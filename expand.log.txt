#![feature(prelude_import)]
#![feature(decl_macro)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub mod errors {
    use std::fmt::Debug;
    use crate::ns::*;
    /// Error used to indicate that verification must be deferred.
    pub struct DeferError(pub Option<u32>);
    #[automatically_derived]
    impl ::core::clone::Clone for DeferError {
        #[inline]
        fn clone(&self) -> DeferError {
            let _: ::core::clone::AssertParamIsClone<Option<u32>>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for DeferError {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DeferError {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DeferError {
        #[inline]
        fn eq(&self, other: &DeferError) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DeferError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "DeferError", &&self.0)
        }
    }
    /// Error used to indicate an ambiguous reference to a local name.
    #[non_exhaustive]
    pub struct AmbiguousReferenceError(pub String);
    #[automatically_derived]
    impl ::core::clone::Clone for AmbiguousReferenceError {
        #[inline]
        fn clone(&self) -> AmbiguousReferenceError {
            AmbiguousReferenceError(::core::clone::Clone::clone(&self.0))
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AmbiguousReferenceError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "AmbiguousReferenceError",
                &&self.0,
            )
        }
    }
    pub enum PropertyLookupError {
        Defer,
        AmbiguousReference(String),
        VoidBase,
        NullableObject { nullable_type: Entity },
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PropertyLookupError {
        #[inline]
        fn clone(&self) -> PropertyLookupError {
            match self {
                PropertyLookupError::Defer => PropertyLookupError::Defer,
                PropertyLookupError::AmbiguousReference(__self_0) => {
                    PropertyLookupError::AmbiguousReference(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                PropertyLookupError::VoidBase => PropertyLookupError::VoidBase,
                PropertyLookupError::NullableObject { nullable_type: __self_0 } => {
                    PropertyLookupError::NullableObject {
                        nullable_type: ::core::clone::Clone::clone(__self_0),
                    }
                }
            }
        }
    }
    impl Debug for PropertyLookupError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(format_args!("PropertyLookupError()"))
        }
    }
    pub struct TypeExpectError();
    #[automatically_derived]
    impl ::core::clone::Clone for TypeExpectError {
        #[inline]
        fn clone(&self) -> TypeExpectError {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TypeExpectError {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TypeExpectError {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TypeExpectError {
        #[inline]
        fn eq(&self, other: &TypeExpectError) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TypeExpectError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "TypeExpectError")
        }
    }
    pub enum MethodOverrideError {
        Defer,
        MustOverrideAMethod,
        IncompatibleOverride { expected_signature: Entity, actual_signature: Entity },
        OverridingFinalMethod,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MethodOverrideError {
        #[inline]
        fn clone(&self) -> MethodOverrideError {
            match self {
                MethodOverrideError::Defer => MethodOverrideError::Defer,
                MethodOverrideError::MustOverrideAMethod => {
                    MethodOverrideError::MustOverrideAMethod
                }
                MethodOverrideError::IncompatibleOverride {
                    expected_signature: __self_0,
                    actual_signature: __self_1,
                } => {
                    MethodOverrideError::IncompatibleOverride {
                        expected_signature: ::core::clone::Clone::clone(__self_0),
                        actual_signature: ::core::clone::Clone::clone(__self_1),
                    }
                }
                MethodOverrideError::OverridingFinalMethod => {
                    MethodOverrideError::OverridingFinalMethod
                }
            }
        }
    }
    impl Debug for MethodOverrideError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(format_args!("MethodOverrideError()"))
        }
    }
}
pub mod semantics {
    mod interface_implement {
        use crate::ns::*;
        pub struct InterfaceImplement<'a>(pub &'a Database);
        impl<'a> InterfaceImplement<'a> {
            pub fn verify(
                &self,
                implementor: &Entity,
                interface: &Entity,
            ) -> Result<Vec<InterfaceImplementationLog>, DeferError> {
                let mut interfaces = interface.all_ascending_types(self.0);
                interfaces.push(interface.clone());
                let mut log: Vec<InterfaceImplementationLog> = ::alloc::vec::Vec::new();
                for interface in interfaces {
                    interface.defer()?;
                    let implementor_prototype = implementor.prototype(self.0);
                    for (name, item) in interface.prototype(self.0).borrow().iter() {
                        let local_name = name.local_name();
                        let implementor_item = implementor_prototype
                            .get_in_any_public_ns(&local_name)
                            .ok()
                            .unwrap_or(None);
                        if implementor_item.is_none() {
                            if item.is::<VirtualSlot>() {
                                if item.getter(self.0).is_some() {
                                    log.push(InterfaceImplementationLog::GetterNotImplemented {
                                        name: local_name.clone(),
                                    });
                                }
                                if item.setter(self.0).is_some() {
                                    log.push(InterfaceImplementationLog::SetterNotImplemented {
                                        name: local_name.clone(),
                                    });
                                }
                            } else {
                                log.push(InterfaceImplementationLog::MethodNotImplemented {
                                    name: local_name.clone(),
                                });
                            }
                        } else if item.is::<VirtualSlot>() {
                            let implementor_item = implementor_item.unwrap();
                            if !implementor_item.is::<VirtualSlot>() {
                                log.push(InterfaceImplementationLog::PropertyMustBeVirtual {
                                    name: local_name.clone(),
                                });
                            } else {
                                if implementor_item.getter(self.0).is_none() {
                                    if item.getter(self.0).is_some() {
                                        log.push(InterfaceImplementationLog::GetterNotImplemented {
                                            name: local_name.clone(),
                                        });
                                    }
                                } else if item.getter(self.0).is_some()
                                    && item.getter(self.0).unwrap().signature(self.0)
                                        != implementor_item
                                            .getter(self.0)
                                            .unwrap()
                                            .signature(self.0)
                                {
                                    let expected_signature = item
                                        .getter(self.0)
                                        .unwrap()
                                        .signature(self.0);
                                    expected_signature.defer()?;
                                    let actual_signature = implementor_item
                                        .getter(self.0)
                                        .unwrap()
                                        .signature(self.0);
                                    actual_signature.defer()?;
                                    log.push(InterfaceImplementationLog::IncompatibleGetterSignature {
                                        name: local_name.clone(),
                                        expected_signature,
                                    });
                                }
                                if implementor_item.setter(self.0).is_none() {
                                    if item.setter(self.0).is_some() {
                                        log.push(InterfaceImplementationLog::SetterNotImplemented {
                                            name: local_name.clone(),
                                        });
                                    }
                                } else if item.setter(self.0).is_some()
                                    && item.setter(self.0).unwrap().signature(self.0)
                                        != implementor_item
                                            .setter(self.0)
                                            .unwrap()
                                            .signature(self.0)
                                {
                                    let expected_signature = item
                                        .setter(self.0)
                                        .unwrap()
                                        .signature(self.0);
                                    expected_signature.defer()?;
                                    let actual_signature = implementor_item
                                        .setter(self.0)
                                        .unwrap()
                                        .signature(self.0);
                                    actual_signature.defer()?;
                                    log.push(InterfaceImplementationLog::IncompatibleSetterSignature {
                                        name: local_name.clone(),
                                        expected_signature,
                                    });
                                }
                            }
                        } else {
                            let implementor_item = implementor_item.unwrap();
                            if !implementor_item.is::<MethodSlot>() {
                                log.push(InterfaceImplementationLog::PropertyMustBeMethod {
                                    name: local_name.clone(),
                                });
                            }
                            let expected_signature = item.signature(self.0);
                            expected_signature.defer()?;
                            let actual_signature = implementor_item.signature(self.0);
                            actual_signature.defer()?;
                            if expected_signature != actual_signature {
                                log.push(InterfaceImplementationLog::IncompatibleMethodSignature {
                                    name: local_name.clone(),
                                    expected_signature,
                                });
                            }
                        }
                    }
                }
                Ok(log)
            }
        }
        /// The log result of verifying interface implementations.
        pub enum InterfaceImplementationLog {
            MethodNotImplemented { name: String },
            GetterNotImplemented { name: String },
            SetterNotImplemented { name: String },
            PropertyMustBeMethod { name: String },
            PropertyMustBeVirtual { name: String },
            IncompatibleMethodSignature { name: String, expected_signature: Entity },
            IncompatibleGetterSignature { name: String, expected_signature: Entity },
            IncompatibleSetterSignature { name: String, expected_signature: Entity },
        }
    }
    pub use interface_implement::*;
    mod method_override {
        use crate::ns::*;
        pub struct MethodOverride<'a>(pub &'a Database);
        impl<'a> MethodOverride<'a> {
            /// Returns a listing of abstract methods that were not overriden.
            /// The resulting list may include method slots which are getters or setters
            /// from a virtual slot.
            pub fn abstract_methods_not_overriden(
                &mut self,
                class: &Entity,
                ns_set: &SharedArray<Entity>,
            ) -> Result<Vec<Entity>, DeferError> {
                let base_class = class.extends_class(self.0);
                if base_class.is_none() {
                    return Ok(::alloc::vec::Vec::new());
                }
                let base_class = base_class.unwrap();
                if base_class.is::<UnresolvedEntity>() {
                    return Err(DeferError(None));
                }
                if &base_class == class {
                    return Ok(::alloc::vec::Vec::new());
                }
                let mut r: Vec<Entity> = ::alloc::vec::Vec::new();
                for (name, prop) in base_class.prototype(self.0).borrow().iter() {
                    if prop.is::<MethodSlot>() {
                        if prop.is_abstract() {
                            let prop2 = if name.namespace().is::<SystemNamespace>() {
                                class
                                    .prototype(self.0)
                                    .get_in_system_ns_kind_in_ns_set(
                                        ns_set,
                                        name.namespace().system_ns_kind().unwrap(),
                                        &name.local_name(),
                                    )
                                    .ok()
                                    .unwrap_or(None)
                            } else {
                                class.prototype(self.0).get(name)
                            };
                            if prop2.is_none() || !prop2.unwrap().is::<MethodSlot>() {
                                r.push(prop.clone());
                            }
                        }
                    } else if prop.is::<VirtualSlot>() {
                        if let Some(getter) = prop.getter(self.0) {
                            if prop.not_overriden_abstract_getter(&getter, class, self.0)
                            {
                                r.push(getter.clone());
                            }
                        }
                        if let Some(setter) = prop.setter(self.0) {
                            if prop.not_overriden_abstract_setter(&setter, class, self.0)
                            {
                                r.push(setter.clone());
                            }
                        }
                    }
                }
                Ok(r)
            }
            pub fn override_method(
                &mut self,
                method: &Entity,
                ns_set: &SharedArray<Entity>,
            ) -> Result<(), MethodOverrideError> {
                let name = method.name();
                let class = method.parent().unwrap();
                if !(class.is::<ClassType>() || class.is::<EnumType>()) {
                    ::core::panicking::panic(
                        "assertion failed: class.is::<ClassType>() || class.is::<EnumType>()",
                    )
                }
                let base_type = class.extends_class(self.0);
                if base_type.is_none() {
                    return Err(MethodOverrideError::MustOverrideAMethod);
                }
                let base_type = base_type.unwrap();
                if base_type == class {
                    return Ok(());
                }
                let base_method = self.lookup_method(&name, &base_type, ns_set)?;
                if base_method.is_none() {
                    return Err(MethodOverrideError::MustOverrideAMethod);
                }
                let mut base_method = base_method.unwrap();
                let virtual_property = method.of_virtual_slot(self.0);
                if let Some(virtual_property) = virtual_property {
                    let is_getter = Some(method.clone())
                        == virtual_property.getter(self.0);
                    if is_getter {
                        if !(base_method.is::<VirtualSlot>()
                            && base_method.getter(self.0).is_some())
                        {
                            return Err(MethodOverrideError::MustOverrideAMethod);
                        }
                        base_method = base_method.getter(self.0).unwrap();
                    } else {
                        if !(base_method.is::<VirtualSlot>()
                            && base_method.setter(self.0).is_some())
                        {
                            return Err(MethodOverrideError::MustOverrideAMethod);
                        }
                        base_method = base_method.setter(self.0).unwrap();
                    }
                } else if !base_method.is::<MethodSlot>() {
                    return Err(MethodOverrideError::MustOverrideAMethod);
                }
                let base_signature = base_method.signature(self.0);
                base_signature.defer().map_err(|_| MethodOverrideError::Defer)?;
                let subtype_signature = method.signature(self.0);
                subtype_signature.defer().map_err(|_| MethodOverrideError::Defer)?;
                if !self.compatible_override(&base_signature, &subtype_signature) {
                    return Err(MethodOverrideError::IncompatibleOverride {
                        expected_signature: base_signature,
                        actual_signature: subtype_signature,
                    });
                }
                if base_method.is_final() {
                    return Err(MethodOverrideError::OverridingFinalMethod);
                }
                base_method.overriden_by(self.0).push(method.clone());
                method.set_overrides_method(Some(base_method));
                Ok(())
            }
            fn lookup_method(
                &mut self,
                name: &QName,
                base_type: &Entity,
                ns_set: &SharedArray<Entity>,
            ) -> Result<Option<Entity>, MethodOverrideError> {
                for class in base_type
                    .descending_class_hierarchy(self.0)
                    .collect::<Vec<_>>()
                {
                    class.defer().map_err(|_| MethodOverrideError::Defer)?;
                    let prop = if name.namespace().is::<SystemNamespace>() {
                        class
                            .prototype(self.0)
                            .get_in_system_ns_kind_in_ns_set(
                                ns_set,
                                name.namespace().system_ns_kind().unwrap(),
                                &name.local_name(),
                            )
                            .ok()
                            .unwrap_or(None)
                    } else {
                        class.prototype(self.0).get(name)
                    };
                    if let Some(prop) = prop {
                        prop.property_static_type(self.0)
                            .defer()
                            .map_err(|_| MethodOverrideError::Defer)?;
                        if prop.is::<VirtualSlot>() {
                            if let Some(getter) = prop.getter(self.0) {
                                getter
                                    .signature(self.0)
                                    .defer()
                                    .map_err(|_| MethodOverrideError::Defer)?;
                            }
                            if let Some(setter) = prop.setter(self.0) {
                                setter
                                    .signature(self.0)
                                    .defer()
                                    .map_err(|_| MethodOverrideError::Defer)?;
                            }
                        }
                        return Ok(Some(prop));
                    }
                }
                Ok(None)
            }
            fn compatible_override(
                &mut self,
                base_signature: &Entity,
                subtype_signature: &Entity,
            ) -> bool {
                base_signature == subtype_signature
            }
        }
    }
    pub use method_override::*;
    mod names {
        use crate::ns::*;
        /// Represents a mapping from a qualified name to a entity
        /// (alias, variable slot, class, or any other thing).
        ///
        /// `Names` is a mutable mapping managed by reference counting.
        ///
        /// # Cloning
        ///
        /// The `clone()` method of `Names` clones the mapping
        /// by reference, and not by content.
        ///
        /// Use `clone_content()` for cloning by content.
        ///
        /// # Iteration
        ///
        /// Iteration over the entries in the name mapping is
        /// performed through the `borrow()` method.
        ///
        /// ```ignore
        /// for (qname, entity) in names.borrow().iter() {
        ///     // Action
        /// });
        /// ```
        pub struct Names(SharedMap<QName, Entity>);
        #[automatically_derived]
        impl ::core::clone::Clone for Names {
            #[inline]
            fn clone(&self) -> Names {
                Names(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Names {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Names {
            #[inline]
            fn eq(&self, other: &Names) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Names {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<SharedMap<QName, Entity>>;
            }
        }
        impl Names {
            pub fn new() -> Self {
                Self(SharedMap::new())
            }
            pub fn get(&self, name: &QName) -> Option<Entity> {
                self.0.get(name)
            }
            /// Retrieves a entity matching a local name in a namespace set.
            pub fn get_in_ns_set(
                &self,
                ns_set: &SharedArray<Entity>,
                local_name: &str,
            ) -> Result<Option<Entity>, AmbiguousReferenceError> {
                let mut r: Option<Entity> = None;
                for (qname, entity) in self.borrow().iter() {
                    let ns1 = qname.namespace();
                    let found_ns = ns_set.iter().find(|ns2| &ns1 == ns2).is_some();
                    if !found_ns {
                        continue;
                    }
                    if qname.local_name() == local_name {
                        if r.is_some() {
                            return Err(AmbiguousReferenceError(local_name.to_owned()));
                        }
                        r = Some(entity.clone());
                    }
                }
                Ok(r)
            }
            /// Retrieves a entity matching a local name in any namespace.
            pub fn get_in_any_ns(
                &self,
                local_name: &str,
            ) -> Result<Option<Entity>, AmbiguousReferenceError> {
                let mut r: Option<Entity> = None;
                for (qname, entity) in self.borrow().iter() {
                    if qname.local_name() == local_name {
                        if r.is_some() {
                            return Err(AmbiguousReferenceError(local_name.to_owned()));
                        }
                        r = Some(entity.clone());
                    }
                }
                Ok(r)
            }
            /// Retrieves a entity matching a local name in a namespace set or in any `public` namespace.
            pub fn get_in_ns_set_or_any_public_ns(
                &self,
                ns_set: &SharedArray<Entity>,
                local_name: &str,
            ) -> Result<Option<Entity>, AmbiguousReferenceError> {
                let mut r: Option<Entity> = None;
                for (qname, entity) in self.borrow().iter() {
                    let ns1 = qname.namespace();
                    if !ns1.is_public_ns() {
                        let found_ns = ns_set.iter().find(|ns2| &ns1 == ns2).is_some();
                        if !found_ns {
                            continue;
                        }
                    }
                    if qname.local_name() == local_name {
                        if r.is_some() {
                            return Err(AmbiguousReferenceError(local_name.to_owned()));
                        }
                        r = Some(entity.clone());
                    }
                }
                Ok(r)
            }
            /// Retrieves a entity matching a local name in a namespace set where the namespace is a specific
            /// system namespace.
            pub fn get_in_system_ns_kind_in_ns_set(
                &self,
                ns_set: &SharedArray<Entity>,
                kind: SystemNamespaceKind,
                local_name: &str,
            ) -> Result<Option<Entity>, AmbiguousReferenceError> {
                let mut r: Option<Entity> = None;
                for (qname, entity) in self.borrow().iter() {
                    let ns1 = qname.namespace();
                    let found_ns = ns_set
                        .iter()
                        .find(|ns2| {
                            &ns1 == ns2
                                && ns1
                                    .system_ns_kind()
                                    .map(|k1| kind == k1)
                                    .unwrap_or(false)
                        })
                        .is_some();
                    if !found_ns {
                        continue;
                    }
                    if qname.local_name() == local_name {
                        if r.is_some() {
                            return Err(AmbiguousReferenceError(local_name.to_owned()));
                        }
                        r = Some(entity.clone());
                    }
                }
                Ok(r)
            }
            /// Retrieves a entity matching a local name in any `public` namespace.
            pub fn get_in_any_public_ns(
                &self,
                local_name: &str,
            ) -> Result<Option<Entity>, AmbiguousReferenceError> {
                let mut r: Option<Entity> = None;
                for (qname, entity) in self.borrow().iter() {
                    if qname.local_name() == local_name
                        && qname.namespace().is_public_ns()
                    {
                        if r.is_some() {
                            return Err(AmbiguousReferenceError(local_name.to_owned()));
                        }
                        r = Some(entity.clone());
                    }
                }
                Ok(r)
            }
            /// Retrieves a entity matching a local name in any `internal` namespace.
            pub fn get_in_any_internal_ns(
                &self,
                local_name: &str,
            ) -> Result<Option<Entity>, AmbiguousReferenceError> {
                let mut r: Option<Entity> = None;
                for (qname, entity) in self.borrow().iter() {
                    if qname.local_name() == local_name
                        && qname.namespace().is_internal_ns()
                    {
                        if r.is_some() {
                            return Err(AmbiguousReferenceError(local_name.to_owned()));
                        }
                        r = Some(entity.clone());
                    }
                }
                Ok(r)
            }
            /// Retrieves a entity matching a local name in a specific system namespace kind.
            pub fn get_in_system_ns_kind(
                &self,
                kind: SystemNamespaceKind,
                local_name: &str,
            ) -> Result<Option<Entity>, AmbiguousReferenceError> {
                let mut r: Option<Entity> = None;
                for (qname, entity) in self.borrow().iter() {
                    if qname.local_name() == local_name
                        && qname
                            .namespace()
                            .system_ns_kind()
                            .map(|k1| kind == k1)
                            .unwrap_or(false)
                    {
                        if r.is_some() {
                            return Err(AmbiguousReferenceError(local_name.to_owned()));
                        }
                        r = Some(entity.clone());
                    }
                }
                Ok(r)
            }
            pub fn set(&mut self, name: QName, thing: Entity) {
                self.0.set(name, thing);
            }
            pub fn delete(&mut self, name: &QName) -> bool {
                self.0.remove(name).is_some()
            }
            /// The `borrow()` method may be used for iteration. Refer to the
            /// [`Names`] documentation for an example.
            pub fn borrow(&self) -> std::cell::Ref<HashMap<QName, Entity>> {
                self.0.borrow()
            }
            pub fn borrow_mut(&mut self) -> std::cell::RefMut<HashMap<QName, Entity>> {
                self.0.borrow_mut()
            }
            /// Clones this `Names` by content, and not by reference.
            pub fn clone_content(&self) -> Self {
                Self(self.0.clone_content())
            }
            pub fn length(&self) -> usize {
                self.0.length()
            }
            pub fn clear(&mut self) {
                self.0.clear();
            }
            pub fn has(&self, name: &QName) -> bool {
                self.0.borrow().contains_key(name)
            }
        }
    }
    pub use names::*;
    mod number {
        use crate::ns::*;
        use num_traits::FromPrimitive;
        use std::ops::{Add, BitAnd, BitOr, BitXor, Div, Mul, Rem, Shl, Shr, Sub};
        /// Represents a numeric value represented as one of the data types
        /// `Number`, `float`, `uint`, or `int`.
        pub enum Number {
            Number(f64),
            Float(f32),
            Int(i32),
            Uint(u32),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Number {
            #[inline]
            fn clone(&self) -> Number {
                match self {
                    Number::Number(__self_0) => {
                        Number::Number(::core::clone::Clone::clone(__self_0))
                    }
                    Number::Float(__self_0) => {
                        Number::Float(::core::clone::Clone::clone(__self_0))
                    }
                    Number::Int(__self_0) => {
                        Number::Int(::core::clone::Clone::clone(__self_0))
                    }
                    Number::Uint(__self_0) => {
                        Number::Uint(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Number {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Number {
            #[inline]
            fn eq(&self, other: &Number) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (Number::Number(__self_0), Number::Number(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (Number::Float(__self_0), Number::Float(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (Number::Int(__self_0), Number::Int(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (Number::Uint(__self_0), Number::Uint(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for Number {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Number,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                match (self, other) {
                    (Number::Number(__self_0), Number::Number(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (Number::Float(__self_0), Number::Float(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (Number::Int(__self_0), Number::Int(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (Number::Uint(__self_0), Number::Uint(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    _ => {
                        ::core::cmp::PartialOrd::partial_cmp(
                            &__self_discr,
                            &__arg1_discr,
                        )
                    }
                }
            }
        }
        impl Add for Number {
            type Output = Self;
            fn add(self, rhs: Self) -> Self::Output {
                match self {
                    Self::Float(v) => {
                        let rhs = rhs.force_float();
                        Self::Float(v + rhs)
                    }
                    Self::Number(v) => {
                        let rhs = rhs.force_double();
                        Self::Number(v + rhs)
                    }
                    Self::Int(v) => {
                        let rhs = rhs.force_int();
                        Self::Int(v.checked_add(rhs).unwrap_or(0))
                    }
                    Self::Uint(v) => {
                        let rhs = rhs.force_uint();
                        Self::Uint(v.checked_add(rhs).unwrap_or(0))
                    }
                }
            }
        }
        impl Sub for Number {
            type Output = Self;
            fn sub(self, rhs: Self) -> Self::Output {
                match self {
                    Self::Float(v) => {
                        let rhs = rhs.force_float();
                        Self::Float(v - rhs)
                    }
                    Self::Number(v) => {
                        let rhs = rhs.force_double();
                        Self::Number(v - rhs)
                    }
                    Self::Int(v) => {
                        let rhs = rhs.force_int();
                        Self::Int(v.checked_sub(rhs).unwrap_or(0))
                    }
                    Self::Uint(v) => {
                        let rhs = rhs.force_uint();
                        Self::Uint(v.checked_sub(rhs).unwrap_or(0))
                    }
                }
            }
        }
        impl Mul for Number {
            type Output = Self;
            fn mul(self, rhs: Self) -> Self::Output {
                match self {
                    Self::Float(v) => {
                        let rhs = rhs.force_float();
                        Self::Float(v * rhs)
                    }
                    Self::Number(v) => {
                        let rhs = rhs.force_double();
                        Self::Number(v * rhs)
                    }
                    Self::Int(v) => {
                        let rhs = rhs.force_int();
                        Self::Int(v.checked_mul(rhs).unwrap_or(0))
                    }
                    Self::Uint(v) => {
                        let rhs = rhs.force_uint();
                        Self::Uint(v.checked_mul(rhs).unwrap_or(0))
                    }
                }
            }
        }
        impl Div for Number {
            type Output = Self;
            fn div(self, rhs: Self) -> Self::Output {
                match self {
                    Self::Float(v) => {
                        let rhs = rhs.force_float();
                        Self::Float(v / rhs)
                    }
                    Self::Number(v) => {
                        let rhs = rhs.force_double();
                        Self::Number(v / rhs)
                    }
                    Self::Int(v) => {
                        let rhs = rhs.force_int();
                        Self::Int(v.checked_div(rhs).unwrap_or(0))
                    }
                    Self::Uint(v) => {
                        let rhs = rhs.force_uint();
                        Self::Uint(v.checked_div(rhs).unwrap_or(0))
                    }
                }
            }
        }
        impl Rem for Number {
            type Output = Self;
            fn rem(self, rhs: Self) -> Self::Output {
                match self {
                    Self::Float(v) => {
                        let rhs = rhs.force_float();
                        Self::Float(v % rhs)
                    }
                    Self::Number(v) => {
                        let rhs = rhs.force_double();
                        Self::Number(v % rhs)
                    }
                    Self::Int(v) => {
                        let rhs = rhs.force_int();
                        Self::Int(v.checked_rem(rhs).unwrap_or(0))
                    }
                    Self::Uint(v) => {
                        let rhs = rhs.force_uint();
                        Self::Uint(v.checked_rem(rhs).unwrap_or(0))
                    }
                }
            }
        }
        impl std::ops::Neg for Number {
            type Output = Self;
            fn neg(self) -> Self::Output {
                match self {
                    Self::Float(v) => Self::Float(-v),
                    Self::Number(v) => Self::Number(-v),
                    Self::Int(v) => Self::Int(-v),
                    Self::Uint(v) => Self::Uint(v),
                }
            }
        }
        impl BitAnd for Number {
            type Output = Self;
            fn bitand(self, rhs: Self) -> Self::Output {
                match self {
                    Self::Float(v) => {
                        let rhs = rhs.force_float();
                        Self::Float(
                            f32::from_u32(
                                    unsafe { v.to_int_unchecked::<u32>() }
                                        & unsafe { rhs.to_int_unchecked::<u32>() },
                                )
                                .unwrap_or(0.0),
                        )
                    }
                    Self::Number(v) => {
                        let rhs = rhs.force_double();
                        Self::Number(
                            f64::from_u32(
                                    unsafe { v.to_int_unchecked::<u32>() }
                                        & unsafe { rhs.to_int_unchecked::<u32>() },
                                )
                                .unwrap_or(0.0),
                        )
                    }
                    Self::Int(v) => {
                        let rhs = rhs.force_int();
                        Self::Int(v & rhs)
                    }
                    Self::Uint(v) => {
                        let rhs = rhs.force_uint();
                        Self::Uint(v & rhs)
                    }
                }
            }
        }
        impl BitXor for Number {
            type Output = Self;
            fn bitxor(self, rhs: Self) -> Self::Output {
                match self {
                    Self::Float(v) => {
                        let rhs = rhs.force_float();
                        Self::Float(
                            f32::from_u32(
                                    unsafe { v.to_int_unchecked::<u32>() }
                                        ^ unsafe { rhs.to_int_unchecked::<u32>() },
                                )
                                .unwrap_or(0.0),
                        )
                    }
                    Self::Number(v) => {
                        let rhs = rhs.force_double();
                        Self::Number(
                            f64::from_u32(
                                    unsafe { v.to_int_unchecked::<u32>() }
                                        ^ unsafe { rhs.to_int_unchecked::<u32>() },
                                )
                                .unwrap_or(0.0),
                        )
                    }
                    Self::Int(v) => {
                        let rhs = rhs.force_int();
                        Self::Int(v ^ rhs)
                    }
                    Self::Uint(v) => {
                        let rhs = rhs.force_uint();
                        Self::Uint(v ^ rhs)
                    }
                }
            }
        }
        impl BitOr for Number {
            type Output = Self;
            fn bitor(self, rhs: Self) -> Self::Output {
                match self {
                    Self::Float(v) => {
                        let rhs = rhs.force_float();
                        Self::Float(
                            f32::from_u32(
                                    unsafe { v.to_int_unchecked::<u32>() }
                                        | unsafe { rhs.to_int_unchecked::<u32>() },
                                )
                                .unwrap_or(0.0),
                        )
                    }
                    Self::Number(v) => {
                        let rhs = rhs.force_double();
                        Self::Number(
                            f64::from_u32(
                                    unsafe { v.to_int_unchecked::<u32>() }
                                        | unsafe { rhs.to_int_unchecked::<u32>() },
                                )
                                .unwrap_or(0.0),
                        )
                    }
                    Self::Int(v) => {
                        let rhs = rhs.force_int();
                        Self::Int(v | rhs)
                    }
                    Self::Uint(v) => {
                        let rhs = rhs.force_uint();
                        Self::Uint(v | rhs)
                    }
                }
            }
        }
        impl Shl for Number {
            type Output = Self;
            fn shl(self, rhs: Self) -> Self::Output {
                match self {
                    Self::Float(v) => {
                        let rhs = rhs.force_float();
                        Self::Float(
                            f32::from_u32(
                                    unsafe { v.to_int_unchecked::<u32>() }
                                        .checked_shl(unsafe { rhs.to_int_unchecked::<u32>() })
                                        .unwrap_or(0),
                                )
                                .unwrap_or(0.0),
                        )
                    }
                    Self::Number(v) => {
                        let rhs = rhs.force_double();
                        Self::Number(
                            f64::from_u32(
                                    unsafe { v.to_int_unchecked::<u32>() }
                                        .checked_shl(unsafe { rhs.to_int_unchecked::<u32>() })
                                        .unwrap_or(0),
                                )
                                .unwrap_or(0.0),
                        )
                    }
                    Self::Int(v) => {
                        let rhs = rhs.force_int();
                        Self::Int(
                            v.checked_shl(rhs.try_into().unwrap_or(0)).unwrap_or(0),
                        )
                    }
                    Self::Uint(v) => {
                        let rhs = rhs.force_uint();
                        Self::Uint(v.checked_shl(rhs).unwrap_or(0))
                    }
                }
            }
        }
        impl Shr for Number {
            type Output = Self;
            fn shr(self, rhs: Self) -> Self::Output {
                match self {
                    Self::Float(v) => {
                        let rhs = rhs.force_float();
                        Self::Float(
                            f32::from_u32(
                                    unsafe { v.to_int_unchecked::<u32>() }
                                        .checked_shr(unsafe { rhs.to_int_unchecked::<u32>() })
                                        .unwrap_or(0),
                                )
                                .unwrap_or(0.0),
                        )
                    }
                    Self::Number(v) => {
                        let rhs = rhs.force_double();
                        Self::Number(
                            f64::from_u32(
                                    unsafe { v.to_int_unchecked::<u32>() }
                                        .checked_shr(unsafe { rhs.to_int_unchecked::<u32>() })
                                        .unwrap_or(0),
                                )
                                .unwrap_or(0.0),
                        )
                    }
                    Self::Int(v) => {
                        let rhs = rhs.force_int();
                        Self::Int(
                            v.checked_shr(rhs.try_into().unwrap_or(0)).unwrap_or(0),
                        )
                    }
                    Self::Uint(v) => {
                        let rhs = rhs.force_uint();
                        Self::Uint(v.checked_shr(rhs).unwrap_or(0))
                    }
                }
            }
        }
        impl Number {
            pub fn zero(type_thing: &Entity, host: &Database) -> Self {
                if type_thing == &host.number_type() {
                    Self::Number(0.0)
                } else if type_thing == &host.int_type() {
                    Self::Int(0)
                } else if type_thing == &host.uint_type() {
                    Self::Uint(0)
                } else if type_thing == &host.float_type() {
                    Self::Float(0.0)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                }
            }
            pub fn nan(type_thing: &Entity, host: &Database) -> Self {
                if type_thing == &host.number_type() {
                    Self::Number(f64::NAN)
                } else if type_thing == &host.float_type() {
                    Self::Float(f32::NAN)
                } else {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("Type does not support NaN."),
                        );
                    };
                }
            }
            pub fn one(type_thing: &Entity, host: &Database) -> Self {
                if type_thing == &host.number_type() {
                    Self::Number(1.0)
                } else if type_thing == &host.int_type() {
                    Self::Int(1)
                } else if type_thing == &host.uint_type() {
                    Self::Uint(1)
                } else if type_thing == &host.float_type() {
                    Self::Float(1.0)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                }
            }
            pub fn minimum_value(type_thing: &Entity, host: &Database) -> Self {
                if type_thing == &host.number_type() {
                    Self::Number(f64::NEG_INFINITY)
                } else if type_thing == &host.int_type() {
                    Self::Int(i32::MIN)
                } else if type_thing == &host.uint_type() {
                    Self::Uint(0)
                } else if type_thing == &host.float_type() {
                    Self::Float(f32::NEG_INFINITY)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                }
            }
            pub fn maximum_value(type_thing: &Entity, host: &Database) -> Self {
                if type_thing == &host.number_type() {
                    Self::Number(f64::INFINITY)
                } else if type_thing == &host.int_type() {
                    Self::Int(i32::MAX)
                } else if type_thing == &host.uint_type() {
                    Self::Uint(u32::MAX)
                } else if type_thing == &host.float_type() {
                    Self::Float(f32::INFINITY)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                }
            }
            pub fn is_zero(&self) -> bool {
                match self {
                    Self::Float(v) => v == &0.0,
                    Self::Number(v) => v == &0.0,
                    Self::Int(v) => v == &0,
                    Self::Uint(v) => v == &0,
                }
            }
            pub fn is_one(&self) -> bool {
                match self {
                    Self::Float(v) => v == &1.0,
                    Self::Number(v) => v == &1.0,
                    Self::Int(v) => v == &1,
                    Self::Uint(v) => v == &1,
                }
            }
            pub fn multiply_per_two(&self) -> Self {
                match self {
                    Self::Float(v) => Self::Float(v * 2.0),
                    Self::Number(v) => Self::Number(v * 2.0),
                    Self::Int(v) => Self::Int(v * 2),
                    Self::Uint(v) => Self::Uint(v * 2),
                }
            }
            pub fn increase_by_one(&self) -> Self {
                match self {
                    Self::Float(v) => Self::Float(v + 1.0),
                    Self::Number(v) => Self::Number(v + 1.0),
                    Self::Int(v) => Self::Int(v + 1),
                    Self::Uint(v) => Self::Uint(v + 1),
                }
            }
            /// Performs bitwise OR if `value` is true or erases bits with the `erase_bits()` method otherwise.
            pub fn apply_bits(&self, bits: &Self, value: bool) -> Self {
                if value { self.clone() | bits.clone() } else { self.erase_bits(bits) }
            }
            /// Erases bits if all of such bits are included in the base value.
            pub fn erase_bits(&self, bits: &Self) -> Self {
                if self.includes_bits(bits) {
                    self.clone() ^ bits.clone()
                } else {
                    self.clone()
                }
            }
            pub fn bitwise_not(&self) -> Self {
                match self {
                    Self::Float(v) => {
                        Self::Float(
                            f32::from_u32(unsafe { !v.to_int_unchecked::<u32>() })
                                .unwrap_or(0.0),
                        )
                    }
                    Self::Number(v) => {
                        Self::Number(
                            f64::from_u32(unsafe { !v.to_int_unchecked::<u32>() })
                                .unwrap_or(0.0),
                        )
                    }
                    Self::Int(v) => Self::Int(!v),
                    Self::Uint(v) => Self::Uint(!v),
                }
            }
            pub fn shift_right_unsigned(&self, rhs: &Self) -> Self {
                match self {
                    Self::Float(v) => {
                        let rhs = rhs.force_float();
                        Self::Float(
                            f32::from_u32(
                                    unsafe { v.to_int_unchecked::<u32>() }
                                        .checked_shr(unsafe { rhs.to_int_unchecked::<u32>() })
                                        .unwrap_or(0),
                                )
                                .unwrap_or(0.0),
                        )
                    }
                    Self::Number(v) => {
                        let rhs = rhs.force_double();
                        Self::Number(
                            f64::from_u32(
                                    unsafe { v.to_int_unchecked::<u32>() }
                                        .checked_shr(unsafe { rhs.to_int_unchecked::<u32>() })
                                        .unwrap_or(0),
                                )
                                .unwrap_or(0.0),
                        )
                    }
                    Self::Int(v) => {
                        let rhs = rhs.force_int();
                        let uint1: u32 = (*v).try_into().unwrap_or(0);
                        let uint2: u32 = rhs.try_into().unwrap_or(0);
                        let v = uint1.checked_shr(uint2).unwrap_or(0);
                        let v: i32 = v.try_into().unwrap_or(0);
                        Self::Int(v)
                    }
                    Self::Uint(v) => {
                        let rhs = rhs.force_uint();
                        Self::Uint(v.checked_shr(rhs).unwrap_or(0))
                    }
                }
            }
            pub fn includes_bits(&self, rhs: &Self) -> bool {
                match self {
                    Self::Float(v) => {
                        let Self::Float(rhs) = rhs else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            };
                        };
                        (unsafe { v.to_int_unchecked::<u32>() }
                            & unsafe { rhs.to_int_unchecked::<u32>() } != 0)
                    }
                    Self::Number(v) => {
                        let Self::Number(rhs) = rhs else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            };
                        };
                        (unsafe { v.to_int_unchecked::<u32>() }
                            & unsafe { rhs.to_int_unchecked::<u32>() } != 0)
                    }
                    Self::Int(v) => {
                        let Self::Int(rhs) = rhs else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            };
                        };
                        v & rhs != 0
                    }
                    Self::Uint(v) => {
                        let Self::Uint(rhs) = rhs else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            };
                        };
                        v & rhs != 0
                    }
                }
            }
            pub fn is_power_of_two(&self) -> bool {
                match self {
                    Self::Float(v) => {
                        let v = unsafe { v.to_int_unchecked::<u32>() };
                        (v != 0) && ((v & (v - 1)) == 0)
                    }
                    Self::Number(v) => {
                        let v = unsafe { v.to_int_unchecked::<u32>() };
                        (v != 0) && ((v & (v - 1)) == 0)
                    }
                    Self::Int(v) => (v != &0) && ((v & (v - 1)) == 0),
                    Self::Uint(v) => (v != &0) && ((v & (v - 1)) == 0),
                }
            }
            pub fn convert_type(
                &self,
                target_type: &Entity,
                host: &Database,
            ) -> Result<Self, DeferError> {
                let number_type = host.number_type().defer()?;
                let float_type = host.float_type().defer()?;
                let int_type = host.int_type().defer()?;
                let uint_type = host.int_type().defer()?;
                Ok(
                    if target_type == &number_type {
                        Self::Number(self.force_double())
                    } else if target_type == &float_type {
                        Self::Float(self.force_float())
                    } else if target_type == &int_type {
                        Self::Int(self.force_int())
                    } else if target_type == &uint_type {
                        Self::Uint(self.force_uint())
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    },
                )
            }
            pub fn is_nan(&self) -> bool {
                match self {
                    Self::Number(f) => f.is_nan(),
                    Self::Float(f) => f.is_nan(),
                    _ => false,
                }
            }
            pub fn is_negative_infinity(&self) -> bool {
                match self {
                    Self::Number(f) => f == &f64::NEG_INFINITY,
                    Self::Float(f) => f == &f32::NEG_INFINITY,
                    _ => false,
                }
            }
            pub fn is_positive_infinity(&self) -> bool {
                match self {
                    Self::Number(f) => f == &f64::INFINITY,
                    Self::Float(f) => f == &f32::INFINITY,
                    _ => false,
                }
            }
            pub fn as_double(&self) -> Option<f64> {
                if let Number::Number(v) = self { Some(*v) } else { None }
            }
            pub fn as_float(&self) -> Option<f32> {
                if let Number::Float(v) = self { Some(*v) } else { None }
            }
            pub fn as_int(&self) -> Option<i32> {
                if let Number::Int(v) = self { Some(*v) } else { None }
            }
            pub fn as_uint(&self) -> Option<u32> {
                if let Number::Uint(v) = self { Some(*v) } else { None }
            }
            pub fn force_double(&self) -> f64 {
                match self {
                    Self::Number(v) => *v,
                    Self::Float(v) => *v as f64,
                    Self::Int(v) => {
                        let v: Result<i32, _> = (*v).try_into();
                        v.map(|v| v as f64).unwrap_or(f64::NAN)
                    }
                    Self::Uint(v) => {
                        let v: Result<u32, _> = (*v).try_into();
                        v.map(|v| v as f64).unwrap_or(f64::NAN)
                    }
                }
            }
            pub fn force_float(&self) -> f32 {
                match self {
                    Self::Float(v) => *v,
                    Self::Number(v) => *v as f32,
                    Self::Int(v) => {
                        let v: Result<i32, _> = (*v).try_into();
                        v.map(|v| v as f32).unwrap_or(f32::NAN)
                    }
                    Self::Uint(v) => {
                        let v: Result<u32, _> = (*v).try_into();
                        v.map(|v| v as f32).unwrap_or(f32::NAN)
                    }
                }
            }
            pub fn force_int(&self) -> i32 {
                match self {
                    Self::Float(v) => {
                        if v.is_infinite() {
                            if v.is_sign_negative() { i32::MIN } else { i32::MAX }
                        } else if v.is_nan() {
                            0
                        } else {
                            unsafe { v.to_int_unchecked() }
                        }
                    }
                    Self::Number(v) => {
                        if v.is_infinite() {
                            if v.is_sign_negative() { i32::MIN } else { i32::MAX }
                        } else if v.is_nan() {
                            0
                        } else {
                            unsafe { v.to_int_unchecked() }
                        }
                    }
                    Self::Int(v) => (*v).try_into().unwrap_or(0),
                    Self::Uint(v) => (*v).try_into().unwrap_or(0),
                }
            }
            pub fn force_uint(&self) -> u32 {
                match self {
                    Self::Float(v) => {
                        if v.is_infinite() {
                            if v.is_sign_negative() { u32::MIN } else { u32::MAX }
                        } else if v.is_nan() {
                            0
                        } else {
                            unsafe { v.to_int_unchecked() }
                        }
                    }
                    Self::Number(v) => {
                        if v.is_infinite() {
                            if v.is_sign_negative() { u32::MIN } else { u32::MAX }
                        } else if v.is_nan() {
                            0
                        } else {
                            unsafe { v.to_int_unchecked() }
                        }
                    }
                    Self::Int(v) => (*v).try_into().unwrap_or(0),
                    Self::Uint(v) => (*v).try_into().unwrap_or(0),
                }
            }
        }
    }
    pub use number::*;
    mod property_lookup {
        use crate::ns::*;
        pub struct PropertyLookup<'a>(pub &'a Database);
        pub enum PropertyLookupKey {
            LocalName(String),
            Computed(Entity),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PropertyLookupKey {
            #[inline]
            fn clone(&self) -> PropertyLookupKey {
                match self {
                    PropertyLookupKey::LocalName(__self_0) => {
                        PropertyLookupKey::LocalName(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    PropertyLookupKey::Computed(__self_0) => {
                        PropertyLookupKey::Computed(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        impl PropertyLookupKey {
            pub fn computed_or_local_name(
                &self,
                host: &Database,
            ) -> Result<Entity, DeferError> {
                match self {
                    Self::LocalName(s) => {
                        let string_type = host.string_type().defer()?;
                        Ok(
                            host
                                .factory()
                                .create_string_constant(s.clone(), &string_type),
                        )
                    }
                    Self::Computed(s) => Ok(s.clone()),
                }
            }
            pub fn static_type(&self, host: &Database) -> Result<Entity, DeferError> {
                match self {
                    Self::LocalName(_) => host.string_type().defer(),
                    Self::Computed(s) => s.static_type(host).defer(),
                }
            }
            pub fn local_name(&self) -> Option<String> {
                match self {
                    Self::LocalName(s) => Some(s.clone()),
                    _ => None,
                }
            }
            pub fn double_value(&self) -> Result<Option<f64>, DeferError> {
                Ok(
                    match self {
                        Self::Computed(d) => {
                            if d.is::<NumberConstant>() {
                                Some(d.number_value().force_double())
                            } else {
                                None
                            }
                        }
                        _ => None,
                    },
                )
            }
        }
        fn defer(entity: &Entity) -> Result<Entity, PropertyLookupError> {
            if entity.is::<UnresolvedEntity>() {
                Err(PropertyLookupError::Defer)
            } else {
                Ok(entity.clone())
            }
        }
        fn map_defer_error<T>(
            result: Result<T, DeferError>,
        ) -> Result<T, PropertyLookupError> {
            result.map_err(|_| PropertyLookupError::Defer)
        }
        impl<'a> PropertyLookup<'a> {
            pub fn lookup_in_object(
                &self,
                base: &Entity,
                open_ns_set: &SharedArray<Entity>,
                qual: Option<Entity>,
                key: &PropertyLookupKey,
                calling: bool,
            ) -> Result<Option<Entity>, PropertyLookupError> {
                if base.is::<InvalidationEntity>() {
                    return Ok(Some(base.clone()));
                }
                let local_name = key.local_name();
                let double_key = map_defer_error(key.double_value())?;
                if base.is_class_or_equivalent() {
                    let Some(local_name) = local_name else {
                        return Ok(None);
                    };
                    if qual
                        .as_ref()
                        .map(|q| q.is_namespace_or_ns_constant())
                        .unwrap_or(true)
                    {
                        let k = map_defer_error(
                            PropertyLookupKey::LocalName(local_name)
                                .computed_or_local_name(self.0),
                        )?;
                        return Ok(
                            Some(
                                self
                                    .0
                                    .factory()
                                    .create_static_dynamic_reference_value(base, qual, &k),
                            ),
                        );
                    }
                    for class in base
                        .descending_class_hierarchy(self.0)
                        .collect::<Vec<_>>()
                    {
                        defer(&class)?;
                        let r = self
                            .get_qname_in_ns_set_or_any_public_ns(
                                &class.properties(self.0),
                                open_ns_set,
                                qual.clone(),
                                &local_name,
                            )?;
                        if let Some(r) = r {
                            Unused(self.0).mark_used(&r);
                            let r = r.resolve_alias();
                            defer(&r.property_static_type(self.0))?;
                            return Ok(
                                Some(map_defer_error(r.wrap_property_reference(self.0))?),
                            );
                        }
                    }
                    return Ok(None);
                }
                if base.is_interface_type_possibly_after_sub() {
                    let Some(key) = local_name else {
                        return Ok(None);
                    };
                    if qual
                        .as_ref()
                        .map(|q| q.is_namespace_or_ns_constant())
                        .unwrap_or(true)
                    {
                        let k = map_defer_error(
                            PropertyLookupKey::LocalName(key)
                                .computed_or_local_name(self.0),
                        )?;
                        return Ok(
                            Some(
                                self
                                    .0
                                    .factory()
                                    .create_static_dynamic_reference_value(base, qual, &k),
                            ),
                        );
                    }
                    return Ok(None);
                }
                if base.is::<Value>() {
                    let base_type = defer(&base.static_type(self.0))?;
                    let base_esc_type = base_type.escape_of_non_nullable();
                    if base_esc_type.is::<InvalidationEntity>() {
                        return Ok(Some(base_esc_type.clone()));
                    }
                    if !calling {
                        if [defer(&self.0.xml_type())?, defer(&self.0.xml_list_type())?]
                            .contains(&base_esc_type)
                        {
                            let k = map_defer_error(key.computed_or_local_name(self.0))?;
                            return Ok(
                                Some(
                                    self.0.factory().create_xml_reference_value(base, qual, &k),
                                ),
                            );
                        }
                    }
                    let has_known_ns = qual
                        .as_ref()
                        .map(|q| q.is_namespace_or_ns_constant())
                        .unwrap_or(true);
                    let Some(local_name) = local_name else {
                        if let Some(_) = map_defer_error(
                            base_esc_type.array_element_type(self.0),
                        )? {
                            let iv: Option<Entity> = map_defer_error(
                                ConversionMethods(self.0)
                                    .implicit(
                                        &map_defer_error(key.computed_or_local_name(self.0))?,
                                        &defer(&self.0.number_type())?,
                                        false,
                                    ),
                            )?;
                            if let Some(iv) = iv {
                                return Ok(
                                    Some(
                                        map_defer_error(
                                            self
                                                .0
                                                .factory()
                                                .create_array_element_reference_value(&base, &iv),
                                        )?,
                                    ),
                                );
                            }
                        }
                        if let Some(_) = map_defer_error(
                            base_esc_type.vector_element_type(self.0),
                        )? {
                            let iv: Option<Entity> = map_defer_error(
                                ConversionMethods(self.0)
                                    .implicit(
                                        &map_defer_error(key.computed_or_local_name(self.0))?,
                                        &defer(&self.0.number_type())?,
                                        false,
                                    ),
                            )?;
                            if let Some(iv) = iv {
                                return Ok(
                                    Some(
                                        map_defer_error(
                                            self
                                                .0
                                                .factory()
                                                .create_vector_element_reference_value(&base, &iv),
                                        )?,
                                    ),
                                );
                            }
                        }
                        if double_key.is_some() && base_esc_type.is::<TupleType>() {
                            let index: usize = unsafe {
                                double_key.unwrap().to_int_unchecked()
                            };
                            if index >= base_type.element_types().length() {
                                return Ok(None);
                            }
                            return Ok(
                                Some(
                                    self.0.factory().create_tuple_reference_value(&base, index),
                                ),
                            );
                        }
                        let k = map_defer_error(key.computed_or_local_name(self.0))?;
                        return Ok(
                            Some(
                                self
                                    .0
                                    .factory()
                                    .create_dynamic_reference_value(base, qual, &k),
                            ),
                        );
                    };
                    let any_or_object = [
                        self.0.any_type(),
                        defer(&self.0.object_type())?,
                    ]
                        .contains(&base_esc_type);
                    if any_or_object || !has_known_ns {
                        if qual.is_none() {
                            if base.is::<MetaProperty>() {
                                if local_name == "env" {
                                    return Ok(Some(self.0.meta_env_property()));
                                }
                                return Ok(None);
                            }
                            if base.is::<MetaEnvProperty>() {
                                let ev_dict = self.0.env();
                                if let Some(ev) = ev_dict.get(&local_name) {
                                    let string_type = defer(&self.0.string_type())?;
                                    return Ok(
                                        Some(
                                            self
                                                .0
                                                .factory()
                                                .create_string_constant(ev.clone(), &string_type),
                                        ),
                                    );
                                } else {
                                    return Ok(None);
                                }
                            }
                        }
                        let k = map_defer_error(key.computed_or_local_name(self.0))?;
                        return Ok(
                            Some(
                                self
                                    .0
                                    .factory()
                                    .create_dynamic_reference_value(base, qual, &k),
                            ),
                        );
                    }
                    if base_esc_type.is_class_or_equivalent() {
                        for class in base_esc_type
                            .descending_class_hierarchy(self.0)
                            .collect::<Vec<_>>()
                        {
                            defer(&class)?;
                            let prop = self
                                .get_qname_in_ns_set_or_any_public_ns(
                                    &class.prototype(self.0),
                                    open_ns_set,
                                    qual.clone(),
                                    &local_name,
                                )?;
                            if let Some(prop) = prop {
                                Unused(self.0).mark_used(&prop);
                                let prop = prop.resolve_alias();
                                defer(&prop.property_static_type(self.0))?;
                                if prop.is_namespace_or_ns_constant() {
                                    return Ok(
                                        Some(
                                            map_defer_error(
                                                self.0.factory().create_namespace_constant(&prop),
                                            )?,
                                        ),
                                    );
                                }
                                return Ok(
                                    Some(
                                        map_defer_error(
                                            self
                                                .0
                                                .factory()
                                                .create_instance_reference_value(&base, &prop),
                                        )?,
                                    ),
                                );
                            }
                        }
                    } else if base_esc_type.is_interface_type_possibly_after_sub() {
                        for itrfc in base_esc_type
                            .all_ascending_types(self.0)
                            .iter()
                            .rev()
                        {
                            defer(itrfc)?;
                            let prop = self
                                .get_qname_in_ns_set_or_any_public_ns(
                                    &itrfc.prototype(self.0),
                                    open_ns_set,
                                    qual.clone(),
                                    &local_name,
                                )?;
                            if let Some(prop) = prop {
                                Unused(self.0).mark_used(&prop);
                                defer(&prop.property_static_type(self.0))?;
                                return Ok(
                                    Some(
                                        map_defer_error(
                                            self
                                                .0
                                                .factory()
                                                .create_instance_reference_value(&base, &prop),
                                        )?,
                                    ),
                                );
                            }
                        }
                    }
                    if base_type.escape_of_non_nullable().is_dynamic()
                        || base_type.escape_of_non_nullable()
                            == map_defer_error(self.0.dictionary_type().defer())?
                    {
                        let k = map_defer_error(key.computed_or_local_name(self.0))?;
                        return Ok(
                            Some(
                                self
                                    .0
                                    .factory()
                                    .create_dynamic_reference_value(base, qual, &k),
                            ),
                        );
                    }
                    return Ok(None);
                }
                if base.is::<Package>() {
                    let Some(local_name) = local_name else {
                        return Ok(None);
                    };
                    if qual
                        .as_ref()
                        .map(|q| q.is_namespace_or_ns_constant())
                        .unwrap_or(true)
                    {
                        return Ok(None);
                    }
                    let mut r: Option<Entity> = None;
                    let prop = self
                        .get_qname_in_ns_set_or_any_public_ns(
                            &base.properties(self.0),
                            open_ns_set,
                            qual.clone(),
                            &local_name,
                        )?;
                    if let Some(prop) = prop {
                        Unused(self.0).mark_used(&prop);
                        let prop = prop.resolve_alias();
                        defer(&prop.property_static_type(self.0))?;
                        r = Some(map_defer_error(prop.wrap_property_reference(self.0))?);
                    } else if base == &self.0.top_level_package && local_name == "Vector"
                        && qual.as_ref().map(|q| q.is_public_ns()).unwrap_or(true)
                    {
                        r = Some(defer(&self.0.vector_type())?);
                    }
                    for concatp in base.package_concats().iter() {
                        let r1 = self
                            .lookup_in_object(
                                &concatp,
                                open_ns_set,
                                qual.clone(),
                                key,
                                calling,
                            )?;
                        if let Some(r1) = r1 {
                            if r.is_some() {
                                return Err(
                                    PropertyLookupError::AmbiguousReference(local_name),
                                );
                            }
                            r = Some(r1);
                        }
                    }
                    return Ok(r);
                }
                Ok(None)
            }
            pub fn lookup_in_scope_chain(
                &self,
                scope: &Entity,
                qual: Option<Entity>,
                key: &PropertyLookupKey,
            ) -> Result<Option<Entity>, PropertyLookupError> {
                let open_ns_set = scope.concat_open_ns_set_of_scope_chain();
                if match key {
                    PropertyLookupKey::Computed(_) => true,
                    _ => false,
                } {
                    let k = map_defer_error(key.computed_or_local_name(self.0))?;
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_dynamic_scope_reference_value(scope, qual, &k),
                        ),
                    );
                }
                if scope.is::<WithScope>() {
                    let obj = scope.object();
                    let obj_static_type = defer(&obj.static_type(self.0))?;
                    if [self.0.any_type(), self.0.xml_type(), self.0.xml_list_type()]
                        .contains(&obj_static_type.escape_of_non_nullable())
                    {
                        let k = map_defer_error(key.computed_or_local_name(self.0))?;
                        return Ok(
                            Some(
                                self
                                    .0
                                    .factory()
                                    .create_dynamic_scope_reference_value(scope, qual, &k),
                            ),
                        );
                    }
                    let r = self
                        .lookup_in_object(
                            &obj,
                            &open_ns_set,
                            qual.clone(),
                            key,
                            calling,
                        )?;
                    if let Some(r) = r {
                        return Ok(Some(r));
                    }
                }
                if scope.is::<FilterScope>() {
                    let k = map_defer_error(key.computed_or_local_name(self.0))?;
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_dynamic_scope_reference_value(scope, qual, &k),
                        ),
                    );
                }
                let local_name = key.local_name();
                let has_known_ns = qual
                    .as_ref()
                    .map(|q| q.is_namespace_or_ns_constant())
                    .unwrap_or(true);
                if let Some(qual) = qual.as_ref() {
                    if qual.is::<PackageWildcardImport>() {
                        let Some(local_name) = local_name else {
                            return Ok(None);
                        };
                        return self
                            .lookup_in_object(
                                &qual.package(),
                                &open_ns_set,
                                None,
                                &PropertyLookupKey::LocalName(local_name.clone()),
                                calling,
                            );
                    }
                    if qual.is::<PackageRecursiveImport>() {
                        let Some(local_name) = local_name else {
                            return Ok(None);
                        };
                        return self
                            .lookup_in_package_recursive(
                                &qual.package(),
                                &open_ns_set,
                                None,
                                &PropertyLookupKey::LocalName(local_name.clone()),
                            );
                    }
                }
                let mut r: Option<Entity> = None;
                if has_known_ns && local_name.is_some() {
                    r = self
                        .get_qname_in_ns_set_or_any_public_ns(
                            &scope.properties(self.0),
                            &open_ns_set,
                            qual.clone(),
                            local_name.as_ref().unwrap(),
                        )?;
                }
                if let Some(r1) = r.as_ref() {
                    Unused(self.0).mark_used(&r1);
                    let r1 = r1.resolve_alias();
                    defer(&r1.property_static_type(self.0))?;
                    r = Some(map_defer_error(r1.wrap_property_reference(self.0))?);
                }
                if scope.is::<Activation>() && scope.this().is_some() && r.is_none() {
                    let r1 = self
                        .lookup_in_object(
                            &scope.this().unwrap(),
                            &open_ns_set,
                            qual.clone(),
                            key,
                            calling,
                        )?;
                    if let Some(r1) = r1 {
                        if !(r1.is::<DynamicReferenceValue>()
                            || r1.is::<XmlReferenceValue>())
                        {
                            r = Some(r1);
                        }
                    }
                }
                if (scope.is::<ClassScope>() || scope.is::<EnumScope>())
                    && local_name.is_some()
                {
                    let r1 = self
                        .lookup_in_object(
                            &scope.class(),
                            &open_ns_set,
                            qual.clone(),
                            key,
                            calling,
                        )?;
                    if r1.is_some() {
                        if r.is_some() {
                            return Err(
                                PropertyLookupError::AmbiguousReference(
                                    local_name.as_ref().unwrap().clone(),
                                ),
                            );
                        }
                        r = r1;
                    }
                }
                let mut amb: Option<Entity>;
                if scope.is::<PackageScope>() && has_known_ns && local_name.is_some() {
                    amb = self
                        .lookup_in_object(
                            &scope.package(),
                            &open_ns_set,
                            qual.clone(),
                            key,
                            calling,
                        )?;
                    if amb.is_some() {
                        if r.is_some() {
                            return Err(
                                PropertyLookupError::AmbiguousReference(
                                    local_name.as_ref().unwrap().clone(),
                                ),
                            );
                        }
                        r = amb;
                    }
                }
                if let Some(local_name) = local_name {
                    if has_known_ns {
                        for import in scope.import_list().iter() {
                            if import.is::<PackageWildcardImport>() {
                                amb = self
                                    .lookup_in_object(
                                        &import.package(),
                                        &open_ns_set,
                                        qual.clone(),
                                        key,
                                        calling,
                                    )?;
                                if let Some(amb) = amb {
                                    Unused(self.0).mark_used(&import);
                                    if r.is_some()
                                        && !r.as_ref().unwrap().fixture_reference_value_equals(&amb)
                                    {
                                        return Err(
                                            PropertyLookupError::AmbiguousReference(local_name),
                                        );
                                    }
                                    r = Some(amb);
                                }
                            } else if import.is::<PackageRecursiveImport>() {
                                amb = self
                                    .lookup_in_package_recursive(
                                        &import.package(),
                                        &open_ns_set,
                                        qual.clone(),
                                        key,
                                    )?;
                                if let Some(amb) = amb {
                                    Unused(self.0).mark_used(&import);
                                    if r.is_some()
                                        && !r.as_ref().unwrap().fixture_reference_value_equals(&amb)
                                    {
                                        return Err(
                                            PropertyLookupError::AmbiguousReference(local_name),
                                        );
                                    }
                                    r = Some(amb);
                                }
                            } else {
                                if !import.is::<PackagePropertyImport>() {
                                    ::core::panicking::panic(
                                        "assertion failed: import.is::<PackagePropertyImport>()",
                                    )
                                }
                                let prop = map_defer_error(import.property().defer())?;
                                if prop.is::<InvalidationEntity>() {
                                    continue;
                                }
                                if prop
                                    .name()
                                    .matches_in_ns_set_or_any_public_ns(
                                        &open_ns_set,
                                        &local_name,
                                    )
                                {
                                    Unused(self.0).mark_used(&import);
                                    if r.is_some()
                                        && !r
                                            .as_ref()
                                            .unwrap()
                                            .fixture_reference_value_equals(&prop)
                                    {
                                        return Err(
                                            PropertyLookupError::AmbiguousReference(local_name),
                                        );
                                    }
                                    let prop = prop.resolve_alias();
                                    defer(&prop.property_static_type(self.0))?;
                                    r = Some(
                                        map_defer_error(prop.wrap_property_reference(self.0))?,
                                    );
                                }
                            }
                        }
                    }
                }
                if r.is_none() {
                    if let Some(parent) = scope.parent() {
                        return self.lookup_in_scope_chain(&parent, qual, key);
                    }
                }
                Ok(r)
            }
            /// Qualifier is assumed to be a compile-time namespace.
            pub fn get_qname_in_ns_set_or_any_public_ns(
                &self,
                mapping: &Names,
                open_ns_set: &SharedArray<Entity>,
                qual: Option<Entity>,
                local_name: &str,
            ) -> Result<Option<Entity>, PropertyLookupError> {
                if let Some(qual) = qual {
                    if qual.is::<PackageWildcardImport>()
                        || qual.is::<PackageRecursiveImport>()
                    {
                        return Ok(None);
                    }
                    let qual = if qual.is::<NamespaceConstant>() {
                        qual.referenced_ns()
                    } else {
                        qual.clone()
                    };
                    if let Some(k) = qual.system_ns_kind() {
                        if k == SystemNamespaceKind::Public {
                            mapping
                                .get_in_system_ns_kind(k, local_name)
                                .map_err(|e| PropertyLookupError::AmbiguousReference(e.0))
                        } else {
                            mapping
                                .get_in_system_ns_kind_in_ns_set(open_ns_set, k, local_name)
                                .map_err(|e| PropertyLookupError::AmbiguousReference(e.0))
                        }
                    } else {
                        Ok(
                            mapping
                                .get(
                                    &self.0.factory().create_qname(&qual, local_name.to_owned()),
                                ),
                        )
                    }
                } else {
                    mapping
                        .get_in_ns_set_or_any_public_ns(open_ns_set, local_name)
                        .map_err(|e| PropertyLookupError::AmbiguousReference(e.0))
                }
            }
            pub fn lookup_in_package_recursive(
                &self,
                package: &Entity,
                open_ns_set: &SharedArray<Entity>,
                qual: Option<Entity>,
                local_name: &PropertyLookupKey,
            ) -> Result<Option<Entity>, PropertyLookupError> {
                let mut r = self
                    .lookup_in_object(
                        &package,
                        &open_ns_set,
                        qual.clone(),
                        local_name,
                        calling,
                    )?;
                for (_, subpackage) in package.subpackages().borrow().iter() {
                    let r1 = self
                        .lookup_in_package_recursive(
                            subpackage,
                            open_ns_set,
                            qual.clone(),
                            local_name,
                        )?;
                    if r1.is_some() {
                        if r.is_some() {
                            return Err(
                                PropertyLookupError::AmbiguousReference(
                                    local_name.local_name().unwrap(),
                                ),
                            );
                        }
                        r = r1;
                    }
                }
                Ok(r)
            }
        }
    }
    pub use property_lookup::*;
    mod database {
        use crate::ns::*;
        pub struct Database {
            pub(crate) arena: EntityArena,
            node_mapping: NodeAssignment<Entity>,
            node_invalidation_mapping: NodeAssignment<()>,
            project_path: Option<String>,
            config_constants: SharedMap<String, String>,
            config_constants_result: SharedMap<String, Entity>,
            env_cache: RefCell<Option<Rc<HashMap<String, String>>>>,
            unused_things: Rc<RefCell<Vec<Entity>>>,
            pub(crate) explicit_namespaces: RefCell<HashMap<String, Entity>>,
            pub(crate) user_namespaces: RefCell<HashMap<String, Entity>>,
            pub(crate) qnames: RefCell<HashMap<Entity, HashMap<String, QName>>>,
            invalidation_entity: Entity,
            unresolved_entity: Entity,
            pub(crate) top_level_package: Entity,
            as3_vec_package: RefCell<Option<Entity>>,
            mxmlextrema_utils_package_name: Vec<String>,
            mxmlextrema_utils_package: RefCell<Option<Entity>>,
            any_type: Entity,
            void_type: Entity,
            object_type: RefCell<Option<Entity>>,
            boolean_type: RefCell<Option<Entity>>,
            number_type: RefCell<Option<Entity>>,
            int_type: RefCell<Option<Entity>>,
            uint_type: RefCell<Option<Entity>>,
            float_type: RefCell<Option<Entity>>,
            string_type: RefCell<Option<Entity>>,
            array_type: RefCell<Option<Entity>>,
            namespace_type: RefCell<Option<Entity>>,
            function_type: RefCell<Option<Entity>>,
            class_type: RefCell<Option<Entity>>,
            xml_type: RefCell<Option<Entity>>,
            xml_list_type: RefCell<Option<Entity>>,
            reg_exp_type: RefCell<Option<Entity>>,
            date_type: RefCell<Option<Entity>>,
            promise_type: RefCell<Option<Entity>>,
            vector_type: RefCell<Option<Entity>>,
            proxy_type: RefCell<Option<Entity>>,
            dictionary_type: RefCell<Option<Entity>>,
            mxmlextrema_proxy_ns_prefix: String,
            mxmlextrema_proxy_ns_uri: String,
            mxmlextrema_proxy_ns: RefCell<Option<Entity>>,
            as3_ns: RefCell<Option<Entity>>,
            empty_empty_qname: RefCell<Option<QName>>,
            const_eval_scope: RefCell<Option<Entity>>,
            meta_prop: Entity,
            meta_env_prop: Entity,
            primitive_types: RefCell<Option<Rc<Vec<Entity>>>>,
            non_null_primitive_types: RefCell<Option<Rc<Vec<Entity>>>>,
            numeric_types: RefCell<Option<Rc<Vec<Entity>>>>,
            floating_point_types: RefCell<Option<Rc<Vec<Entity>>>>,
            integer_types: RefCell<Option<Rc<Vec<Entity>>>>,
            pub(crate) types_after_sub: RefCell<HashMap<Entity, Vec<Entity>>>,
            pub(crate) function_types: RefCell<HashMap<usize, Vec<Entity>>>,
            pub(crate) tuple_types: RefCell<HashMap<usize, Vec<Entity>>>,
            pub(crate) nullable_types: RefCell<HashMap<Entity, Entity>>,
            pub(crate) non_nullable_types: RefCell<HashMap<Entity, Entity>>,
            pub(crate) vasub: RefCell<
                HashMap<Entity, HashMap<SharedArray<Entity>, Vec<Entity>>>,
            >,
            pub(crate) visub: RefCell<
                HashMap<Entity, HashMap<SharedArray<Entity>, Vec<Entity>>>,
            >,
            pub(crate) mssub: RefCell<
                HashMap<Entity, HashMap<SharedArray<Entity>, Vec<Entity>>>,
            >,
        }
        impl Database {
            pub fn new(options: DatabaseOptions) -> Self {
                let arena = EntityArena::new();
                let explicit_namespaces = RefCell::new(HashMap::new());
                let user_namespaces = RefCell::new(HashMap::new());
                let qnames = RefCell::new(HashMap::new());
                let any_type: Entity = AnyType::new(&arena).into();
                let void_type: Entity = VoidType::new(&arena).into();
                let invalidation_entity: Entity = InvalidationEntity::new(&arena).into();
                let unresolved_entity: Entity = UnresolvedEntity::new(&arena).into();
                let top_level_package = Package::new(&arena, "".into());
                let meta_prop: Entity = MetaProperty::new(&arena, &any_type).into();
                let meta_env_prop: Entity = MetaEnvProperty::new(&arena, &any_type)
                    .into();
                let host = Self {
                    arena,
                    node_mapping: NodeAssignment::new(),
                    node_invalidation_mapping: NodeAssignment::new(),
                    project_path: options.project_path.clone(),
                    config_constants: SharedMap::new(),
                    config_constants_result: SharedMap::new(),
                    env_cache: RefCell::new(None),
                    explicit_namespaces,
                    user_namespaces,
                    qnames,
                    top_level_package: top_level_package.clone().into(),
                    as3_vec_package: RefCell::new(None),
                    mxmlextrema_utils_package_name: options
                        .mxmlextrema_utils_package_name,
                    mxmlextrema_utils_package: RefCell::new(None),
                    invalidation_entity,
                    unresolved_entity,
                    unused_things: Rc::new(RefCell::new(::alloc::vec::Vec::new())),
                    meta_prop,
                    meta_env_prop,
                    any_type,
                    void_type,
                    object_type: RefCell::new(None),
                    boolean_type: RefCell::new(None),
                    number_type: RefCell::new(None),
                    int_type: RefCell::new(None),
                    uint_type: RefCell::new(None),
                    float_type: RefCell::new(None),
                    string_type: RefCell::new(None),
                    array_type: RefCell::new(None),
                    namespace_type: RefCell::new(None),
                    function_type: RefCell::new(None),
                    class_type: RefCell::new(None),
                    xml_type: RefCell::new(None),
                    xml_list_type: RefCell::new(None),
                    reg_exp_type: RefCell::new(None),
                    date_type: RefCell::new(None),
                    promise_type: RefCell::new(None),
                    vector_type: RefCell::new(None),
                    proxy_type: RefCell::new(None),
                    dictionary_type: RefCell::new(None),
                    mxmlextrema_proxy_ns_prefix: options.mxmlextrema_proxy_ns_prefix,
                    mxmlextrema_proxy_ns_uri: options.mxmlextrema_proxy_ns_uri,
                    mxmlextrema_proxy_ns: RefCell::new(None),
                    as3_ns: RefCell::new(None),
                    empty_empty_qname: RefCell::new(None),
                    const_eval_scope: RefCell::new(None),
                    primitive_types: RefCell::new(None),
                    non_null_primitive_types: RefCell::new(None),
                    numeric_types: RefCell::new(None),
                    floating_point_types: RefCell::new(None),
                    integer_types: RefCell::new(None),
                    types_after_sub: RefCell::new(HashMap::new()),
                    function_types: RefCell::new(HashMap::new()),
                    tuple_types: RefCell::new(HashMap::new()),
                    nullable_types: RefCell::new(HashMap::new()),
                    non_nullable_types: RefCell::new(HashMap::new()),
                    vasub: RefCell::new(HashMap::new()),
                    visub: RefCell::new(HashMap::new()),
                    mssub: RefCell::new(HashMap::new()),
                };
                top_level_package
                    .set_public_ns(
                        Some(
                            host
                                .factory()
                                .create_public_ns(Some(top_level_package.clone().into())),
                        ),
                    );
                top_level_package
                    .set_internal_ns(
                        Some(
                            host
                                .factory()
                                .create_internal_ns(Some(top_level_package.clone().into())),
                        ),
                    );
                host.mxmlextrema_proxy_ns
                    .replace(
                        Some(
                            host
                                .factory()
                                .create_user_ns(host.mxmlextrema_proxy_ns_uri.clone()),
                        ),
                    );
                host.as3_ns
                    .replace(Some(host.factory().create_user_ns(options.as3_ns_uri)));
                host.empty_empty_qname
                    .replace(
                        Some(
                            host
                                .factory()
                                .create_qname(
                                    &host.factory().create_user_ns("".into()),
                                    "".into(),
                                ),
                        ),
                    );
                let const_eval_scope = host.factory().create_scope();
                const_eval_scope
                    .import_list()
                    .push(
                        host
                            .factory()
                            .create_package_wildcard_import(
                                &host.top_level_package(),
                                None,
                            ),
                    );
                const_eval_scope.open_ns_set().push(host.as3_ns());
                host.const_eval_scope.replace(Some(const_eval_scope));
                host
            }
            #[inline(always)]
            pub fn factory(&self) -> Factory {
                Factory(self)
            }
            /// Mapping from a node to something in the semantic model.
            #[inline(always)]
            pub fn node_mapping(&self) -> &NodeAssignment<Entity> {
                &self.node_mapping
            }
            /// Mapping from a node to an unit indicating invalidation.
            #[inline(always)]
            pub fn node_invalidation_mapping(&self) -> &NodeAssignment<()> {
                &self.node_invalidation_mapping
            }
            pub fn lazy_node_mapping<T>(
                &self,
                node: &Rc<T>,
                init: impl FnOnce() -> Entity,
            ) -> Entity
            where
                NodeAssignment<Entity>: NodeAssignmentMethod<T, Entity>,
            {
                if let Some(m) = self.node_mapping().get(node) {
                    m
                } else {
                    let entity = init();
                    self.node_mapping().set(node, Some(entity.clone()));
                    entity
                }
            }
            /// The mapping of configuration constants used for
            /// conditional compilation.
            #[inline(always)]
            pub fn config_constants(&self) -> SharedMap<String, String> {
                self.config_constants.clone()
            }
            pub fn clear_config_constants(&self) {
                self.config_constants.clone().clear();
                self.config_constants_result.clone().clear();
            }
            /// The mapping of configuration constants to their verification
            /// result.
            #[inline(always)]
            pub fn config_constants_result(&self) -> SharedMap<String, Entity> {
                self.config_constants_result.clone()
            }
            pub fn empty_empty_qname(&self) -> QName {
                self.empty_empty_qname.borrow().as_ref().unwrap().clone()
            }
            /// Default scope used for the evaluation of configuration constants.
            pub fn const_eval_scope(&self) -> Entity {
                self.const_eval_scope.borrow().as_ref().unwrap().clone()
            }
            pub fn top_level_package(&self) -> Entity {
                self.top_level_package.clone()
            }
            pub fn as3_vec_package(&self) -> Entity {
                if let Some(p) = self.as3_vec_package.borrow().as_ref() {
                    return p.clone();
                }
                let p = self.factory().create_package(["__AS3__", "vec"]);
                self.as3_vec_package.replace(Some(p.clone()));
                p
            }
            pub fn mxmlextrema_utils_package(&self) -> Entity {
                if let Some(p) = self.mxmlextrema_utils_package.borrow().as_ref() {
                    return p.clone();
                }
                let p = self
                    .factory()
                    .create_package(self.mxmlextrema_utils_package_name);
                self.mxmlextrema_utils_package.replace(Some(p.clone()));
                p
            }
            pub fn invalidation_entity(&self) -> Entity {
                self.invalidation_entity.clone()
            }
            pub fn unresolved_entity(&self) -> Entity {
                self.unresolved_entity.clone()
            }
            pub fn any_type(&self) -> Entity {
                self.any_type.clone()
            }
            pub fn void_type(&self) -> Entity {
                self.void_type.clone()
            }
            pub fn meta_property(&self) -> Entity {
                self.meta_prop.clone()
            }
            pub fn meta_env_property(&self) -> Entity {
                self.meta_env_prop.clone()
            }
            /// Retrieves a possibly unresolved thing.
            pub fn object_type(&self) -> Entity {
                if let Some(r) = self.object_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "Object".to_owned(),
                            ),
                    )
                {
                    self.object_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves a possibly unresolved thing.
            pub fn boolean_type(&self) -> Entity {
                if let Some(r) = self.boolean_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "Boolean".to_owned(),
                            ),
                    )
                {
                    self.boolean_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves a possibly unresolved thing.
            pub fn number_type(&self) -> Entity {
                if let Some(r) = self.number_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "Number".to_owned(),
                            ),
                    )
                {
                    self.number_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves a possibly unresolved thing.
            pub fn int_type(&self) -> Entity {
                if let Some(r) = self.int_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "int".to_owned(),
                            ),
                    )
                {
                    self.int_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves a possibly unresolved thing.
            pub fn uint_type(&self) -> Entity {
                if let Some(r) = self.uint_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "uint".to_owned(),
                            ),
                    )
                {
                    self.uint_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves a possibly unresolved thing.
            pub fn float_type(&self) -> Entity {
                if let Some(r) = self.float_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "float".to_owned(),
                            ),
                    )
                {
                    self.float_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves a possibly unresolved thing.
            pub fn string_type(&self) -> Entity {
                if let Some(r) = self.string_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "String".to_owned(),
                            ),
                    )
                {
                    self.string_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves a possibly unresolved thing.
            pub fn array_type(&self) -> Entity {
                if let Some(r) = self.array_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "Array".to_owned(),
                            ),
                    )
                {
                    self.array_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves a possibly unresolved thing.
            pub fn namespace_type(&self) -> Entity {
                if let Some(r) = self.namespace_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "Namespace".to_owned(),
                            ),
                    )
                {
                    self.namespace_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves a possibly unresolved thing.
            pub fn function_type(&self) -> Entity {
                if let Some(r) = self.function_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "Function".to_owned(),
                            ),
                    )
                {
                    self.function_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves a possibly unresolved thing.
            pub fn class_type(&self) -> Entity {
                if let Some(r) = self.class_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "Class".to_owned(),
                            ),
                    )
                {
                    self.class_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves a possibly unresolved thing.
            pub fn xml_type(&self) -> Entity {
                if let Some(r) = self.xml_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "XML".to_owned(),
                            ),
                    )
                {
                    self.xml_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves a possibly unresolved thing.
            pub fn xml_list_type(&self) -> Entity {
                if let Some(r) = self.xml_list_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "XMLList".to_owned(),
                            ),
                    )
                {
                    self.xml_list_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves a possibly unresolved thing.
            pub fn reg_exp_type(&self) -> Entity {
                if let Some(r) = self.reg_exp_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "RegExp".to_owned(),
                            ),
                    )
                {
                    self.reg_exp_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves a possibly unresolved thing.
            pub fn date_type(&self) -> Entity {
                if let Some(r) = self.date_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "Date".to_owned(),
                            ),
                    )
                {
                    self.date_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves a possibly unresolved thing.
            pub fn promise_type(&self) -> Entity {
                if let Some(r) = self.promise_type.borrow().as_ref() {
                    return r.clone();
                }
                if let Some(r) = self
                    .top_level_package
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &self.top_level_package.public_ns().unwrap().into(),
                                "Promise".to_owned(),
                            ),
                    )
                {
                    self.promise_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            pub fn array_type_of_any(&self) -> Result<Entity, DeferError> {
                let origin = self.array_type().defer()?;
                Ok(
                    self
                        .factory()
                        .create_type_after_substitution(
                            &origin,
                            &SharedArray::from([self.any_type()]),
                        ),
                )
            }
            pub fn promise_type_of_any(&self) -> Result<Entity, DeferError> {
                let origin = self.promise_type().defer()?;
                Ok(
                    self
                        .factory()
                        .create_type_after_substitution(
                            &origin,
                            &SharedArray::from([self.any_type()]),
                        ),
                )
            }
            pub fn vector_type_of_any(&self) -> Result<Entity, DeferError> {
                let origin = self.vector_type().defer()?;
                Ok(
                    self
                        .factory()
                        .create_type_after_substitution(
                            &origin,
                            &SharedArray::from([self.any_type()]),
                        ),
                )
            }
            /// Retrieves `__AS3__.vec.Vector`, a possibly unresolved thing.
            pub fn vector_type(&self) -> Entity {
                if let Some(r) = self.vector_type.borrow().as_ref() {
                    return r.clone();
                }
                let pckg = self.as3_vec_package();
                if let Some(r) = pckg
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &pckg.public_ns().unwrap().into(),
                                "Vector".to_owned(),
                            ),
                    )
                {
                    self.vector_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves `mxmlextrema.utils.Proxy`, a possibly unresolved thing.
            pub fn proxy_type(&self) -> Entity {
                if let Some(r) = self.proxy_type.borrow().as_ref() {
                    return r.clone();
                }
                let pckg = self.mxmlextrema_utils_package();
                if let Some(r) = pckg
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &pckg.public_ns().unwrap().into(),
                                "Proxy".to_owned(),
                            ),
                    )
                {
                    self.proxy_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// Retrieves `mxmlextrema.utils.Dictionary`, a possibly unresolved thing.
            pub fn dictionary_type(&self) -> Entity {
                if let Some(r) = self.dictionary_type.borrow().as_ref() {
                    return r.clone();
                }
                let pckg = self.mxmlextrema_utils_package();
                if let Some(r) = pckg
                    .properties(self)
                    .get(
                        &self
                            .factory()
                            .create_qname(
                                &pckg.public_ns().unwrap().into(),
                                "Dictionary".to_owned(),
                            ),
                    )
                {
                    self.dictionary_type.replace(Some(r.clone()));
                    r
                } else {
                    self.unresolved_entity()
                }
            }
            /// The `mxmlextrema.utils.mxmlextrema_proxy` namespace.
            pub fn mxmlextrema_proxy_ns(&self) -> Entity {
                self.mxmlextrema_proxy_ns.borrow().as_ref().unwrap().clone()
            }
            /// The `AS3` namespace.
            pub fn as3_ns(&self) -> Entity {
                self.as3_ns.borrow().as_ref().unwrap().clone()
            }
            /// Returns the set (`void`, `String`, `Boolean`, `Number`, `int`, `uint`, `float`).
            pub fn primitive_types(&self) -> Result<Rc<Vec<Entity>>, DeferError> {
                if let Some(r) = self.primitive_types.borrow().as_ref() {
                    return Ok(r.clone());
                }
                let r = Rc::new(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            self.void_type(),
                            self.string_type().defer()?,
                            self.boolean_type().defer()?,
                            self.number_type().defer()?,
                            self.int_type().defer()?,
                            self.uint_type().defer()?,
                            self.float_type().defer()?,
                        ]),
                    ),
                );
                self.primitive_types.replace(Some(r.clone()));
                Ok(r)
            }
            /// Returns the set (`Boolean`, `Number`, `int`, `uint`, `float`).
            pub fn non_null_primitive_types(
                &self,
            ) -> Result<Rc<Vec<Entity>>, DeferError> {
                if let Some(r) = self.non_null_primitive_types.borrow().as_ref() {
                    return Ok(r.clone());
                }
                let r = Rc::new(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            self.boolean_type().defer()?,
                            self.number_type().defer()?,
                            self.int_type().defer()?,
                            self.uint_type().defer()?,
                            self.float_type().defer()?,
                        ]),
                    ),
                );
                self.non_null_primitive_types.replace(Some(r.clone()));
                Ok(r)
            }
            pub fn numeric_types(&self) -> Result<Rc<Vec<Entity>>, DeferError> {
                if let Some(r) = self.numeric_types.borrow().as_ref() {
                    return Ok(r.clone());
                }
                let r = Rc::new(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            self.number_type().defer()?,
                            self.int_type().defer()?,
                            self.uint_type().defer()?,
                            self.float_type().defer()?,
                        ]),
                    ),
                );
                self.numeric_types.replace(Some(r.clone()));
                Ok(r)
            }
            pub fn floating_point_types(&self) -> Result<Rc<Vec<Entity>>, DeferError> {
                if let Some(r) = self.floating_point_types.borrow().as_ref() {
                    return Ok(r.clone());
                }
                let r = Rc::new(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            self.number_type().defer()?,
                            self.float_type().defer()?,
                        ]),
                    ),
                );
                self.floating_point_types.replace(Some(r.clone()));
                Ok(r)
            }
            pub fn integer_types(&self) -> Result<Rc<Vec<Entity>>, DeferError> {
                if let Some(r) = self.integer_types.borrow().as_ref() {
                    return Ok(r.clone());
                }
                let r = Rc::new(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            self.int_type().defer()?,
                            self.uint_type().defer()?,
                        ]),
                    ),
                );
                self.integer_types.replace(Some(r.clone()));
                Ok(r)
            }
            /// Preloads environment variables from the main project's `.env` file
            /// using the DotEnv file format.
            pub fn env(&self) -> Rc<HashMap<String, String>> {
                if let Some(env) = self.env_cache.borrow().as_ref() {
                    return env.clone();
                }
                let mut r = HashMap::<String, String>::new();
                if let Some(project_path) = self.project_path.as_ref() {
                    if let Ok(iterator) = dotenvy::from_path_iter(project_path) {
                        for item in iterator {
                            if let Ok((key, value)) = item {
                                r.insert(key, value);
                            }
                        }
                    }
                }
                let r = Rc::new(r);
                self.env_cache.replace(Some(r.clone()));
                r
            }
            pub(crate) fn unused_things(&self) -> std::cell::Ref<Vec<Entity>> {
                self.unused_things.borrow()
            }
            pub(crate) fn is_unused(&self, entity: &Entity) -> bool {
                self.unused_things.borrow().contains(entity)
            }
            pub(crate) fn add_unused_thing(&self, thing: &Entity) {
                self.unused_things.borrow_mut().push(thing.clone());
            }
            pub(crate) fn remove_unused_thing(&self, thing: &Entity) {
                let mut i = 0usize;
                let mut things = self.unused_things.borrow_mut();
                for t1 in things.iter() {
                    if thing == t1 {
                        things.remove(i);
                        break;
                    }
                    i += 1;
                }
            }
        }
        pub struct DatabaseOptions {
            /// The directory path of the main project being compiled,
            /// used for the `import.meta.env.EXAMPLE` accessors.
            pub project_path: Option<String>,
            /// The "AS3" namespace URI. Default: `"http://adobe.com/AS3/2006/builtin"`.
            pub as3_ns_uri: String,
            /// The "flash_proxy" compliant namespace's prefix. Default: `"flash_proxy"`
            pub mxmlextrema_proxy_ns_prefix: String,
            /// The "flash_proxy" compliant namespace's URI. Default: `"http://www.adobe.com/2006/actionscript/flash/proxy"`
            pub mxmlextrema_proxy_ns_uri: String,
            /// The "flash.utils" semi compliant package name. Default: `["flash", "utils"]`
            pub mxmlextrema_utils_package_name: Vec<String>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DatabaseOptions {
            #[inline]
            fn clone(&self) -> DatabaseOptions {
                DatabaseOptions {
                    project_path: ::core::clone::Clone::clone(&self.project_path),
                    as3_ns_uri: ::core::clone::Clone::clone(&self.as3_ns_uri),
                    mxmlextrema_proxy_ns_prefix: ::core::clone::Clone::clone(
                        &self.mxmlextrema_proxy_ns_prefix,
                    ),
                    mxmlextrema_proxy_ns_uri: ::core::clone::Clone::clone(
                        &self.mxmlextrema_proxy_ns_uri,
                    ),
                    mxmlextrema_utils_package_name: ::core::clone::Clone::clone(
                        &self.mxmlextrema_utils_package_name,
                    ),
                }
            }
        }
        impl Default for DatabaseOptions {
            fn default() -> Self {
                Self {
                    project_path: None,
                    as3_ns_uri: "http://adobe.com/AS3/2006/builtin".into(),
                    mxmlextrema_proxy_ns_prefix: "flash_proxy".into(),
                    mxmlextrema_proxy_ns_uri: "http://www.adobe.com/2006/actionscript/flash/proxy"
                        .into(),
                    mxmlextrema_utils_package_name: <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new(["flash".into(), "utils".into()]),
                    ),
                }
            }
        }
        macro global_lookup {
            ($field : ident, $as3name : expr) => { #[doc =
            " Retrieves a possibly unresolved thing."] pub fn $field (& self) -> Entity {
            if let Some(r) = self.$field .borrow().as_ref() { return r.clone(); } if let
            Some(r) = self.top_level_package.properties(self).get(& self.factory()
            .create_qname(& self.top_level_package.public_ns().unwrap().into(), $as3name
            .to_owned())) { self.$field .replace(Some(r.clone())); r } else { self
            .unresolved_entity() } } },
        }
    }
    pub use database::*;
    #[allow(unused_variables)]
    mod entity {
        use crate::ns::*;
        use bitflags::bitflags;
        use hydroperfox_smodel::smodel;
        pub type EntityArena = ::hydroperfox_smodel::Arena<__data__::__data_Entity>;
        /// Semantic data type representing one of several ActionScript 3 elements.
        pub struct Entity(::std::rc::Weak<__data__::__data_Entity>);
        #[automatically_derived]
        impl ::core::clone::Clone for Entity {
            #[inline]
            fn clone(&self) -> Entity {
                Entity(::core::clone::Clone::clone(&self.0))
            }
        }
        impl PartialEq for Entity {
            fn eq(&self, other: &Self) -> bool {
                self.0.ptr_eq(&other.0)
            }
        }
        impl ::std::hash::Hash for Entity {
            fn hash<H: ::std::hash::Hasher>(&self, state: &mut H) {
                self.0.as_ptr().hash(state)
            }
        }
        impl Eq for Entity {}
        impl ::std::fmt::Debug for Entity {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("Entity()"))
            }
        }
        impl TryFrom<Entity> for UnresolvedEntity {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_UnresolvedEntity(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    Ok(UnresolvedEntity(Entity(v.0.clone())))
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for InvalidationEntity {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_InvalidationEntity(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    Ok(InvalidationEntity(Entity(v.0.clone())))
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for Namespace {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Namespace(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    Ok(Namespace(Entity(v.0.clone())))
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for SystemNamespace {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Namespace(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Namespace::__data_SystemNamespace(_o) = &_o
                        .__variant
                    {
                        Ok(SystemNamespace(Namespace(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for UserNamespace {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Namespace(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Namespace::__data_UserNamespace(_o) = &_o
                        .__variant
                    {
                        Ok(UserNamespace(Namespace(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for ExplicitNamespace {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Namespace(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Namespace::__data_ExplicitNamespace(_o) = &_o
                        .__variant
                    {
                        Ok(ExplicitNamespace(Namespace(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for Package {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Package(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    Ok(Package(Entity(v.0.clone())))
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for Alias {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Alias(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    Ok(Alias(Entity(v.0.clone())))
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for Type {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    Ok(Type(Entity(v.0.clone())))
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for AnyType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_AnyType(_o) = &_o.__variant {
                        Ok(AnyType(Type(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for VoidType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_VoidType(_o) = &_o.__variant
                    {
                        Ok(VoidType(Type(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for ClassType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_ClassType(_o) = &_o.__variant
                    {
                        Ok(ClassType(Type(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for EnumType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_EnumType(_o) = &_o.__variant
                    {
                        Ok(EnumType(Type(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for InterfaceType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_InterfaceType(_o) = &_o
                        .__variant
                    {
                        Ok(InterfaceType(Type(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for TypeAfterSubstitution {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_TypeAfterSubstitution(_o) = &_o
                        .__variant
                    {
                        Ok(TypeAfterSubstitution(Type(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for TupleType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_TupleType(_o) = &_o.__variant
                    {
                        Ok(TupleType(Type(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for FunctionType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_FunctionType(_o) = &_o
                        .__variant
                    {
                        Ok(FunctionType(Type(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for NullableType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_NullableType(_o) = &_o
                        .__variant
                    {
                        Ok(NullableType(Type(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for NonNullableType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_NonNullableType(_o) = &_o
                        .__variant
                    {
                        Ok(NonNullableType(Type(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for TypeParameterType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_TypeParameterType(_o) = &_o
                        .__variant
                    {
                        Ok(TypeParameterType(Type(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for VariableSlot {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_VariableSlot(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    Ok(VariableSlot(Entity(v.0.clone())))
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for OriginalVariableSlot {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_VariableSlot(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        _o,
                    ) = &_o.__variant
                    {
                        Ok(OriginalVariableSlot(VariableSlot(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for VariableSlotAfterSubstitution {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_VariableSlot(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_VariableSlot::__data_VariableSlotAfterSubstitution(
                        _o,
                    ) = &_o.__variant
                    {
                        Ok(
                            VariableSlotAfterSubstitution(
                                VariableSlot(Entity(v.0.clone())),
                            ),
                        )
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for VirtualSlot {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_VirtualSlot(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    Ok(VirtualSlot(Entity(v.0.clone())))
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for OriginalVirtualSlot {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_VirtualSlot(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        _o,
                    ) = &_o.__variant
                    {
                        Ok(OriginalVirtualSlot(VirtualSlot(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for VirtualSlotAfterSubstitution {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_VirtualSlot(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_VirtualSlot::__data_VirtualSlotAfterSubstitution(
                        _o,
                    ) = &_o.__variant
                    {
                        Ok(
                            VirtualSlotAfterSubstitution(
                                VirtualSlot(Entity(v.0.clone())),
                            ),
                        )
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for MethodSlot {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_MethodSlot(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    Ok(MethodSlot(Entity(v.0.clone())))
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for OriginalMethodSlot {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_MethodSlot(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        _o,
                    ) = &_o.__variant
                    {
                        Ok(OriginalMethodSlot(MethodSlot(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for MethodSlotAfterSubstitution {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_MethodSlot(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        _o,
                    ) = &_o.__variant
                    {
                        Ok(MethodSlotAfterSubstitution(MethodSlot(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for Scope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    Ok(Scope(Entity(v.0.clone())))
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for WithScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_WithScope(_o) = &_o
                        .__variant
                    {
                        Ok(WithScope(Scope(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for FilterScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FilterScope(_o) = &_o
                        .__variant
                    {
                        Ok(FilterScope(Scope(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for Activation {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_Activation(_o) = &_o
                        .__variant
                    {
                        Ok(Activation(Scope(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for FixtureScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FixtureScope(_o) = &_o
                        .__variant
                    {
                        Ok(FixtureScope(Scope(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for ClassScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FixtureScope(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_FixtureScope::__data_ClassScope(_o) = &_o
                            .__variant
                        {
                            Ok(ClassScope(FixtureScope(Scope(Entity(v.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for EnumScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FixtureScope(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_FixtureScope::__data_EnumScope(_o) = &_o
                            .__variant
                        {
                            Ok(EnumScope(FixtureScope(Scope(Entity(v.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for InterfaceScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FixtureScope(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_FixtureScope::__data_InterfaceScope(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(InterfaceScope(FixtureScope(Scope(Entity(v.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for PackageScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FixtureScope(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_FixtureScope::__data_PackageScope(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(PackageScope(FixtureScope(Scope(Entity(v.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for Value {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    Ok(Value(Entity(v.0.clone())))
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for PackagePropertyImport {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_PackagePropertyImport(_o) = &_o
                        .__variant
                    {
                        Ok(PackagePropertyImport(Value(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for PackageWildcardImport {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_PackageWildcardImport(_o) = &_o
                        .__variant
                    {
                        Ok(PackageWildcardImport(Value(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for PackageRecursiveImport {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_PackageRecursiveImport(
                        _o,
                    ) = &_o.__variant
                    {
                        Ok(PackageRecursiveImport(Value(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for Constant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        Ok(Constant(Value(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for UndefinedConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_UndefinedConstant(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(UndefinedConstant(Constant(Value(Entity(v.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for NullConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_NullConstant(_o) = &_o
                            .__variant
                        {
                            Ok(NullConstant(Constant(Value(Entity(v.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for NamespaceConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_NamespaceConstant(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(NamespaceConstant(Constant(Value(Entity(v.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for TypeConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_TypeConstant(_o) = &_o
                            .__variant
                        {
                            Ok(TypeConstant(Constant(Value(Entity(v.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for NumberConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_NumberConstant(_o) = &_o
                            .__variant
                        {
                            Ok(NumberConstant(Constant(Value(Entity(v.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for StringConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_StringConstant(_o) = &_o
                            .__variant
                        {
                            Ok(StringConstant(Constant(Value(Entity(v.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for BooleanConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_BooleanConstant(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(BooleanConstant(Constant(Value(Entity(v.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for ThisObject {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ThisObject(_o) = &_o
                        .__variant
                    {
                        Ok(ThisObject(Value(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for MetaProperty {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_MetaProperty(_o) = &_o
                        .__variant
                    {
                        Ok(MetaProperty(Value(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for MetaEnvProperty {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_MetaEnvProperty(_o) = &_o
                        .__variant
                    {
                        Ok(MetaEnvProperty(Value(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for ReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        Ok(ReferenceValue(Value(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for XmlReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_XmlReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                XmlReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for DynamicReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_DynamicReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                DynamicReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for FixtureReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                FixtureReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for StaticReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_StaticReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    StaticReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for InstanceReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_InstanceReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    InstanceReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for ScopeReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_ScopeReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    ScopeReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for PackageReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_PackageReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    PackageReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for StaticDynamicReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_StaticDynamicReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                StaticDynamicReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for TupleReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_TupleReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                TupleReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for DynamicScopeReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_DynamicScopeReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                DynamicScopeReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for ArrayElementReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_ArrayElementReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                ArrayElementReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for VectorElementReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_VectorElementReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                VectorElementReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for ConversionValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ConversionValue(_o) = &_o
                        .__variant
                    {
                        Ok(ConversionValue(Value(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for NonNullValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_NonNullValue(_o) = &_o
                        .__variant
                    {
                        Ok(NonNullValue(Value(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for LambdaObject {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_LambdaObject(_o) = &_o
                        .__variant
                    {
                        Ok(LambdaObject(Value(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for FilterValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_FilterValue(_o) = &_o
                        .__variant
                    {
                        Ok(FilterValue(Value(Entity(v.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for FieldResolution {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_FieldResolution(_o) = &v
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    Ok(FieldResolution(Entity(v.0.clone())))
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for DeclarativeFieldDestructuringResolution {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_DeclarativeFieldDestructuringResolution(
                    _o,
                ) = &v.0.upgrade().unwrap().__variant
                {
                    Ok(DeclarativeFieldDestructuringResolution(Entity(v.0.clone())))
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Entity> for AssignmentFieldDestructuringResolution {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Entity) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_AssignmentFieldDestructuringResolution(
                    _o,
                ) = &v.0.upgrade().unwrap().__variant
                {
                    Ok(AssignmentFieldDestructuringResolution(Entity(v.0.clone())))
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        pub struct UnresolvedEntity(Entity);
        #[automatically_derived]
        impl ::core::clone::Clone for UnresolvedEntity {
            #[inline]
            fn clone(&self) -> UnresolvedEntity {
                UnresolvedEntity(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for UnresolvedEntity {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for UnresolvedEntity {
            #[inline]
            fn eq(&self, other: &UnresolvedEntity) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for UnresolvedEntity {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for UnresolvedEntity {
            type Target = Entity;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for UnresolvedEntity {}
        impl ::std::fmt::Debug for UnresolvedEntity {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("UnresolvedEntity()"))
            }
        }
        impl From<UnresolvedEntity> for Entity {
            fn from(v: UnresolvedEntity) -> Self {
                Entity(v.0.0.clone())
            }
        }
        /// Entity used to indicate that an entity is invalidated.
        pub struct InvalidationEntity(Entity);
        #[automatically_derived]
        impl ::core::clone::Clone for InvalidationEntity {
            #[inline]
            fn clone(&self) -> InvalidationEntity {
                InvalidationEntity(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for InvalidationEntity {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for InvalidationEntity {
            #[inline]
            fn eq(&self, other: &InvalidationEntity) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for InvalidationEntity {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for InvalidationEntity {
            type Target = Entity;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for InvalidationEntity {}
        impl ::std::fmt::Debug for InvalidationEntity {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("InvalidationEntity()"))
            }
        }
        impl From<InvalidationEntity> for Entity {
            fn from(v: InvalidationEntity) -> Self {
                Entity(v.0.0.clone())
            }
        }
        pub struct Namespace(Entity);
        #[automatically_derived]
        impl ::core::clone::Clone for Namespace {
            #[inline]
            fn clone(&self) -> Namespace {
                Namespace(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Namespace {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Namespace {
            #[inline]
            fn eq(&self, other: &Namespace) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Namespace {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for Namespace {
            type Target = Entity;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for Namespace {}
        impl ::std::fmt::Debug for Namespace {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("Namespace()"))
            }
        }
        impl From<Namespace> for Entity {
            fn from(v: Namespace) -> Self {
                Entity(v.0.0.clone())
            }
        }
        impl TryFrom<Namespace> for SystemNamespace {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Namespace) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Namespace(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Namespace::__data_SystemNamespace(_o) = &_o
                        .__variant
                    {
                        Ok(SystemNamespace(Namespace(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Namespace> for UserNamespace {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Namespace) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Namespace(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Namespace::__data_UserNamespace(_o) = &_o
                        .__variant
                    {
                        Ok(UserNamespace(Namespace(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Namespace> for ExplicitNamespace {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Namespace) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Namespace(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Namespace::__data_ExplicitNamespace(_o) = &_o
                        .__variant
                    {
                        Ok(ExplicitNamespace(Namespace(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        pub struct SystemNamespace(Namespace);
        #[automatically_derived]
        impl ::core::clone::Clone for SystemNamespace {
            #[inline]
            fn clone(&self) -> SystemNamespace {
                SystemNamespace(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SystemNamespace {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SystemNamespace {
            #[inline]
            fn eq(&self, other: &SystemNamespace) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for SystemNamespace {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for SystemNamespace {
            type Target = Namespace;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for SystemNamespace {}
        impl ::std::fmt::Debug for SystemNamespace {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("SystemNamespace()"))
            }
        }
        impl From<SystemNamespace> for Namespace {
            fn from(v: SystemNamespace) -> Self {
                Namespace(v.0.0.clone())
            }
        }
        impl From<SystemNamespace> for Entity {
            fn from(v: SystemNamespace) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// In the AVM2, this is equivalent to a `CONSTANT_Namespace` namespace.
        pub struct UserNamespace(Namespace);
        #[automatically_derived]
        impl ::core::clone::Clone for UserNamespace {
            #[inline]
            fn clone(&self) -> UserNamespace {
                UserNamespace(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for UserNamespace {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for UserNamespace {
            #[inline]
            fn eq(&self, other: &UserNamespace) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for UserNamespace {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for UserNamespace {
            type Target = Namespace;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for UserNamespace {}
        impl ::std::fmt::Debug for UserNamespace {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("UserNamespace()"))
            }
        }
        impl From<UserNamespace> for Namespace {
            fn from(v: UserNamespace) -> Self {
                Namespace(v.0.0.clone())
            }
        }
        impl From<UserNamespace> for Entity {
            fn from(v: UserNamespace) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// In the AVM2, this is equivalent to a `CONSTANT_ExplicitNamespace` namespace.
        pub struct ExplicitNamespace(Namespace);
        #[automatically_derived]
        impl ::core::clone::Clone for ExplicitNamespace {
            #[inline]
            fn clone(&self) -> ExplicitNamespace {
                ExplicitNamespace(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ExplicitNamespace {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ExplicitNamespace {
            #[inline]
            fn eq(&self, other: &ExplicitNamespace) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ExplicitNamespace {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for ExplicitNamespace {
            type Target = Namespace;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for ExplicitNamespace {}
        impl ::std::fmt::Debug for ExplicitNamespace {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("ExplicitNamespace()"))
            }
        }
        impl From<ExplicitNamespace> for Namespace {
            fn from(v: ExplicitNamespace) -> Self {
                Namespace(v.0.0.clone())
            }
        }
        impl From<ExplicitNamespace> for Entity {
            fn from(v: ExplicitNamespace) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// A package consists of a local name, two namespaces, `public` and `internal`,
        /// and a mapping of subpackages.
        pub struct Package(Entity);
        #[automatically_derived]
        impl ::core::clone::Clone for Package {
            #[inline]
            fn clone(&self) -> Package {
                Package(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Package {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Package {
            #[inline]
            fn eq(&self, other: &Package) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Package {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for Package {
            type Target = Entity;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for Package {}
        impl ::std::fmt::Debug for Package {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("Package()"))
            }
        }
        impl From<Package> for Entity {
            fn from(v: Package) -> Self {
                Entity(v.0.0.clone())
            }
        }
        pub struct Alias(Entity);
        #[automatically_derived]
        impl ::core::clone::Clone for Alias {
            #[inline]
            fn clone(&self) -> Alias {
                Alias(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Alias {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Alias {
            #[inline]
            fn eq(&self, other: &Alias) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Alias {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for Alias {
            type Target = Entity;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for Alias {}
        impl ::std::fmt::Debug for Alias {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("Alias()"))
            }
        }
        impl From<Alias> for Entity {
            fn from(v: Alias) -> Self {
                Entity(v.0.0.clone())
            }
        }
        pub struct Type(Entity);
        #[automatically_derived]
        impl ::core::clone::Clone for Type {
            #[inline]
            fn clone(&self) -> Type {
                Type(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Type {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Type {
            #[inline]
            fn eq(&self, other: &Type) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Type {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for Type {
            type Target = Entity;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for Type {}
        impl ::std::fmt::Debug for Type {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("Type()"))
            }
        }
        impl From<Type> for Entity {
            fn from(v: Type) -> Self {
                Entity(v.0.0.clone())
            }
        }
        impl TryFrom<Type> for AnyType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Type) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_AnyType(_o) = &_o.__variant {
                        Ok(AnyType(Type(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Type> for VoidType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Type) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_VoidType(_o) = &_o.__variant
                    {
                        Ok(VoidType(Type(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Type> for ClassType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Type) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_ClassType(_o) = &_o.__variant
                    {
                        Ok(ClassType(Type(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Type> for EnumType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Type) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_EnumType(_o) = &_o.__variant
                    {
                        Ok(EnumType(Type(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Type> for InterfaceType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Type) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_InterfaceType(_o) = &_o
                        .__variant
                    {
                        Ok(InterfaceType(Type(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Type> for TypeAfterSubstitution {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Type) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_TypeAfterSubstitution(_o) = &_o
                        .__variant
                    {
                        Ok(TypeAfterSubstitution(Type(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Type> for TupleType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Type) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_TupleType(_o) = &_o.__variant
                    {
                        Ok(TupleType(Type(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Type> for FunctionType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Type) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_FunctionType(_o) = &_o
                        .__variant
                    {
                        Ok(FunctionType(Type(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Type> for NullableType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Type) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_NullableType(_o) = &_o
                        .__variant
                    {
                        Ok(NullableType(Type(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Type> for NonNullableType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Type) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_NonNullableType(_o) = &_o
                        .__variant
                    {
                        Ok(NonNullableType(Type(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Type> for TypeParameterType {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Type) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Type(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Type::__data_TypeParameterType(_o) = &_o
                        .__variant
                    {
                        Ok(TypeParameterType(Type(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        pub struct AnyType(Type);
        #[automatically_derived]
        impl ::core::clone::Clone for AnyType {
            #[inline]
            fn clone(&self) -> AnyType {
                AnyType(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AnyType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AnyType {
            #[inline]
            fn eq(&self, other: &AnyType) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for AnyType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for AnyType {
            type Target = Type;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for AnyType {}
        impl ::std::fmt::Debug for AnyType {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("AnyType()"))
            }
        }
        impl From<AnyType> for Type {
            fn from(v: AnyType) -> Self {
                Type(v.0.0.clone())
            }
        }
        impl From<AnyType> for Entity {
            fn from(v: AnyType) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct VoidType(Type);
        #[automatically_derived]
        impl ::core::clone::Clone for VoidType {
            #[inline]
            fn clone(&self) -> VoidType {
                VoidType(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for VoidType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for VoidType {
            #[inline]
            fn eq(&self, other: &VoidType) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for VoidType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for VoidType {
            type Target = Type;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for VoidType {}
        impl ::std::fmt::Debug for VoidType {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("VoidType()"))
            }
        }
        impl From<VoidType> for Type {
            fn from(v: VoidType) -> Self {
                Type(v.0.0.clone())
            }
        }
        impl From<VoidType> for Entity {
            fn from(v: VoidType) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct ClassType(Type);
        #[automatically_derived]
        impl ::core::clone::Clone for ClassType {
            #[inline]
            fn clone(&self) -> ClassType {
                ClassType(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ClassType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ClassType {
            #[inline]
            fn eq(&self, other: &ClassType) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ClassType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for ClassType {
            type Target = Type;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for ClassType {}
        impl ::std::fmt::Debug for ClassType {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("ClassType()"))
            }
        }
        impl From<ClassType> for Type {
            fn from(v: ClassType) -> Self {
                Type(v.0.0.clone())
            }
        }
        impl From<ClassType> for Entity {
            fn from(v: ClassType) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct EnumType(Type);
        #[automatically_derived]
        impl ::core::clone::Clone for EnumType {
            #[inline]
            fn clone(&self) -> EnumType {
                EnumType(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for EnumType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for EnumType {
            #[inline]
            fn eq(&self, other: &EnumType) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for EnumType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for EnumType {
            type Target = Type;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for EnumType {}
        impl ::std::fmt::Debug for EnumType {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("EnumType()"))
            }
        }
        impl From<EnumType> for Type {
            fn from(v: EnumType) -> Self {
                Type(v.0.0.clone())
            }
        }
        impl From<EnumType> for Entity {
            fn from(v: EnumType) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct InterfaceType(Type);
        #[automatically_derived]
        impl ::core::clone::Clone for InterfaceType {
            #[inline]
            fn clone(&self) -> InterfaceType {
                InterfaceType(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for InterfaceType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for InterfaceType {
            #[inline]
            fn eq(&self, other: &InterfaceType) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for InterfaceType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for InterfaceType {
            type Target = Type;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for InterfaceType {}
        impl ::std::fmt::Debug for InterfaceType {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("InterfaceType()"))
            }
        }
        impl From<InterfaceType> for Type {
            fn from(v: InterfaceType) -> Self {
                Type(v.0.0.clone())
            }
        }
        impl From<InterfaceType> for Entity {
            fn from(v: InterfaceType) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// Type after substitution, whose origin is either
        /// a class or an interface. Other types, after substitution,
        /// such as structural types, are represented by their
        /// same type with substitution in compound parts.
        pub struct TypeAfterSubstitution(Type);
        #[automatically_derived]
        impl ::core::clone::Clone for TypeAfterSubstitution {
            #[inline]
            fn clone(&self) -> TypeAfterSubstitution {
                TypeAfterSubstitution(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TypeAfterSubstitution {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TypeAfterSubstitution {
            #[inline]
            fn eq(&self, other: &TypeAfterSubstitution) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TypeAfterSubstitution {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for TypeAfterSubstitution {
            type Target = Type;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for TypeAfterSubstitution {}
        impl ::std::fmt::Debug for TypeAfterSubstitution {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("TypeAfterSubstitution()"))
            }
        }
        impl From<TypeAfterSubstitution> for Type {
            fn from(v: TypeAfterSubstitution) -> Self {
                Type(v.0.0.clone())
            }
        }
        impl From<TypeAfterSubstitution> for Entity {
            fn from(v: TypeAfterSubstitution) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// Tuple type. The tuple type is equivalent to
        /// `Array` with type safety for its element types.
        pub struct TupleType(Type);
        #[automatically_derived]
        impl ::core::clone::Clone for TupleType {
            #[inline]
            fn clone(&self) -> TupleType {
                TupleType(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TupleType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TupleType {
            #[inline]
            fn eq(&self, other: &TupleType) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TupleType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for TupleType {
            type Target = Type;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for TupleType {}
        impl ::std::fmt::Debug for TupleType {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("TupleType()"))
            }
        }
        impl From<TupleType> for Type {
            fn from(v: TupleType) -> Self {
                Type(v.0.0.clone())
            }
        }
        impl From<TupleType> for Entity {
            fn from(v: TupleType) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// Structural function type. This type is equivalent to `Function`
        /// with type safety.
        pub struct FunctionType(Type);
        #[automatically_derived]
        impl ::core::clone::Clone for FunctionType {
            #[inline]
            fn clone(&self) -> FunctionType {
                FunctionType(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for FunctionType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for FunctionType {
            #[inline]
            fn eq(&self, other: &FunctionType) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for FunctionType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for FunctionType {
            type Target = Type;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for FunctionType {}
        impl ::std::fmt::Debug for FunctionType {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("FunctionType()"))
            }
        }
        impl From<FunctionType> for Type {
            fn from(v: FunctionType) -> Self {
                Type(v.0.0.clone())
            }
        }
        impl From<FunctionType> for Entity {
            fn from(v: FunctionType) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// The nullable type `T?`. It is equivalent to either
        /// `T` or `*` (for all primitive types but String).
        pub struct NullableType(Type);
        #[automatically_derived]
        impl ::core::clone::Clone for NullableType {
            #[inline]
            fn clone(&self) -> NullableType {
                NullableType(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NullableType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NullableType {
            #[inline]
            fn eq(&self, other: &NullableType) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for NullableType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for NullableType {
            type Target = Type;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for NullableType {}
        impl ::std::fmt::Debug for NullableType {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("NullableType()"))
            }
        }
        impl From<NullableType> for Type {
            fn from(v: NullableType) -> Self {
                Type(v.0.0.clone())
            }
        }
        impl From<NullableType> for Entity {
            fn from(v: NullableType) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct NonNullableType(Type);
        #[automatically_derived]
        impl ::core::clone::Clone for NonNullableType {
            #[inline]
            fn clone(&self) -> NonNullableType {
                NonNullableType(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NonNullableType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NonNullableType {
            #[inline]
            fn eq(&self, other: &NonNullableType) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for NonNullableType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for NonNullableType {
            type Target = Type;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for NonNullableType {}
        impl ::std::fmt::Debug for NonNullableType {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("NonNullableType()"))
            }
        }
        impl From<NonNullableType> for Type {
            fn from(v: NonNullableType) -> Self {
                Type(v.0.0.clone())
            }
        }
        impl From<NonNullableType> for Entity {
            fn from(v: NonNullableType) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct TypeParameterType(Type);
        #[automatically_derived]
        impl ::core::clone::Clone for TypeParameterType {
            #[inline]
            fn clone(&self) -> TypeParameterType {
                TypeParameterType(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TypeParameterType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TypeParameterType {
            #[inline]
            fn eq(&self, other: &TypeParameterType) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TypeParameterType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for TypeParameterType {
            type Target = Type;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for TypeParameterType {}
        impl ::std::fmt::Debug for TypeParameterType {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("TypeParameterType()"))
            }
        }
        impl From<TypeParameterType> for Type {
            fn from(v: TypeParameterType) -> Self {
                Type(v.0.0.clone())
            }
        }
        impl From<TypeParameterType> for Entity {
            fn from(v: TypeParameterType) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// Either an *original* variable slot, or a variable slot after substitution.
        pub struct VariableSlot(Entity);
        #[automatically_derived]
        impl ::core::clone::Clone for VariableSlot {
            #[inline]
            fn clone(&self) -> VariableSlot {
                VariableSlot(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for VariableSlot {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for VariableSlot {
            #[inline]
            fn eq(&self, other: &VariableSlot) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for VariableSlot {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for VariableSlot {
            type Target = Entity;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for VariableSlot {}
        impl ::std::fmt::Debug for VariableSlot {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("VariableSlot()"))
            }
        }
        impl From<VariableSlot> for Entity {
            fn from(v: VariableSlot) -> Self {
                Entity(v.0.0.clone())
            }
        }
        impl TryFrom<VariableSlot> for OriginalVariableSlot {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: VariableSlot) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_VariableSlot(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        _o,
                    ) = &_o.__variant
                    {
                        Ok(OriginalVariableSlot(VariableSlot(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<VariableSlot> for VariableSlotAfterSubstitution {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: VariableSlot) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_VariableSlot(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_VariableSlot::__data_VariableSlotAfterSubstitution(
                        _o,
                    ) = &_o.__variant
                    {
                        Ok(
                            VariableSlotAfterSubstitution(
                                VariableSlot(Entity(v.0.0.clone())),
                            ),
                        )
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        pub struct OriginalVariableSlot(VariableSlot);
        #[automatically_derived]
        impl ::core::clone::Clone for OriginalVariableSlot {
            #[inline]
            fn clone(&self) -> OriginalVariableSlot {
                OriginalVariableSlot(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for OriginalVariableSlot {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for OriginalVariableSlot {
            #[inline]
            fn eq(&self, other: &OriginalVariableSlot) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for OriginalVariableSlot {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for OriginalVariableSlot {
            type Target = VariableSlot;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for OriginalVariableSlot {}
        impl ::std::fmt::Debug for OriginalVariableSlot {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("OriginalVariableSlot()"))
            }
        }
        impl From<OriginalVariableSlot> for VariableSlot {
            fn from(v: OriginalVariableSlot) -> Self {
                VariableSlot(v.0.0.clone())
            }
        }
        impl From<OriginalVariableSlot> for Entity {
            fn from(v: OriginalVariableSlot) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// Variable slot after indirect substitution.
        pub struct VariableSlotAfterSubstitution(VariableSlot);
        #[automatically_derived]
        impl ::core::clone::Clone for VariableSlotAfterSubstitution {
            #[inline]
            fn clone(&self) -> VariableSlotAfterSubstitution {
                VariableSlotAfterSubstitution(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for VariableSlotAfterSubstitution {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for VariableSlotAfterSubstitution {
            #[inline]
            fn eq(&self, other: &VariableSlotAfterSubstitution) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for VariableSlotAfterSubstitution {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for VariableSlotAfterSubstitution {
            type Target = VariableSlot;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for VariableSlotAfterSubstitution {}
        impl ::std::fmt::Debug for VariableSlotAfterSubstitution {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("VariableSlotAfterSubstitution()"))
            }
        }
        impl From<VariableSlotAfterSubstitution> for VariableSlot {
            fn from(v: VariableSlotAfterSubstitution) -> Self {
                VariableSlot(v.0.0.clone())
            }
        }
        impl From<VariableSlotAfterSubstitution> for Entity {
            fn from(v: VariableSlotAfterSubstitution) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// Either an *original* virtual slot, or a virtual slot after substitution.
        pub struct VirtualSlot(Entity);
        #[automatically_derived]
        impl ::core::clone::Clone for VirtualSlot {
            #[inline]
            fn clone(&self) -> VirtualSlot {
                VirtualSlot(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for VirtualSlot {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for VirtualSlot {
            #[inline]
            fn eq(&self, other: &VirtualSlot) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for VirtualSlot {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for VirtualSlot {
            type Target = Entity;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for VirtualSlot {}
        impl ::std::fmt::Debug for VirtualSlot {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("VirtualSlot()"))
            }
        }
        impl From<VirtualSlot> for Entity {
            fn from(v: VirtualSlot) -> Self {
                Entity(v.0.0.clone())
            }
        }
        impl TryFrom<VirtualSlot> for OriginalVirtualSlot {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: VirtualSlot) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_VirtualSlot(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        _o,
                    ) = &_o.__variant
                    {
                        Ok(OriginalVirtualSlot(VirtualSlot(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<VirtualSlot> for VirtualSlotAfterSubstitution {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: VirtualSlot) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_VirtualSlot(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_VirtualSlot::__data_VirtualSlotAfterSubstitution(
                        _o,
                    ) = &_o.__variant
                    {
                        Ok(
                            VirtualSlotAfterSubstitution(
                                VirtualSlot(Entity(v.0.0.clone())),
                            ),
                        )
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        pub struct OriginalVirtualSlot(VirtualSlot);
        #[automatically_derived]
        impl ::core::clone::Clone for OriginalVirtualSlot {
            #[inline]
            fn clone(&self) -> OriginalVirtualSlot {
                OriginalVirtualSlot(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for OriginalVirtualSlot {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for OriginalVirtualSlot {
            #[inline]
            fn eq(&self, other: &OriginalVirtualSlot) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for OriginalVirtualSlot {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for OriginalVirtualSlot {
            type Target = VirtualSlot;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for OriginalVirtualSlot {}
        impl ::std::fmt::Debug for OriginalVirtualSlot {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("OriginalVirtualSlot()"))
            }
        }
        impl From<OriginalVirtualSlot> for VirtualSlot {
            fn from(v: OriginalVirtualSlot) -> Self {
                VirtualSlot(v.0.0.clone())
            }
        }
        impl From<OriginalVirtualSlot> for Entity {
            fn from(v: OriginalVirtualSlot) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct VirtualSlotAfterSubstitution(VirtualSlot);
        #[automatically_derived]
        impl ::core::clone::Clone for VirtualSlotAfterSubstitution {
            #[inline]
            fn clone(&self) -> VirtualSlotAfterSubstitution {
                VirtualSlotAfterSubstitution(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for VirtualSlotAfterSubstitution {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for VirtualSlotAfterSubstitution {
            #[inline]
            fn eq(&self, other: &VirtualSlotAfterSubstitution) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for VirtualSlotAfterSubstitution {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for VirtualSlotAfterSubstitution {
            type Target = VirtualSlot;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for VirtualSlotAfterSubstitution {}
        impl ::std::fmt::Debug for VirtualSlotAfterSubstitution {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("VirtualSlotAfterSubstitution()"))
            }
        }
        impl From<VirtualSlotAfterSubstitution> for VirtualSlot {
            fn from(v: VirtualSlotAfterSubstitution) -> Self {
                VirtualSlot(v.0.0.clone())
            }
        }
        impl From<VirtualSlotAfterSubstitution> for Entity {
            fn from(v: VirtualSlotAfterSubstitution) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// Either an *original* method slot, or a method slot after substitution.
        pub struct MethodSlot(Entity);
        #[automatically_derived]
        impl ::core::clone::Clone for MethodSlot {
            #[inline]
            fn clone(&self) -> MethodSlot {
                MethodSlot(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MethodSlot {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MethodSlot {
            #[inline]
            fn eq(&self, other: &MethodSlot) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for MethodSlot {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for MethodSlot {
            type Target = Entity;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for MethodSlot {}
        impl ::std::fmt::Debug for MethodSlot {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("MethodSlot()"))
            }
        }
        impl From<MethodSlot> for Entity {
            fn from(v: MethodSlot) -> Self {
                Entity(v.0.0.clone())
            }
        }
        impl TryFrom<MethodSlot> for OriginalMethodSlot {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: MethodSlot) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_MethodSlot(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        _o,
                    ) = &_o.__variant
                    {
                        Ok(OriginalMethodSlot(MethodSlot(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<MethodSlot> for MethodSlotAfterSubstitution {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: MethodSlot) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_MethodSlot(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        _o,
                    ) = &_o.__variant
                    {
                        Ok(
                            MethodSlotAfterSubstitution(
                                MethodSlot(Entity(v.0.0.clone())),
                            ),
                        )
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        pub struct OriginalMethodSlot(MethodSlot);
        #[automatically_derived]
        impl ::core::clone::Clone for OriginalMethodSlot {
            #[inline]
            fn clone(&self) -> OriginalMethodSlot {
                OriginalMethodSlot(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for OriginalMethodSlot {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for OriginalMethodSlot {
            #[inline]
            fn eq(&self, other: &OriginalMethodSlot) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for OriginalMethodSlot {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for OriginalMethodSlot {
            type Target = MethodSlot;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for OriginalMethodSlot {}
        impl ::std::fmt::Debug for OriginalMethodSlot {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("OriginalMethodSlot()"))
            }
        }
        impl From<OriginalMethodSlot> for MethodSlot {
            fn from(v: OriginalMethodSlot) -> Self {
                MethodSlot(v.0.0.clone())
            }
        }
        impl From<OriginalMethodSlot> for Entity {
            fn from(v: OriginalMethodSlot) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct MethodSlotAfterSubstitution(MethodSlot);
        #[automatically_derived]
        impl ::core::clone::Clone for MethodSlotAfterSubstitution {
            #[inline]
            fn clone(&self) -> MethodSlotAfterSubstitution {
                MethodSlotAfterSubstitution(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MethodSlotAfterSubstitution {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MethodSlotAfterSubstitution {
            #[inline]
            fn eq(&self, other: &MethodSlotAfterSubstitution) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for MethodSlotAfterSubstitution {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for MethodSlotAfterSubstitution {
            type Target = MethodSlot;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for MethodSlotAfterSubstitution {}
        impl ::std::fmt::Debug for MethodSlotAfterSubstitution {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("MethodSlotAfterSubstitution()"))
            }
        }
        impl From<MethodSlotAfterSubstitution> for MethodSlot {
            fn from(v: MethodSlotAfterSubstitution) -> Self {
                MethodSlot(v.0.0.clone())
            }
        }
        impl From<MethodSlotAfterSubstitution> for Entity {
            fn from(v: MethodSlotAfterSubstitution) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct Scope(Entity);
        #[automatically_derived]
        impl ::core::clone::Clone for Scope {
            #[inline]
            fn clone(&self) -> Scope {
                Scope(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Scope {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Scope {
            #[inline]
            fn eq(&self, other: &Scope) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Scope {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for Scope {
            type Target = Entity;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for Scope {}
        impl ::std::fmt::Debug for Scope {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("Scope()"))
            }
        }
        impl From<Scope> for Entity {
            fn from(v: Scope) -> Self {
                Entity(v.0.0.clone())
            }
        }
        impl TryFrom<Scope> for WithScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Scope) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_WithScope(_o) = &_o
                        .__variant
                    {
                        Ok(WithScope(Scope(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Scope> for FilterScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Scope) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FilterScope(_o) = &_o
                        .__variant
                    {
                        Ok(FilterScope(Scope(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Scope> for Activation {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Scope) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_Activation(_o) = &_o
                        .__variant
                    {
                        Ok(Activation(Scope(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Scope> for FixtureScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Scope) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FixtureScope(_o) = &_o
                        .__variant
                    {
                        Ok(FixtureScope(Scope(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Scope> for ClassScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Scope) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FixtureScope(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_FixtureScope::__data_ClassScope(_o) = &_o
                            .__variant
                        {
                            Ok(ClassScope(FixtureScope(Scope(Entity(v.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Scope> for EnumScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Scope) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FixtureScope(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_FixtureScope::__data_EnumScope(_o) = &_o
                            .__variant
                        {
                            Ok(EnumScope(FixtureScope(Scope(Entity(v.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Scope> for InterfaceScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Scope) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FixtureScope(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_FixtureScope::__data_InterfaceScope(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                InterfaceScope(FixtureScope(Scope(Entity(v.0.0.clone())))),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Scope> for PackageScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Scope) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FixtureScope(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_FixtureScope::__data_PackageScope(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(PackageScope(FixtureScope(Scope(Entity(v.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        pub struct WithScope(Scope);
        #[automatically_derived]
        impl ::core::clone::Clone for WithScope {
            #[inline]
            fn clone(&self) -> WithScope {
                WithScope(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for WithScope {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for WithScope {
            #[inline]
            fn eq(&self, other: &WithScope) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for WithScope {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for WithScope {
            type Target = Scope;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for WithScope {}
        impl ::std::fmt::Debug for WithScope {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("WithScope()"))
            }
        }
        impl From<WithScope> for Scope {
            fn from(v: WithScope) -> Self {
                Scope(v.0.0.clone())
            }
        }
        impl From<WithScope> for Entity {
            fn from(v: WithScope) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct FilterScope(Scope);
        #[automatically_derived]
        impl ::core::clone::Clone for FilterScope {
            #[inline]
            fn clone(&self) -> FilterScope {
                FilterScope(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for FilterScope {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for FilterScope {
            #[inline]
            fn eq(&self, other: &FilterScope) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for FilterScope {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for FilterScope {
            type Target = Scope;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for FilterScope {}
        impl ::std::fmt::Debug for FilterScope {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("FilterScope()"))
            }
        }
        impl From<FilterScope> for Scope {
            fn from(v: FilterScope) -> Self {
                Scope(v.0.0.clone())
            }
        }
        impl From<FilterScope> for Entity {
            fn from(v: FilterScope) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct Activation(Scope);
        #[automatically_derived]
        impl ::core::clone::Clone for Activation {
            #[inline]
            fn clone(&self) -> Activation {
                Activation(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Activation {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Activation {
            #[inline]
            fn eq(&self, other: &Activation) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Activation {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for Activation {
            type Target = Scope;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for Activation {}
        impl ::std::fmt::Debug for Activation {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("Activation()"))
            }
        }
        impl From<Activation> for Scope {
            fn from(v: Activation) -> Self {
                Scope(v.0.0.clone())
            }
        }
        impl From<Activation> for Entity {
            fn from(v: Activation) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct FixtureScope(Scope);
        #[automatically_derived]
        impl ::core::clone::Clone for FixtureScope {
            #[inline]
            fn clone(&self) -> FixtureScope {
                FixtureScope(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for FixtureScope {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for FixtureScope {
            #[inline]
            fn eq(&self, other: &FixtureScope) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for FixtureScope {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for FixtureScope {
            type Target = Scope;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for FixtureScope {}
        impl ::std::fmt::Debug for FixtureScope {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("FixtureScope()"))
            }
        }
        impl From<FixtureScope> for Scope {
            fn from(v: FixtureScope) -> Self {
                Scope(v.0.0.clone())
            }
        }
        impl From<FixtureScope> for Entity {
            fn from(v: FixtureScope) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        impl TryFrom<FixtureScope> for ClassScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: FixtureScope) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FixtureScope(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_FixtureScope::__data_ClassScope(_o) = &_o
                            .__variant
                        {
                            Ok(ClassScope(FixtureScope(Scope(Entity(v.0.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<FixtureScope> for EnumScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: FixtureScope) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FixtureScope(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_FixtureScope::__data_EnumScope(_o) = &_o
                            .__variant
                        {
                            Ok(EnumScope(FixtureScope(Scope(Entity(v.0.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<FixtureScope> for InterfaceScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: FixtureScope) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FixtureScope(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_FixtureScope::__data_InterfaceScope(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                InterfaceScope(FixtureScope(Scope(Entity(v.0.0.0.clone())))),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<FixtureScope> for PackageScope {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: FixtureScope) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Scope(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Scope::__data_FixtureScope(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_FixtureScope::__data_PackageScope(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                PackageScope(FixtureScope(Scope(Entity(v.0.0.0.clone())))),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        pub struct ClassScope(FixtureScope);
        #[automatically_derived]
        impl ::core::clone::Clone for ClassScope {
            #[inline]
            fn clone(&self) -> ClassScope {
                ClassScope(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ClassScope {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ClassScope {
            #[inline]
            fn eq(&self, other: &ClassScope) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ClassScope {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for ClassScope {
            type Target = FixtureScope;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for ClassScope {}
        impl ::std::fmt::Debug for ClassScope {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("ClassScope()"))
            }
        }
        impl From<ClassScope> for FixtureScope {
            fn from(v: ClassScope) -> Self {
                FixtureScope(v.0.0.clone())
            }
        }
        impl From<ClassScope> for Scope {
            fn from(v: ClassScope) -> Self {
                Scope(v.0.0.0.clone())
            }
        }
        impl From<ClassScope> for Entity {
            fn from(v: ClassScope) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        pub struct EnumScope(FixtureScope);
        #[automatically_derived]
        impl ::core::clone::Clone for EnumScope {
            #[inline]
            fn clone(&self) -> EnumScope {
                EnumScope(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for EnumScope {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for EnumScope {
            #[inline]
            fn eq(&self, other: &EnumScope) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for EnumScope {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for EnumScope {
            type Target = FixtureScope;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for EnumScope {}
        impl ::std::fmt::Debug for EnumScope {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("EnumScope()"))
            }
        }
        impl From<EnumScope> for FixtureScope {
            fn from(v: EnumScope) -> Self {
                FixtureScope(v.0.0.clone())
            }
        }
        impl From<EnumScope> for Scope {
            fn from(v: EnumScope) -> Self {
                Scope(v.0.0.0.clone())
            }
        }
        impl From<EnumScope> for Entity {
            fn from(v: EnumScope) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        pub struct InterfaceScope(FixtureScope);
        #[automatically_derived]
        impl ::core::clone::Clone for InterfaceScope {
            #[inline]
            fn clone(&self) -> InterfaceScope {
                InterfaceScope(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for InterfaceScope {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for InterfaceScope {
            #[inline]
            fn eq(&self, other: &InterfaceScope) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for InterfaceScope {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for InterfaceScope {
            type Target = FixtureScope;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for InterfaceScope {}
        impl ::std::fmt::Debug for InterfaceScope {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("InterfaceScope()"))
            }
        }
        impl From<InterfaceScope> for FixtureScope {
            fn from(v: InterfaceScope) -> Self {
                FixtureScope(v.0.0.clone())
            }
        }
        impl From<InterfaceScope> for Scope {
            fn from(v: InterfaceScope) -> Self {
                Scope(v.0.0.0.clone())
            }
        }
        impl From<InterfaceScope> for Entity {
            fn from(v: InterfaceScope) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        pub struct PackageScope(FixtureScope);
        #[automatically_derived]
        impl ::core::clone::Clone for PackageScope {
            #[inline]
            fn clone(&self) -> PackageScope {
                PackageScope(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PackageScope {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PackageScope {
            #[inline]
            fn eq(&self, other: &PackageScope) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for PackageScope {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for PackageScope {
            type Target = FixtureScope;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for PackageScope {}
        impl ::std::fmt::Debug for PackageScope {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("PackageScope()"))
            }
        }
        impl From<PackageScope> for FixtureScope {
            fn from(v: PackageScope) -> Self {
                FixtureScope(v.0.0.clone())
            }
        }
        impl From<PackageScope> for Scope {
            fn from(v: PackageScope) -> Self {
                Scope(v.0.0.0.clone())
            }
        }
        impl From<PackageScope> for Entity {
            fn from(v: PackageScope) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        pub struct Value(Entity);
        #[automatically_derived]
        impl ::core::clone::Clone for Value {
            #[inline]
            fn clone(&self) -> Value {
                Value(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Value {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Value {
            #[inline]
            fn eq(&self, other: &Value) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Value {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for Value {
            type Target = Entity;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for Value {}
        impl ::std::fmt::Debug for Value {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("Value()"))
            }
        }
        impl From<Value> for Entity {
            fn from(v: Value) -> Self {
                Entity(v.0.0.clone())
            }
        }
        impl TryFrom<Value> for PackagePropertyImport {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_PackagePropertyImport(_o) = &_o
                        .__variant
                    {
                        Ok(PackagePropertyImport(Value(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for PackageWildcardImport {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_PackageWildcardImport(_o) = &_o
                        .__variant
                    {
                        Ok(PackageWildcardImport(Value(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for PackageRecursiveImport {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_PackageRecursiveImport(
                        _o,
                    ) = &_o.__variant
                    {
                        Ok(PackageRecursiveImport(Value(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for Constant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        Ok(Constant(Value(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for UndefinedConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_UndefinedConstant(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(UndefinedConstant(Constant(Value(Entity(v.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for NullConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_NullConstant(_o) = &_o
                            .__variant
                        {
                            Ok(NullConstant(Constant(Value(Entity(v.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for NamespaceConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_NamespaceConstant(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(NamespaceConstant(Constant(Value(Entity(v.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for TypeConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_TypeConstant(_o) = &_o
                            .__variant
                        {
                            Ok(TypeConstant(Constant(Value(Entity(v.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for NumberConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_NumberConstant(_o) = &_o
                            .__variant
                        {
                            Ok(NumberConstant(Constant(Value(Entity(v.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for StringConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_StringConstant(_o) = &_o
                            .__variant
                        {
                            Ok(StringConstant(Constant(Value(Entity(v.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for BooleanConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_BooleanConstant(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(BooleanConstant(Constant(Value(Entity(v.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for ThisObject {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ThisObject(_o) = &_o
                        .__variant
                    {
                        Ok(ThisObject(Value(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for MetaProperty {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_MetaProperty(_o) = &_o
                        .__variant
                    {
                        Ok(MetaProperty(Value(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for MetaEnvProperty {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_MetaEnvProperty(_o) = &_o
                        .__variant
                    {
                        Ok(MetaEnvProperty(Value(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for ReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        Ok(ReferenceValue(Value(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for XmlReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_XmlReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                XmlReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for DynamicReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_DynamicReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                DynamicReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for FixtureReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                FixtureReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for StaticReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_StaticReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    StaticReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for InstanceReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_InstanceReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    InstanceReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for ScopeReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_ScopeReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    ScopeReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for PackageReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_PackageReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    PackageReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for StaticDynamicReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_StaticDynamicReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                StaticDynamicReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for TupleReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_TupleReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                TupleReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for DynamicScopeReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_DynamicScopeReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                DynamicScopeReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for ArrayElementReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_ArrayElementReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                ArrayElementReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for VectorElementReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_VectorElementReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                VectorElementReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for ConversionValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ConversionValue(_o) = &_o
                        .__variant
                    {
                        Ok(ConversionValue(Value(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for NonNullValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_NonNullValue(_o) = &_o
                        .__variant
                    {
                        Ok(NonNullValue(Value(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for LambdaObject {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_LambdaObject(_o) = &_o
                        .__variant
                    {
                        Ok(LambdaObject(Value(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Value> for FilterValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Value) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_FilterValue(_o) = &_o
                        .__variant
                    {
                        Ok(FilterValue(Value(Entity(v.0.0.clone()))))
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        pub struct PackagePropertyImport(Value);
        #[automatically_derived]
        impl ::core::clone::Clone for PackagePropertyImport {
            #[inline]
            fn clone(&self) -> PackagePropertyImport {
                PackagePropertyImport(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PackagePropertyImport {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PackagePropertyImport {
            #[inline]
            fn eq(&self, other: &PackagePropertyImport) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for PackagePropertyImport {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for PackagePropertyImport {
            type Target = Value;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for PackagePropertyImport {}
        impl ::std::fmt::Debug for PackagePropertyImport {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("PackagePropertyImport()"))
            }
        }
        impl From<PackagePropertyImport> for Value {
            fn from(v: PackagePropertyImport) -> Self {
                Value(v.0.0.clone())
            }
        }
        impl From<PackagePropertyImport> for Entity {
            fn from(v: PackagePropertyImport) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct PackageWildcardImport(Value);
        #[automatically_derived]
        impl ::core::clone::Clone for PackageWildcardImport {
            #[inline]
            fn clone(&self) -> PackageWildcardImport {
                PackageWildcardImport(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PackageWildcardImport {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PackageWildcardImport {
            #[inline]
            fn eq(&self, other: &PackageWildcardImport) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for PackageWildcardImport {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for PackageWildcardImport {
            type Target = Value;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for PackageWildcardImport {}
        impl ::std::fmt::Debug for PackageWildcardImport {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("PackageWildcardImport()"))
            }
        }
        impl From<PackageWildcardImport> for Value {
            fn from(v: PackageWildcardImport) -> Self {
                Value(v.0.0.clone())
            }
        }
        impl From<PackageWildcardImport> for Entity {
            fn from(v: PackageWildcardImport) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct PackageRecursiveImport(Value);
        #[automatically_derived]
        impl ::core::clone::Clone for PackageRecursiveImport {
            #[inline]
            fn clone(&self) -> PackageRecursiveImport {
                PackageRecursiveImport(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PackageRecursiveImport {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PackageRecursiveImport {
            #[inline]
            fn eq(&self, other: &PackageRecursiveImport) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for PackageRecursiveImport {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for PackageRecursiveImport {
            type Target = Value;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for PackageRecursiveImport {}
        impl ::std::fmt::Debug for PackageRecursiveImport {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("PackageRecursiveImport()"))
            }
        }
        impl From<PackageRecursiveImport> for Value {
            fn from(v: PackageRecursiveImport) -> Self {
                Value(v.0.0.clone())
            }
        }
        impl From<PackageRecursiveImport> for Entity {
            fn from(v: PackageRecursiveImport) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct Constant(Value);
        #[automatically_derived]
        impl ::core::clone::Clone for Constant {
            #[inline]
            fn clone(&self) -> Constant {
                Constant(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Constant {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Constant {
            #[inline]
            fn eq(&self, other: &Constant) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Constant {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for Constant {
            type Target = Value;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for Constant {}
        impl ::std::fmt::Debug for Constant {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("Constant()"))
            }
        }
        impl From<Constant> for Value {
            fn from(v: Constant) -> Self {
                Value(v.0.0.clone())
            }
        }
        impl From<Constant> for Entity {
            fn from(v: Constant) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        impl TryFrom<Constant> for UndefinedConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Constant) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_UndefinedConstant(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                UndefinedConstant(Constant(Value(Entity(v.0.0.0.clone())))),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Constant> for NullConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Constant) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_NullConstant(_o) = &_o
                            .__variant
                        {
                            Ok(NullConstant(Constant(Value(Entity(v.0.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Constant> for NamespaceConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Constant) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_NamespaceConstant(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                NamespaceConstant(Constant(Value(Entity(v.0.0.0.clone())))),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Constant> for TypeConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Constant) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_TypeConstant(_o) = &_o
                            .__variant
                        {
                            Ok(TypeConstant(Constant(Value(Entity(v.0.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Constant> for NumberConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Constant) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_NumberConstant(_o) = &_o
                            .__variant
                        {
                            Ok(NumberConstant(Constant(Value(Entity(v.0.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Constant> for StringConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Constant) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_StringConstant(_o) = &_o
                            .__variant
                        {
                            Ok(StringConstant(Constant(Value(Entity(v.0.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<Constant> for BooleanConstant {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: Constant) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_Constant(_o) = &_o.__variant
                    {
                        if let __data__::__variant_Constant::__data_BooleanConstant(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(BooleanConstant(Constant(Value(Entity(v.0.0.0.clone())))))
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        /// Constant with possible types being `*` or `Object`.
        pub struct UndefinedConstant(Constant);
        #[automatically_derived]
        impl ::core::clone::Clone for UndefinedConstant {
            #[inline]
            fn clone(&self) -> UndefinedConstant {
                UndefinedConstant(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for UndefinedConstant {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for UndefinedConstant {
            #[inline]
            fn eq(&self, other: &UndefinedConstant) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for UndefinedConstant {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for UndefinedConstant {
            type Target = Constant;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for UndefinedConstant {}
        impl ::std::fmt::Debug for UndefinedConstant {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("UndefinedConstant()"))
            }
        }
        impl From<UndefinedConstant> for Constant {
            fn from(v: UndefinedConstant) -> Self {
                Constant(v.0.0.clone())
            }
        }
        impl From<UndefinedConstant> for Value {
            fn from(v: UndefinedConstant) -> Self {
                Value(v.0.0.0.clone())
            }
        }
        impl From<UndefinedConstant> for Entity {
            fn from(v: UndefinedConstant) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        pub struct NullConstant(Constant);
        #[automatically_derived]
        impl ::core::clone::Clone for NullConstant {
            #[inline]
            fn clone(&self) -> NullConstant {
                NullConstant(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NullConstant {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NullConstant {
            #[inline]
            fn eq(&self, other: &NullConstant) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for NullConstant {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for NullConstant {
            type Target = Constant;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for NullConstant {}
        impl ::std::fmt::Debug for NullConstant {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("NullConstant()"))
            }
        }
        impl From<NullConstant> for Constant {
            fn from(v: NullConstant) -> Self {
                Constant(v.0.0.clone())
            }
        }
        impl From<NullConstant> for Value {
            fn from(v: NullConstant) -> Self {
                Value(v.0.0.0.clone())
            }
        }
        impl From<NullConstant> for Entity {
            fn from(v: NullConstant) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        pub struct NamespaceConstant(Constant);
        #[automatically_derived]
        impl ::core::clone::Clone for NamespaceConstant {
            #[inline]
            fn clone(&self) -> NamespaceConstant {
                NamespaceConstant(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NamespaceConstant {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NamespaceConstant {
            #[inline]
            fn eq(&self, other: &NamespaceConstant) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for NamespaceConstant {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for NamespaceConstant {
            type Target = Constant;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for NamespaceConstant {}
        impl ::std::fmt::Debug for NamespaceConstant {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("NamespaceConstant()"))
            }
        }
        impl From<NamespaceConstant> for Constant {
            fn from(v: NamespaceConstant) -> Self {
                Constant(v.0.0.clone())
            }
        }
        impl From<NamespaceConstant> for Value {
            fn from(v: NamespaceConstant) -> Self {
                Value(v.0.0.0.clone())
            }
        }
        impl From<NamespaceConstant> for Entity {
            fn from(v: NamespaceConstant) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        pub struct TypeConstant(Constant);
        #[automatically_derived]
        impl ::core::clone::Clone for TypeConstant {
            #[inline]
            fn clone(&self) -> TypeConstant {
                TypeConstant(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TypeConstant {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TypeConstant {
            #[inline]
            fn eq(&self, other: &TypeConstant) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TypeConstant {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for TypeConstant {
            type Target = Constant;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for TypeConstant {}
        impl ::std::fmt::Debug for TypeConstant {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("TypeConstant()"))
            }
        }
        impl From<TypeConstant> for Constant {
            fn from(v: TypeConstant) -> Self {
                Constant(v.0.0.clone())
            }
        }
        impl From<TypeConstant> for Value {
            fn from(v: TypeConstant) -> Self {
                Value(v.0.0.0.clone())
            }
        }
        impl From<TypeConstant> for Entity {
            fn from(v: TypeConstant) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        pub struct NumberConstant(Constant);
        #[automatically_derived]
        impl ::core::clone::Clone for NumberConstant {
            #[inline]
            fn clone(&self) -> NumberConstant {
                NumberConstant(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NumberConstant {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NumberConstant {
            #[inline]
            fn eq(&self, other: &NumberConstant) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for NumberConstant {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for NumberConstant {
            type Target = Constant;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for NumberConstant {}
        impl ::std::fmt::Debug for NumberConstant {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("NumberConstant()"))
            }
        }
        impl From<NumberConstant> for Constant {
            fn from(v: NumberConstant) -> Self {
                Constant(v.0.0.clone())
            }
        }
        impl From<NumberConstant> for Value {
            fn from(v: NumberConstant) -> Self {
                Value(v.0.0.0.clone())
            }
        }
        impl From<NumberConstant> for Entity {
            fn from(v: NumberConstant) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        pub struct StringConstant(Constant);
        #[automatically_derived]
        impl ::core::clone::Clone for StringConstant {
            #[inline]
            fn clone(&self) -> StringConstant {
                StringConstant(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for StringConstant {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for StringConstant {
            #[inline]
            fn eq(&self, other: &StringConstant) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for StringConstant {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for StringConstant {
            type Target = Constant;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for StringConstant {}
        impl ::std::fmt::Debug for StringConstant {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("StringConstant()"))
            }
        }
        impl From<StringConstant> for Constant {
            fn from(v: StringConstant) -> Self {
                Constant(v.0.0.clone())
            }
        }
        impl From<StringConstant> for Value {
            fn from(v: StringConstant) -> Self {
                Value(v.0.0.0.clone())
            }
        }
        impl From<StringConstant> for Entity {
            fn from(v: StringConstant) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        pub struct BooleanConstant(Constant);
        #[automatically_derived]
        impl ::core::clone::Clone for BooleanConstant {
            #[inline]
            fn clone(&self) -> BooleanConstant {
                BooleanConstant(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for BooleanConstant {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for BooleanConstant {
            #[inline]
            fn eq(&self, other: &BooleanConstant) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for BooleanConstant {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for BooleanConstant {
            type Target = Constant;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for BooleanConstant {}
        impl ::std::fmt::Debug for BooleanConstant {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("BooleanConstant()"))
            }
        }
        impl From<BooleanConstant> for Constant {
            fn from(v: BooleanConstant) -> Self {
                Constant(v.0.0.clone())
            }
        }
        impl From<BooleanConstant> for Value {
            fn from(v: BooleanConstant) -> Self {
                Value(v.0.0.0.clone())
            }
        }
        impl From<BooleanConstant> for Entity {
            fn from(v: BooleanConstant) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        pub struct ThisObject(Value);
        #[automatically_derived]
        impl ::core::clone::Clone for ThisObject {
            #[inline]
            fn clone(&self) -> ThisObject {
                ThisObject(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ThisObject {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ThisObject {
            #[inline]
            fn eq(&self, other: &ThisObject) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ThisObject {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for ThisObject {
            type Target = Value;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for ThisObject {}
        impl ::std::fmt::Debug for ThisObject {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("ThisObject()"))
            }
        }
        impl From<ThisObject> for Value {
            fn from(v: ThisObject) -> Self {
                Value(v.0.0.clone())
            }
        }
        impl From<ThisObject> for Entity {
            fn from(v: ThisObject) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// The `import.meta` value.
        pub struct MetaProperty(Value);
        #[automatically_derived]
        impl ::core::clone::Clone for MetaProperty {
            #[inline]
            fn clone(&self) -> MetaProperty {
                MetaProperty(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MetaProperty {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MetaProperty {
            #[inline]
            fn eq(&self, other: &MetaProperty) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for MetaProperty {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for MetaProperty {
            type Target = Value;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for MetaProperty {}
        impl ::std::fmt::Debug for MetaProperty {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("MetaProperty()"))
            }
        }
        impl From<MetaProperty> for Value {
            fn from(v: MetaProperty) -> Self {
                Value(v.0.0.clone())
            }
        }
        impl From<MetaProperty> for Entity {
            fn from(v: MetaProperty) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// The `import.meta.env` value.
        pub struct MetaEnvProperty(Value);
        #[automatically_derived]
        impl ::core::clone::Clone for MetaEnvProperty {
            #[inline]
            fn clone(&self) -> MetaEnvProperty {
                MetaEnvProperty(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MetaEnvProperty {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MetaEnvProperty {
            #[inline]
            fn eq(&self, other: &MetaEnvProperty) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for MetaEnvProperty {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for MetaEnvProperty {
            type Target = Value;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for MetaEnvProperty {}
        impl ::std::fmt::Debug for MetaEnvProperty {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("MetaEnvProperty()"))
            }
        }
        impl From<MetaEnvProperty> for Value {
            fn from(v: MetaEnvProperty) -> Self {
                Value(v.0.0.clone())
            }
        }
        impl From<MetaEnvProperty> for Entity {
            fn from(v: MetaEnvProperty) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        pub struct ReferenceValue(Value);
        #[automatically_derived]
        impl ::core::clone::Clone for ReferenceValue {
            #[inline]
            fn clone(&self) -> ReferenceValue {
                ReferenceValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ReferenceValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ReferenceValue {
            #[inline]
            fn eq(&self, other: &ReferenceValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ReferenceValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for ReferenceValue {
            type Target = Value;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for ReferenceValue {}
        impl ::std::fmt::Debug for ReferenceValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("ReferenceValue()"))
            }
        }
        impl From<ReferenceValue> for Value {
            fn from(v: ReferenceValue) -> Self {
                Value(v.0.0.clone())
            }
        }
        impl From<ReferenceValue> for Entity {
            fn from(v: ReferenceValue) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        impl TryFrom<ReferenceValue> for XmlReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: ReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_XmlReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                XmlReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<ReferenceValue> for DynamicReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: ReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_DynamicReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                DynamicReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<ReferenceValue> for FixtureReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: ReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                FixtureReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<ReferenceValue> for StaticReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: ReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_StaticReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    StaticReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.0.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<ReferenceValue> for InstanceReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: ReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_InstanceReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    InstanceReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.0.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<ReferenceValue> for ScopeReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: ReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_ScopeReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    ScopeReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.0.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<ReferenceValue> for PackageReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: ReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_PackageReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    PackageReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.0.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<ReferenceValue> for StaticDynamicReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: ReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_StaticDynamicReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                StaticDynamicReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<ReferenceValue> for TupleReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: ReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_TupleReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                TupleReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<ReferenceValue> for DynamicScopeReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: ReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_DynamicScopeReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                DynamicScopeReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<ReferenceValue> for ArrayElementReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: ReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_ArrayElementReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                ArrayElementReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<ReferenceValue> for VectorElementReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: ReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_VectorElementReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            Ok(
                                VectorElementReferenceValue(
                                    ReferenceValue(Value(Entity(v.0.0.0.clone()))),
                                ),
                            )
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        /// Possibly uses attribute.
        pub struct XmlReferenceValue(ReferenceValue);
        #[automatically_derived]
        impl ::core::clone::Clone for XmlReferenceValue {
            #[inline]
            fn clone(&self) -> XmlReferenceValue {
                XmlReferenceValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for XmlReferenceValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for XmlReferenceValue {
            #[inline]
            fn eq(&self, other: &XmlReferenceValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for XmlReferenceValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for XmlReferenceValue {
            type Target = ReferenceValue;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for XmlReferenceValue {}
        impl ::std::fmt::Debug for XmlReferenceValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("XmlReferenceValue()"))
            }
        }
        impl From<XmlReferenceValue> for ReferenceValue {
            fn from(v: XmlReferenceValue) -> Self {
                ReferenceValue(v.0.0.clone())
            }
        }
        impl From<XmlReferenceValue> for Value {
            fn from(v: XmlReferenceValue) -> Self {
                Value(v.0.0.0.clone())
            }
        }
        impl From<XmlReferenceValue> for Entity {
            fn from(v: XmlReferenceValue) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        /// Possibly uses attribute.
        pub struct DynamicReferenceValue(ReferenceValue);
        #[automatically_derived]
        impl ::core::clone::Clone for DynamicReferenceValue {
            #[inline]
            fn clone(&self) -> DynamicReferenceValue {
                DynamicReferenceValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DynamicReferenceValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DynamicReferenceValue {
            #[inline]
            fn eq(&self, other: &DynamicReferenceValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for DynamicReferenceValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for DynamicReferenceValue {
            type Target = ReferenceValue;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for DynamicReferenceValue {}
        impl ::std::fmt::Debug for DynamicReferenceValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("DynamicReferenceValue()"))
            }
        }
        impl From<DynamicReferenceValue> for ReferenceValue {
            fn from(v: DynamicReferenceValue) -> Self {
                ReferenceValue(v.0.0.clone())
            }
        }
        impl From<DynamicReferenceValue> for Value {
            fn from(v: DynamicReferenceValue) -> Self {
                Value(v.0.0.0.clone())
            }
        }
        impl From<DynamicReferenceValue> for Entity {
            fn from(v: DynamicReferenceValue) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        pub struct FixtureReferenceValue(ReferenceValue);
        #[automatically_derived]
        impl ::core::clone::Clone for FixtureReferenceValue {
            #[inline]
            fn clone(&self) -> FixtureReferenceValue {
                FixtureReferenceValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for FixtureReferenceValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for FixtureReferenceValue {
            #[inline]
            fn eq(&self, other: &FixtureReferenceValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for FixtureReferenceValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for FixtureReferenceValue {
            type Target = ReferenceValue;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for FixtureReferenceValue {}
        impl ::std::fmt::Debug for FixtureReferenceValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("FixtureReferenceValue()"))
            }
        }
        impl From<FixtureReferenceValue> for ReferenceValue {
            fn from(v: FixtureReferenceValue) -> Self {
                ReferenceValue(v.0.0.clone())
            }
        }
        impl From<FixtureReferenceValue> for Value {
            fn from(v: FixtureReferenceValue) -> Self {
                Value(v.0.0.0.clone())
            }
        }
        impl From<FixtureReferenceValue> for Entity {
            fn from(v: FixtureReferenceValue) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        impl TryFrom<FixtureReferenceValue> for StaticReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: FixtureReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_StaticReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    StaticReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.0.0.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<FixtureReferenceValue> for InstanceReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: FixtureReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_InstanceReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    InstanceReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.0.0.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<FixtureReferenceValue> for ScopeReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: FixtureReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_ScopeReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    ScopeReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.0.0.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        impl TryFrom<FixtureReferenceValue> for PackageReferenceValue {
            type Error = ::hydroperfox_smodel::SModelError;
            fn try_from(v: FixtureReferenceValue) -> Result<Self, Self::Error> {
                if let __data__::__variant_Entity::__data_Value(_o) = &v
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    if let __data__::__variant_Value::__data_ReferenceValue(_o) = &_o
                        .__variant
                    {
                        if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            _o,
                        ) = &_o.__variant
                        {
                            if let __data__::__variant_FixtureReferenceValue::__data_PackageReferenceValue(
                                _o,
                            ) = &_o.__variant
                            {
                                Ok(
                                    PackageReferenceValue(
                                        FixtureReferenceValue(
                                            ReferenceValue(Value(Entity(v.0.0.0.0.clone()))),
                                        ),
                                    ),
                                )
                            } else {
                                Err(::hydroperfox_smodel::SModelError::Contravariant)
                            }
                        } else {
                            Err(::hydroperfox_smodel::SModelError::Contravariant)
                        }
                    } else {
                        Err(::hydroperfox_smodel::SModelError::Contravariant)
                    }
                } else {
                    Err(::hydroperfox_smodel::SModelError::Contravariant)
                }
            }
        }
        pub struct StaticReferenceValue(FixtureReferenceValue);
        #[automatically_derived]
        impl ::core::clone::Clone for StaticReferenceValue {
            #[inline]
            fn clone(&self) -> StaticReferenceValue {
                StaticReferenceValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for StaticReferenceValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for StaticReferenceValue {
            #[inline]
            fn eq(&self, other: &StaticReferenceValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for StaticReferenceValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for StaticReferenceValue {
            type Target = FixtureReferenceValue;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for StaticReferenceValue {}
        impl ::std::fmt::Debug for StaticReferenceValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("StaticReferenceValue()"))
            }
        }
        impl From<StaticReferenceValue> for FixtureReferenceValue {
            fn from(v: StaticReferenceValue) -> Self {
                FixtureReferenceValue(v.0.0.clone())
            }
        }
        impl From<StaticReferenceValue> for ReferenceValue {
            fn from(v: StaticReferenceValue) -> Self {
                ReferenceValue(v.0.0.0.clone())
            }
        }
        impl From<StaticReferenceValue> for Value {
            fn from(v: StaticReferenceValue) -> Self {
                Value(v.0.0.0.0.clone())
            }
        }
        impl From<StaticReferenceValue> for Entity {
            fn from(v: StaticReferenceValue) -> Self {
                Entity(v.0.0.0.0.0.clone())
            }
        }
        pub struct StaticDynamicReferenceValue(ReferenceValue);
        #[automatically_derived]
        impl ::core::clone::Clone for StaticDynamicReferenceValue {
            #[inline]
            fn clone(&self) -> StaticDynamicReferenceValue {
                StaticDynamicReferenceValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for StaticDynamicReferenceValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for StaticDynamicReferenceValue {
            #[inline]
            fn eq(&self, other: &StaticDynamicReferenceValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for StaticDynamicReferenceValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for StaticDynamicReferenceValue {
            type Target = ReferenceValue;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for StaticDynamicReferenceValue {}
        impl ::std::fmt::Debug for StaticDynamicReferenceValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("StaticDynamicReferenceValue()"))
            }
        }
        impl From<StaticDynamicReferenceValue> for ReferenceValue {
            fn from(v: StaticDynamicReferenceValue) -> Self {
                ReferenceValue(v.0.0.clone())
            }
        }
        impl From<StaticDynamicReferenceValue> for Value {
            fn from(v: StaticDynamicReferenceValue) -> Self {
                Value(v.0.0.0.clone())
            }
        }
        impl From<StaticDynamicReferenceValue> for Entity {
            fn from(v: StaticDynamicReferenceValue) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        /// Instance reference value in a possibly non nullable base.
        pub struct InstanceReferenceValue(FixtureReferenceValue);
        #[automatically_derived]
        impl ::core::clone::Clone for InstanceReferenceValue {
            #[inline]
            fn clone(&self) -> InstanceReferenceValue {
                InstanceReferenceValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for InstanceReferenceValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for InstanceReferenceValue {
            #[inline]
            fn eq(&self, other: &InstanceReferenceValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for InstanceReferenceValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for InstanceReferenceValue {
            type Target = FixtureReferenceValue;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for InstanceReferenceValue {}
        impl ::std::fmt::Debug for InstanceReferenceValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("InstanceReferenceValue()"))
            }
        }
        impl From<InstanceReferenceValue> for FixtureReferenceValue {
            fn from(v: InstanceReferenceValue) -> Self {
                FixtureReferenceValue(v.0.0.clone())
            }
        }
        impl From<InstanceReferenceValue> for ReferenceValue {
            fn from(v: InstanceReferenceValue) -> Self {
                ReferenceValue(v.0.0.0.clone())
            }
        }
        impl From<InstanceReferenceValue> for Value {
            fn from(v: InstanceReferenceValue) -> Self {
                Value(v.0.0.0.0.clone())
            }
        }
        impl From<InstanceReferenceValue> for Entity {
            fn from(v: InstanceReferenceValue) -> Self {
                Entity(v.0.0.0.0.0.clone())
            }
        }
        /// Tuple reference value in a possibly non nullable base.
        pub struct TupleReferenceValue(ReferenceValue);
        #[automatically_derived]
        impl ::core::clone::Clone for TupleReferenceValue {
            #[inline]
            fn clone(&self) -> TupleReferenceValue {
                TupleReferenceValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TupleReferenceValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TupleReferenceValue {
            #[inline]
            fn eq(&self, other: &TupleReferenceValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TupleReferenceValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for TupleReferenceValue {
            type Target = ReferenceValue;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for TupleReferenceValue {}
        impl ::std::fmt::Debug for TupleReferenceValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("TupleReferenceValue()"))
            }
        }
        impl From<TupleReferenceValue> for ReferenceValue {
            fn from(v: TupleReferenceValue) -> Self {
                ReferenceValue(v.0.0.clone())
            }
        }
        impl From<TupleReferenceValue> for Value {
            fn from(v: TupleReferenceValue) -> Self {
                Value(v.0.0.0.clone())
            }
        }
        impl From<TupleReferenceValue> for Entity {
            fn from(v: TupleReferenceValue) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        pub struct ScopeReferenceValue(FixtureReferenceValue);
        #[automatically_derived]
        impl ::core::clone::Clone for ScopeReferenceValue {
            #[inline]
            fn clone(&self) -> ScopeReferenceValue {
                ScopeReferenceValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ScopeReferenceValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ScopeReferenceValue {
            #[inline]
            fn eq(&self, other: &ScopeReferenceValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ScopeReferenceValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for ScopeReferenceValue {
            type Target = FixtureReferenceValue;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for ScopeReferenceValue {}
        impl ::std::fmt::Debug for ScopeReferenceValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("ScopeReferenceValue()"))
            }
        }
        impl From<ScopeReferenceValue> for FixtureReferenceValue {
            fn from(v: ScopeReferenceValue) -> Self {
                FixtureReferenceValue(v.0.0.clone())
            }
        }
        impl From<ScopeReferenceValue> for ReferenceValue {
            fn from(v: ScopeReferenceValue) -> Self {
                ReferenceValue(v.0.0.0.clone())
            }
        }
        impl From<ScopeReferenceValue> for Value {
            fn from(v: ScopeReferenceValue) -> Self {
                Value(v.0.0.0.0.clone())
            }
        }
        impl From<ScopeReferenceValue> for Entity {
            fn from(v: ScopeReferenceValue) -> Self {
                Entity(v.0.0.0.0.0.clone())
            }
        }
        /// Possibly uses attribute.
        pub struct DynamicScopeReferenceValue(ReferenceValue);
        #[automatically_derived]
        impl ::core::clone::Clone for DynamicScopeReferenceValue {
            #[inline]
            fn clone(&self) -> DynamicScopeReferenceValue {
                DynamicScopeReferenceValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DynamicScopeReferenceValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DynamicScopeReferenceValue {
            #[inline]
            fn eq(&self, other: &DynamicScopeReferenceValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for DynamicScopeReferenceValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for DynamicScopeReferenceValue {
            type Target = ReferenceValue;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for DynamicScopeReferenceValue {}
        impl ::std::fmt::Debug for DynamicScopeReferenceValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("DynamicScopeReferenceValue()"))
            }
        }
        impl From<DynamicScopeReferenceValue> for ReferenceValue {
            fn from(v: DynamicScopeReferenceValue) -> Self {
                ReferenceValue(v.0.0.clone())
            }
        }
        impl From<DynamicScopeReferenceValue> for Value {
            fn from(v: DynamicScopeReferenceValue) -> Self {
                Value(v.0.0.0.clone())
            }
        }
        impl From<DynamicScopeReferenceValue> for Entity {
            fn from(v: DynamicScopeReferenceValue) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        pub struct PackageReferenceValue(FixtureReferenceValue);
        #[automatically_derived]
        impl ::core::clone::Clone for PackageReferenceValue {
            #[inline]
            fn clone(&self) -> PackageReferenceValue {
                PackageReferenceValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PackageReferenceValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PackageReferenceValue {
            #[inline]
            fn eq(&self, other: &PackageReferenceValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for PackageReferenceValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for PackageReferenceValue {
            type Target = FixtureReferenceValue;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for PackageReferenceValue {}
        impl ::std::fmt::Debug for PackageReferenceValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("PackageReferenceValue()"))
            }
        }
        impl From<PackageReferenceValue> for FixtureReferenceValue {
            fn from(v: PackageReferenceValue) -> Self {
                FixtureReferenceValue(v.0.0.clone())
            }
        }
        impl From<PackageReferenceValue> for ReferenceValue {
            fn from(v: PackageReferenceValue) -> Self {
                ReferenceValue(v.0.0.0.clone())
            }
        }
        impl From<PackageReferenceValue> for Value {
            fn from(v: PackageReferenceValue) -> Self {
                Value(v.0.0.0.0.clone())
            }
        }
        impl From<PackageReferenceValue> for Entity {
            fn from(v: PackageReferenceValue) -> Self {
                Entity(v.0.0.0.0.0.clone())
            }
        }
        /// Array element reference value with a possibly non-nullable base.
        /// The key is assumed to be of the `Number` data type.
        pub struct ArrayElementReferenceValue(ReferenceValue);
        #[automatically_derived]
        impl ::core::clone::Clone for ArrayElementReferenceValue {
            #[inline]
            fn clone(&self) -> ArrayElementReferenceValue {
                ArrayElementReferenceValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ArrayElementReferenceValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ArrayElementReferenceValue {
            #[inline]
            fn eq(&self, other: &ArrayElementReferenceValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ArrayElementReferenceValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for ArrayElementReferenceValue {
            type Target = ReferenceValue;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for ArrayElementReferenceValue {}
        impl ::std::fmt::Debug for ArrayElementReferenceValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("ArrayElementReferenceValue()"))
            }
        }
        impl From<ArrayElementReferenceValue> for ReferenceValue {
            fn from(v: ArrayElementReferenceValue) -> Self {
                ReferenceValue(v.0.0.clone())
            }
        }
        impl From<ArrayElementReferenceValue> for Value {
            fn from(v: ArrayElementReferenceValue) -> Self {
                Value(v.0.0.0.clone())
            }
        }
        impl From<ArrayElementReferenceValue> for Entity {
            fn from(v: ArrayElementReferenceValue) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        /// Vector element reference value with a possibly non-nullable base.
        /// The key is assumed to be of the `Number` data type.
        pub struct VectorElementReferenceValue(ReferenceValue);
        #[automatically_derived]
        impl ::core::clone::Clone for VectorElementReferenceValue {
            #[inline]
            fn clone(&self) -> VectorElementReferenceValue {
                VectorElementReferenceValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for VectorElementReferenceValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for VectorElementReferenceValue {
            #[inline]
            fn eq(&self, other: &VectorElementReferenceValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for VectorElementReferenceValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for VectorElementReferenceValue {
            type Target = ReferenceValue;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for VectorElementReferenceValue {}
        impl ::std::fmt::Debug for VectorElementReferenceValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("VectorElementReferenceValue()"))
            }
        }
        impl From<VectorElementReferenceValue> for ReferenceValue {
            fn from(v: VectorElementReferenceValue) -> Self {
                ReferenceValue(v.0.0.clone())
            }
        }
        impl From<VectorElementReferenceValue> for Value {
            fn from(v: VectorElementReferenceValue) -> Self {
                Value(v.0.0.0.clone())
            }
        }
        impl From<VectorElementReferenceValue> for Entity {
            fn from(v: VectorElementReferenceValue) -> Self {
                Entity(v.0.0.0.0.clone())
            }
        }
        /// Represents the resulting value of a conversion, whether implicit or explicit.
        pub struct ConversionValue(Value);
        #[automatically_derived]
        impl ::core::clone::Clone for ConversionValue {
            #[inline]
            fn clone(&self) -> ConversionValue {
                ConversionValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ConversionValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ConversionValue {
            #[inline]
            fn eq(&self, other: &ConversionValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for ConversionValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for ConversionValue {
            type Target = Value;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for ConversionValue {}
        impl ::std::fmt::Debug for ConversionValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("ConversionValue()"))
            }
        }
        impl From<ConversionValue> for Value {
            fn from(v: ConversionValue) -> Self {
                Value(v.0.0.clone())
            }
        }
        impl From<ConversionValue> for Entity {
            fn from(v: ConversionValue) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// Non-null assertion value as part of fields from object destructuring.
        pub struct NonNullValue(Value);
        #[automatically_derived]
        impl ::core::clone::Clone for NonNullValue {
            #[inline]
            fn clone(&self) -> NonNullValue {
                NonNullValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NonNullValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NonNullValue {
            #[inline]
            fn eq(&self, other: &NonNullValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for NonNullValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for NonNullValue {
            type Target = Value;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for NonNullValue {}
        impl ::std::fmt::Debug for NonNullValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("NonNullValue()"))
            }
        }
        impl From<NonNullValue> for Value {
            fn from(v: NonNullValue) -> Self {
                Value(v.0.0.clone())
            }
        }
        impl From<NonNullValue> for Entity {
            fn from(v: NonNullValue) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// Represents the direct value of a `function` expression, holding back its activation.
        pub struct LambdaObject(Value);
        #[automatically_derived]
        impl ::core::clone::Clone for LambdaObject {
            #[inline]
            fn clone(&self) -> LambdaObject {
                LambdaObject(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for LambdaObject {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for LambdaObject {
            #[inline]
            fn eq(&self, other: &LambdaObject) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for LambdaObject {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for LambdaObject {
            type Target = Value;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for LambdaObject {}
        impl ::std::fmt::Debug for LambdaObject {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("LambdaObject()"))
            }
        }
        impl From<LambdaObject> for Value {
            fn from(v: LambdaObject) -> Self {
                Value(v.0.0.clone())
            }
        }
        impl From<LambdaObject> for Entity {
            fn from(v: LambdaObject) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// Represents the direct value of a filter expression, holding back its scope.
        pub struct FilterValue(Value);
        #[automatically_derived]
        impl ::core::clone::Clone for FilterValue {
            #[inline]
            fn clone(&self) -> FilterValue {
                FilterValue(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for FilterValue {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for FilterValue {
            #[inline]
            fn eq(&self, other: &FilterValue) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for FilterValue {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for FilterValue {
            type Target = Value;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for FilterValue {}
        impl ::std::fmt::Debug for FilterValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("FilterValue()"))
            }
        }
        impl From<FilterValue> for Value {
            fn from(v: FilterValue) -> Self {
                Value(v.0.0.clone())
            }
        }
        impl From<FilterValue> for Entity {
            fn from(v: FilterValue) -> Self {
                Entity(v.0.0.0.clone())
            }
        }
        /// Resolutions of a field in an object initializer, including shorthand resolution
        /// and the field slot. This is only assigned to a field where applicable.
        pub struct FieldResolution(Entity);
        #[automatically_derived]
        impl ::core::clone::Clone for FieldResolution {
            #[inline]
            fn clone(&self) -> FieldResolution {
                FieldResolution(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for FieldResolution {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for FieldResolution {
            #[inline]
            fn eq(&self, other: &FieldResolution) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for FieldResolution {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for FieldResolution {
            type Target = Entity;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for FieldResolution {}
        impl ::std::fmt::Debug for FieldResolution {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("FieldResolution()"))
            }
        }
        impl From<FieldResolution> for Entity {
            fn from(v: FieldResolution) -> Self {
                Entity(v.0.0.clone())
            }
        }
        /// Resolutions of a field in a declarative object destructuring pattern.
        pub struct DeclarativeFieldDestructuringResolution(Entity);
        #[automatically_derived]
        impl ::core::clone::Clone for DeclarativeFieldDestructuringResolution {
            #[inline]
            fn clone(&self) -> DeclarativeFieldDestructuringResolution {
                DeclarativeFieldDestructuringResolution(
                    ::core::clone::Clone::clone(&self.0),
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq
        for DeclarativeFieldDestructuringResolution {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DeclarativeFieldDestructuringResolution {
            #[inline]
            fn eq(&self, other: &DeclarativeFieldDestructuringResolution) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for DeclarativeFieldDestructuringResolution {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for DeclarativeFieldDestructuringResolution {
            type Target = Entity;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for DeclarativeFieldDestructuringResolution {}
        impl ::std::fmt::Debug for DeclarativeFieldDestructuringResolution {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("DeclarativeFieldDestructuringResolution()"))
            }
        }
        impl From<DeclarativeFieldDestructuringResolution> for Entity {
            fn from(v: DeclarativeFieldDestructuringResolution) -> Self {
                Entity(v.0.0.clone())
            }
        }
        /// Resolutions of a field in an assignment object destructuring pattern.
        pub struct AssignmentFieldDestructuringResolution(Entity);
        #[automatically_derived]
        impl ::core::clone::Clone for AssignmentFieldDestructuringResolution {
            #[inline]
            fn clone(&self) -> AssignmentFieldDestructuringResolution {
                AssignmentFieldDestructuringResolution(
                    ::core::clone::Clone::clone(&self.0),
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq
        for AssignmentFieldDestructuringResolution {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AssignmentFieldDestructuringResolution {
            #[inline]
            fn eq(&self, other: &AssignmentFieldDestructuringResolution) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for AssignmentFieldDestructuringResolution {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl ::std::ops::Deref for AssignmentFieldDestructuringResolution {
            type Target = Entity;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Eq for AssignmentFieldDestructuringResolution {}
        impl ::std::fmt::Debug for AssignmentFieldDestructuringResolution {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_fmt(format_args!("AssignmentFieldDestructuringResolution()"))
            }
        }
        impl From<AssignmentFieldDestructuringResolution> for Entity {
            fn from(v: AssignmentFieldDestructuringResolution) -> Self {
                Entity(v.0.0.clone())
            }
        }
        impl Entity {
            fn __ctor(&self) {}
            fn new(arena: &EntityArena) -> Self {
                let __cto1 = Entity(
                    arena
                        .allocate(__data__::__data_Entity {
                            __variant: __data__::__variant_Entity::__Nothing,
                        })
                        .clone(),
                );
                __cto1.__ctor();
                __cto1
            }
            fn __nd_defer(&self) -> Result<Entity, DeferError> {
                if self.is::<UnresolvedEntity>() {
                    Err(DeferError(None))
                } else {
                    Ok(self.clone())
                }
            }
            fn __nd_location(&self) -> Option<Location> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_location(&self, loc: Option<Location>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_qualifier(&self) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_key(&self) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_property_static_type(&self, host: &Database) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_is_dynamic_or_inherits_dynamic(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                Ok(false)
            }
            fn __nd_tuple_index(&self) -> usize {
                0
            }
            fn __nd_system_ns_kind(&self) -> Option<SystemNamespaceKind> {
                None
            }
            fn __nd_asdoc(&self) -> Option<Rc<Asdoc>> {
                None
            }
            fn __nd_set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {}
            fn __nd_metadata(&self) -> SharedArray<Rc<Metadata>> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_is_opt_variable_for_options_class(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                let st = self.static_type(host).defer()?;
                Ok(st.includes_null(host)? || st.includes_undefined(host)?)
            }
            fn __nd_escape_of_nullable(&self) -> Entity {
                self.clone()
            }
            fn __nd_escape_of_non_nullable(&self) -> Entity {
                self.clone()
            }
            fn __nd_escape_of_nullable_or_non_nullable(&self) -> Entity {
                self.clone()
            }
            fn __nd_object(&self) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_uri(&self) -> String {
                "".into()
            }
            fn __nd_open_ns_set(&self) -> SharedArray<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_import_list(&self) -> SharedArray<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_is_class_or_equivalent(&self) -> bool {
                self.is_class_type_possibly_after_sub() || self.is::<EnumType>()
                    || self.is::<TupleType>() || self.is::<FunctionType>()
            }
            fn __nd_local_name(&self) -> String {
                "".into()
            }
            fn __nd_class(&self) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_interface(&self) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_package(&self) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_of_method(&self) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_search_activation(&self) -> Option<Entity> {
                for scope in self.descending_scope_hierarchy() {
                    if scope.is::<Activation>() {
                        return Some(scope);
                    }
                }
                return None;
            }
            fn __nd_this(&self) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_this(&self, this: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_property_has_capture(&self, property: &Entity) -> bool {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_property_has_capture(&self, property: &Entity, value: bool) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_concat_open_ns_set_of_scope_chain(&self) -> SharedArray<Entity> {
                let mut open_ns_set = SharedArray::new();
                open_ns_set.extend(self.open_ns_set().iter());
                let mut p = self.parent();
                while let Some(p1) = p {
                    open_ns_set.extend(p1.open_ns_set().iter());
                    p = p1.parent();
                }
                open_ns_set
            }
            fn __nd_referenced_type(&self) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_referenced_ns(&self) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_shorthand_resolution(&self) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_shorthand_resolution(&self, value: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_field_slot(&self) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_field_slot(&self, value: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_is_entity_after_substitution(&self) -> bool {
                self.is::<TypeAfterSubstitution>()
                    || self.is::<VariableSlotAfterSubstitution>()
                    || self.is::<VirtualSlotAfterSubstitution>()
                    || self.is::<MethodSlotAfterSubstitution>()
            }
            fn __nd_parent(&self) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_parent(&self, p: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_package_concats(&self) -> SharedArray<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_public_ns(&self) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_public_ns(&self, ns: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_private_ns(&self) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_private_ns(&self, ns: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_protected_ns(&self) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_protected_ns(&self, ns: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_static_protected_ns(&self) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_static_protected_ns(&self, ns: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_internal_ns(&self) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_internal_ns(&self, ns: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_is_public_ns(&self) -> bool {
                false
            }
            fn __nd_is_private_ns(&self) -> bool {
                false
            }
            fn __nd_is_protected_ns(&self) -> bool {
                false
            }
            fn __nd_is_internal_ns(&self) -> bool {
                false
            }
            fn __nd_is_static_protected_ns(&self) -> bool {
                false
            }
            fn __nd_is_parameterized_type_or_type_after_sub(&self) -> bool {
                if self.is::<ClassType>() || self.is::<InterfaceType>() {
                    self.type_params().is_some()
                } else {
                    self.is::<TypeAfterSubstitution>()
                }
            }
            fn __nd_is_package_self_referential(&self, pckg: &Entity) -> bool {
                if self == pckg {
                    return true;
                }
                let mut p = self.parent();
                while let Some(p1) = p {
                    if &p1 == pckg {
                        return true;
                    }
                    p = p1.parent();
                }
                false
            }
            fn __nd_is_global_initialization(&self) -> bool {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_is_global_initialization(&self, value: bool) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_is_package_initialization(&self) -> bool {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_is_package_initialization(&self, value: bool) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_number_value(&self) -> Number {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_string_value(&self) -> String {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_boolean_value(&self) -> bool {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_type_default_value(
                &self,
                host: &Database,
            ) -> Result<Option<Entity>, DeferError> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_conversion_kind(&self) -> ConversionKind {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_conversion_is_opt(&self) -> bool {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_conversion_target(&self) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_is_class_type_possibly_after_sub(&self) -> bool {
                false
            }
            fn __nd_is_interface_type_possibly_after_sub(&self) -> bool {
                false
            }
            fn __nd_events(&self) -> SharedMap<String, Event> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_bindable_event(&self) -> Option<String> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_bindable_event(&self, name: Option<String>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_scope(&self) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_getter(&self, host: &Database) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_getter(&self, m: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_setter(&self, host: &Database) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_setter(&self, m: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_static_type(&self, host: &Database) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_static_type(&self, value: Entity) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_clone_constant(&self, host: &Database) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_is_abstract(&self) -> bool {
                false
            }
            fn __nd_set_is_abstract(&self, value: bool) {}
            fn __nd_is_final(&self) -> bool {
                false
            }
            fn __nd_set_is_final(&self, value: bool) {}
            fn __nd_is_dynamic(&self) -> bool {
                false
            }
            fn __nd_set_is_dynamic(&self, value: bool) {}
            fn __nd_is_options_class(&self) -> bool {
                false
            }
            fn __nd_set_is_options_class(&self, value: bool) {}
            fn __nd_is_static(&self) -> bool {
                false
            }
            fn __nd_set_is_static(&self, value: bool) {}
            fn __nd_is_overriding(&self) -> bool {
                false
            }
            fn __nd_set_is_overriding(&self, value: bool) {}
            fn __nd_is_async(&self) -> bool {
                false
            }
            fn __nd_set_is_async(&self, value: bool) {}
            fn __nd_is_generator(&self) -> bool {
                false
            }
            fn __nd_set_is_generator(&self, value: bool) {}
            fn __nd_signature(&self, host: &Database) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_signature(&self, signature: &Entity) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_array_element_type(
                &self,
                host: &Database,
            ) -> Result<Option<Entity>, DeferError> {
                let array_type = host.array_type().defer()?;
                if self == &array_type {
                    Ok(Some(array_type.type_params().unwrap().get(0).unwrap()))
                } else if self.type_after_sub_has_origin(&array_type) {
                    Ok(Some(self.substitute_types().get(0).unwrap()))
                } else {
                    Ok(None)
                }
            }
            fn __nd_vector_element_type(
                &self,
                host: &Database,
            ) -> Result<Option<Entity>, DeferError> {
                let vec_type = host.vector_type().defer()?;
                if self == &vec_type {
                    Ok(Some(vec_type.type_params().unwrap().get(0).unwrap()))
                } else if self.type_after_sub_has_origin(&vec_type) {
                    Ok(Some(self.substitute_types().get(0).unwrap()))
                } else {
                    Ok(None)
                }
            }
            fn __nd_promise_result_type(
                &self,
                host: &Database,
            ) -> Result<Option<Entity>, DeferError> {
                let promise_type = host.promise_type().defer()?;
                if self == &promise_type {
                    Ok(Some(promise_type.type_params().unwrap().get(0).unwrap()))
                } else if self.type_after_sub_has_origin(&promise_type) {
                    Ok(Some(self.substitute_types().get(0).unwrap()))
                } else {
                    Ok(None)
                }
            }
            fn __nd_type_after_sub_has_origin(&self, origin: &Entity) -> bool {
                self.is::<TypeAfterSubstitution>() && &self.origin() == origin
            }
            fn __nd_is_type_or_type_after_sub_has_origin(
                &self,
                type_or_origin: &Entity,
            ) -> bool {
                self == type_or_origin || self.type_after_sub_has_origin(type_or_origin)
            }
            fn __nd_origin_or_parameterized_type_identity(&self) -> Option<Entity> {
                if self.is::<TypeAfterSubstitution>() {
                    Some(self.origin())
                } else if self.type_params().is_some() {
                    Some(self.clone())
                } else {
                    None
                }
            }
            fn __nd_descending_class_hierarchy<'a>(
                &self,
                host: &'a Database,
            ) -> DescendingClassHierarchy<'a> {
                DescendingClassHierarchy(Some(self.clone()), host, self.clone())
            }
            fn __nd_descending_scope_hierarchy(&self) -> DescendingScopeHierarchy {
                DescendingScopeHierarchy(Some(self.clone()))
            }
            fn __nd_descending_definition_hierarchy(
                &self,
            ) -> DescendingDefinitionHierarchy {
                DescendingDefinitionHierarchy(Some(self.clone()))
            }
            fn __nd_is_namespace_or_ns_constant(&self) -> bool {
                false
            }
            fn __nd_wrap_property_reference(
                &self,
                host: &Database,
            ) -> Result<Entity, DeferError> {
                if self.is::<Value>() {
                    return Ok(self.clone());
                }
                if self.is::<Type>()
                    && (self.is::<VoidType>() || self.is::<AnyType>()
                        || self.is::<FunctionType>() || self.is::<TupleType>()
                        || self.is::<NullableType>() || self.is::<NonNullableType>()
                        || self.is::<TypeAfterSubstitution>())
                {
                    return host.factory().create_type_constant(self);
                }
                if self.is::<Namespace>() {
                    return host.factory().create_namespace_constant(self);
                }
                if self.is::<InvalidationEntity>() {
                    return Ok(self.clone());
                }
                let parent = self.parent().unwrap();
                if parent.is::<ClassType>() || parent.is::<EnumType>() {
                    return host.factory().create_static_reference_value(&parent, self);
                }
                if parent.is::<Package>() {
                    return host.factory().create_package_reference_value(&parent, self);
                }
                if !parent.is::<Scope>() {
                    ::core::panicking::panic("assertion failed: parent.is::<Scope>()")
                }
                return host.factory().create_scope_reference_value(&parent, self);
            }
            fn __nd_activation(&self) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_activation(&self, activation: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_of_virtual_slot(&self, host: &Database) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_of_virtual_slot(&self, virtual_slot: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_overriden_by(&self, host: &Database) -> SharedArray<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_overrides_method(&self, host: &Database) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_overrides_method(&self, method: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_is_constructor(&self) -> bool {
                false
            }
            fn __nd_set_is_constructor(&self, value: bool) {}
            fn __nd_constructor_method(&self, host: &Database) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_constructor_method(&self, m: Option<Entity>) {}
            fn __nd_known_subclasses(&self) -> SharedArray<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_implements(&self, host: &Database) -> SharedArray<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_extends_class(&self, host: &Database) -> Option<Entity> {
                None
            }
            fn __nd_set_extends_class(&self, entity: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_prototype(&self, host: &Database) -> Names {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_properties(&self, host: &Database) -> Names {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_subpackages(&self) -> SharedMap<String, Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_alias_of(&self) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_alias_of(&self, value: &Entity) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_resolve_alias(&self) -> Entity {
                self.clone()
            }
            fn __nd_property(&self) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_property(&self, value: &Entity) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_name(&self) -> QName {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_fully_qualified_name(&self) -> String {
                self.fully_qualified_name_list()
                    .join(".")
                    .replace("__AS3__.vec.Vector", "Vector")
            }
            fn __nd_fully_qualified_name_list(&self) -> Vec<String> {
                let mut r: Vec<String> = ::alloc::vec::Vec::new();
                let mut p = Some(self.clone());
                while let Some(p1) = p {
                    let name = if p1.is::<Package>() {
                        p1.local_name()
                    } else {
                        p1.name().to_string()
                    };
                    if !name.is_empty() {
                        r.insert(0, name);
                    }
                    p = p1.parent();
                }
                r
            }
            fn __nd_type_params(&self) -> Option<SharedArray<Entity>> {
                None
            }
            fn __nd_set_type_params(&self, list: Option<SharedArray<Entity>>) {}
            fn __nd_enum_member_number_mapping(&self) -> SharedMap<String, Number> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_enum_member_slot_mapping(&self) -> SharedMap<String, Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_known_implementors(&self) -> SharedArray<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_extends_interfaces(&self, host: &Database) -> SharedArray<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_origin(&self) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_substitute_types(&self) -> SharedArray<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_indirect_type_params(&self) -> SharedArray<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_indirect_substitute_types(&self) -> SharedArray<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_element_types(&self) -> SharedArray<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_params(&self) -> SharedArray<Rc<SemanticFunctionTypeParameter>> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_result_type(&self) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_base(&self) -> Entity {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_apply_type(
                &self,
                host: &Database,
                type_params: &SharedArray<Entity>,
                substitute_types: &SharedArray<Entity>,
            ) -> Entity {
                ApplyType(host).exec(self, type_params, substitute_types)
            }
            fn __nd_read_only(&self, host: &Database) -> bool {
                true
            }
            fn __nd_set_read_only(&self, value: bool) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_write_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_set_write_only(&self, value: bool) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_deletable(&self, host: &Database) -> bool {
                false
            }
            fn __nd_var_constant(&self) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_var_constant(&self, k: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_is_ascending_type_of(
                &self,
                possibly_subtype: &Entity,
                host: &Database,
            ) -> Result<bool, DeferError> {
                possibly_subtype.is_subtype_of(self, host)
            }
            fn __nd_is_subtype_of(
                &self,
                possibly_ascending_type: &Entity,
                host: &Database,
            ) -> Result<bool, DeferError> {
                if possibly_ascending_type.is::<AnyType>() {
                    return Ok(true);
                }
                for t in self.all_ascending_types(host) {
                    t.defer()?;
                    if &t == possibly_ascending_type {
                        return Ok(true);
                    }
                }
                Ok(false)
            }
            fn __nd_is_equals_or_subtype_of(
                &self,
                other: &Entity,
                host: &Database,
            ) -> Result<bool, DeferError> {
                Ok(self == other || self.is_subtype_of(other, host)?)
            }
            fn __nd_all_ascending_types(&self, host: &Database) -> Vec<Entity> {
                self.all_ascending_types_non_circular(host, self)
            }
            fn __nd_all_ascending_types_non_circular(
                &self,
                host: &Database,
                descending_most: &Entity,
            ) -> Vec<Entity> {
                let mut r = ::alloc::vec::Vec::new();
                let mut r2 = ::alloc::vec::Vec::new();
                for type_thing in self.direct_ascending_types(host) {
                    if !type_thing.is::<UnresolvedEntity>() {
                        if &type_thing != descending_most {
                            for type1 in type_thing.all_ascending_types(host) {
                                if !r.contains(&type1) && &type1 != descending_most {
                                    r.push(type1.clone());
                                }
                            }
                        }
                    }
                    if !r.contains(&type_thing) && &type_thing != descending_most {
                        r2.push(type_thing.clone());
                    }
                }
                r.extend(r2);
                r
            }
            fn __nd_direct_ascending_types(&self, host: &Database) -> Vec<Entity> {
                if self.is::<ClassType>() {
                    let mut r: Vec<Entity> = self.implements(host).iter().collect();
                    if let Some(ascending_class) = self.extends_class(host) {
                        r.push(ascending_class);
                    }
                    return r;
                } else if self.is::<EnumType>() {
                    return <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([self.extends_class(host).unwrap()]),
                    );
                } else if self.is::<InterfaceType>() {
                    return self.extends_interfaces(host).iter().collect();
                } else if self.is::<FunctionType>() {
                    return <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([host.function_type()]),
                    );
                } else if self.is::<TupleType>() {
                    return <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            host.array_type_of_any().unwrap_or(host.unresolved_entity()),
                        ]),
                    );
                } else if self.is::<InvalidationEntity>() {
                    return ::alloc::vec::Vec::new();
                }
                return ::alloc::vec::Vec::new();
            }
            fn __nd_not_overriden_abstract_getter(
                &self,
                getter_from_base_class: &Entity,
                subclass: &Entity,
                host: &Database,
            ) -> bool {
                if getter_from_base_class.is_abstract() {
                    let name = &getter_from_base_class.name();
                    let prop2 = if name.namespace().is::<SystemNamespace>() {
                        subclass
                            .prototype(host)
                            .get_in_system_ns_kind(
                                name.namespace().system_ns_kind().unwrap(),
                                &name.local_name(),
                            )
                            .ok()
                            .unwrap_or(None)
                    } else {
                        subclass.prototype(host).get(name)
                    };
                    prop2.is_none() || !prop2.clone().unwrap().is::<VirtualSlot>()
                        || prop2.unwrap().getter(host).is_none()
                } else {
                    false
                }
            }
            fn __nd_not_overriden_abstract_setter(
                &self,
                setter_from_base_class: &Entity,
                subclass: &Entity,
                host: &Database,
            ) -> bool {
                if setter_from_base_class.is_abstract() {
                    let name = &setter_from_base_class.name();
                    let prop2 = if name.namespace().is::<SystemNamespace>() {
                        subclass
                            .prototype(host)
                            .get_in_system_ns_kind(
                                name.namespace().system_ns_kind().unwrap(),
                                &name.local_name(),
                            )
                            .ok()
                            .unwrap_or(None)
                    } else {
                        subclass.prototype(host).get(name)
                    };
                    prop2.is_none() || !prop2.clone().unwrap().is::<VirtualSlot>()
                        || prop2.unwrap().setter(host).is_none()
                } else {
                    false
                }
            }
            fn __nd_is_comparison_between_unrelated_types(
                &self,
                other: &Entity,
                host: &Database,
            ) -> Result<bool, DeferError> {
                let left = self.escape_of_nullable_or_non_nullable();
                let right = other.escape_of_nullable_or_non_nullable();
                if left == right
                    || [left.clone(), right.clone()].contains(&host.any_type())
                {
                    return Ok(false);
                }
                let primitive_types = host.primitive_types()?;
                if primitive_types.contains(&left) || primitive_types.contains(&right) {
                    return Ok(false);
                }
                if !(left.is_ascending_type_of(&right, host)?
                    || left.is_subtype_of(&right, host)?)
                {
                    return Ok(true);
                }
                Ok(false)
            }
            fn __nd_expect_type(&self) -> Result<Entity, TypeExpectError> {
                if let Some(t) = self.as_type() { Ok(t) } else { Err(TypeExpectError()) }
            }
            fn __nd_as_type(&self) -> Option<Entity> {
                if self.is::<TypeConstant>() {
                    return Some(self.referenced_type());
                }
                if self.is::<FixtureReferenceValue>() {
                    return self.property().as_type();
                }
                if self.is::<Type>() { Some(self.clone()) } else { None }
            }
            fn __nd_fixture_reference_value_equals(&self, other: &Entity) -> bool {
                if other.is::<FixtureReferenceValue>() {
                    if self.is::<FixtureReferenceValue>() {
                        self.property() == other.property()
                    } else {
                        self == &other.property()
                    }
                } else if self.is::<FixtureReferenceValue>() {
                    &self.property() == other
                } else {
                    self == other
                }
            }
            fn __nd_control_flow_graph(&self) -> ControlFlowGraph {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_lookup_in_object(
                &self,
                host: &Database,
                open_ns_set: &SharedArray<Entity>,
                qual: Option<Entity>,
                key: &PropertyLookupKey,
                calling: bool,
            ) -> Result<Option<Entity>, PropertyLookupError> {
                PropertyLookup(host)
                    .lookup_in_object(self, open_ns_set, qual, key, calling)
            }
            fn __nd_lookup_in_scope_chain(
                &self,
                host: &Database,
                qual: Option<Entity>,
                key: &PropertyLookupKey,
            ) -> Result<Option<Entity>, PropertyLookupError> {
                PropertyLookup(host).lookup_in_scope_chain(self, qual, key)
            }
            fn __nd_search_system_ns_in_scope_chain(
                &self,
                ns: SystemNamespaceKind,
            ) -> Option<Entity> {
                let mut scope = Some(self.clone());
                while let Some(scope1) = scope {
                    if scope1.is::<PackageScope>() || scope1.is::<Activation>() {
                        if ns == SystemNamespaceKind::Public {
                            return scope1.public_ns();
                        }
                        if ns == SystemNamespaceKind::Internal {
                            return scope1.internal_ns();
                        }
                    } else if scope1.is::<ClassScope>() {
                        if ns == SystemNamespaceKind::Private {
                            return scope1.private_ns();
                        }
                        if ns == SystemNamespaceKind::Protected {
                            return scope1.protected_ns();
                        }
                        if ns == SystemNamespaceKind::StaticProtected {
                            return scope1.static_protected_ns();
                        }
                    } else if scope1.is::<EnumScope>() {
                        if ns == SystemNamespaceKind::Private {
                            return scope1.private_ns();
                        }
                    }
                    scope = scope1.parent();
                }
                None
            }
            fn __nd_field_reference(&self) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_field_reference(&self, value: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_var_slot(&self) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_var_slot(&self, value: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_target_reference(&self) -> Option<Entity> {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_set_target_reference(&self, value: Option<Entity>) {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                };
            }
            fn __nd_search_hoist_scope(&self) -> Entity {
                let mut scope = Some(self.clone());
                while let Some(scope1) = scope {
                    if scope1.is::<FixtureScope>() || scope1.is::<Activation>() {
                        return scope1;
                    }
                    scope = scope1.parent();
                }
                scope.unwrap()
            }
            fn __nd_is_empty_package(&self, host: &Database) -> bool {
                if self.properties(host).length() != 0 {
                    return false;
                }
                for pckg in self.package_concats().iter() {
                    if !pckg.is_empty_package(host) {
                        return false;
                    }
                }
                true
            }
            fn __nd_is_empty_package_recursive(&self, host: &Database) -> bool {
                if !self.is_empty_package(host) {
                    return false;
                }
                for (_, pckg) in self.subpackages().borrow().iter() {
                    if !pckg.is_empty_package_recursive(host) {
                        return false;
                    }
                }
                true
            }
            fn __nd_list_packages_recursively(&self) -> Vec<Entity> {
                let mut r: Vec<Entity> = <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([self.clone()]),
                );
                for (_, pckg) in self.subpackages().borrow().iter() {
                    r.extend(pckg.list_packages_recursively());
                }
                r
            }
            fn __nd_to_string_1(&self) -> String {
                "".into()
            }
            pub fn defer(&self) -> Result<Entity, DeferError> {
                self.__nd_defer()
            }
            pub fn location(&self) -> Option<Location> {
                if self.is::<Type>() {
                    if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone())).location();
                    } else if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).location();
                    } else if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone())).location();
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).location();
                    } else if self.is::<TypeParameterType>() {
                        return TypeParameterType(Type(self.clone())).location();
                    }
                } else if self.is::<VariableSlot>() {
                    if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone()))
                            .location();
                    } else if self.is::<VariableSlotAfterSubstitution>() {
                        return VariableSlotAfterSubstitution(VariableSlot(self.clone()))
                            .location();
                    }
                } else if self.is::<Alias>() {
                    return Alias(self.clone()).location();
                } else if self.is::<VirtualSlot>() {
                    if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone())).location();
                    } else if self.is::<VirtualSlotAfterSubstitution>() {
                        return VirtualSlotAfterSubstitution(VirtualSlot(self.clone()))
                            .location();
                    }
                } else if self.is::<MethodSlot>() {
                    if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .location();
                    } else if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone())).location();
                    }
                } else if self.is::<Value>() {
                    if self.is::<PackagePropertyImport>() {
                        return PackagePropertyImport(Value(self.clone())).location();
                    } else if self.is::<PackageWildcardImport>() {
                        return PackageWildcardImport(Value(self.clone())).location();
                    } else if self.is::<PackageRecursiveImport>() {
                        return PackageRecursiveImport(Value(self.clone())).location();
                    }
                }
                self.__nd_location()
            }
            pub fn set_location(&self, loc: Option<Location>) {
                if self.is::<VariableSlot>() {
                    if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone()))
                            .set_location(loc);
                    }
                } else if self.is::<Value>() {
                    if self.is::<PackagePropertyImport>() {
                        return PackagePropertyImport(Value(self.clone()))
                            .set_location(loc);
                    } else if self.is::<PackageWildcardImport>() {
                        return PackageWildcardImport(Value(self.clone()))
                            .set_location(loc);
                    } else if self.is::<PackageRecursiveImport>() {
                        return PackageRecursiveImport(Value(self.clone()))
                            .set_location(loc);
                    }
                } else if self.is::<Alias>() {
                    return Alias(self.clone()).set_location(loc);
                } else if self.is::<VirtualSlot>() {
                    if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone()))
                            .set_location(loc);
                    }
                } else if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .set_location(loc);
                    }
                } else if self.is::<Type>() {
                    if self.is::<TypeParameterType>() {
                        return TypeParameterType(Type(self.clone())).set_location(loc);
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).set_location(loc);
                    } else if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).set_location(loc);
                    } else if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone())).set_location(loc);
                    }
                }
                self.__nd_set_location(loc)
            }
            pub fn qualifier(&self) -> Option<Entity> {
                if self.is::<Value>() {
                    if self.is::<ReferenceValue>() {
                        if self.is::<XmlReferenceValue>() {
                            return XmlReferenceValue(ReferenceValue(Value(self.clone())))
                                .qualifier();
                        } else if self.is::<DynamicReferenceValue>() {
                            return DynamicReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .qualifier();
                        } else if self.is::<DynamicScopeReferenceValue>() {
                            return DynamicScopeReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .qualifier();
                        } else if self.is::<StaticDynamicReferenceValue>() {
                            return StaticDynamicReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .qualifier();
                        }
                    }
                }
                self.__nd_qualifier()
            }
            pub fn key(&self) -> Entity {
                if self.is::<Value>() {
                    if self.is::<ReferenceValue>() {
                        if self.is::<VectorElementReferenceValue>() {
                            return VectorElementReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .key();
                        } else if self.is::<XmlReferenceValue>() {
                            return XmlReferenceValue(ReferenceValue(Value(self.clone())))
                                .key();
                        } else if self.is::<ArrayElementReferenceValue>() {
                            return ArrayElementReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .key();
                        } else if self.is::<StaticDynamicReferenceValue>() {
                            return StaticDynamicReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .key();
                        } else if self.is::<DynamicScopeReferenceValue>() {
                            return DynamicScopeReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .key();
                        } else if self.is::<DynamicReferenceValue>() {
                            return DynamicReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .key();
                        }
                    }
                }
                self.__nd_key()
            }
            /// Returns the static type of a property, whether for a type, variable, virtual or method slot or namespace,
            /// or act as identity of a value's static type.
            /// Possibly `UnresolvedEntity`.
            pub fn property_static_type(&self, host: &Database) -> Entity {
                if self.is::<VariableSlot>() {
                    return VariableSlot(self.clone()).property_static_type(host);
                } else if self.is::<VirtualSlot>() {
                    return VirtualSlot(self.clone()).property_static_type(host);
                } else if self.is::<MethodSlot>() {
                    return MethodSlot(self.clone()).property_static_type(host);
                } else if self.is::<Value>() {
                    return Value(self.clone()).property_static_type(host);
                } else if self.is::<Namespace>() {
                    return Namespace(self.clone()).property_static_type(host);
                } else if self.is::<Type>() {
                    return Type(self.clone()).property_static_type(host);
                } else if self.is::<InvalidationEntity>() {
                    return InvalidationEntity(self.clone()).property_static_type(host);
                }
                self.__nd_property_static_type(host)
            }
            pub fn is_dynamic_or_inherits_dynamic(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone()))
                            .is_dynamic_or_inherits_dynamic(host);
                    } else if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone()))
                            .is_dynamic_or_inherits_dynamic(host);
                    } else if self.is::<FunctionType>() {
                        return FunctionType(Type(self.clone()))
                            .is_dynamic_or_inherits_dynamic(host);
                    } else if self.is::<TupleType>() {
                        return TupleType(Type(self.clone()))
                            .is_dynamic_or_inherits_dynamic(host);
                    }
                }
                self.__nd_is_dynamic_or_inherits_dynamic(host)
            }
            pub fn tuple_index(&self) -> usize {
                if self.is::<Value>() {
                    if self.is::<ReferenceValue>() {
                        if self.is::<TupleReferenceValue>() {
                            return TupleReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .tuple_index();
                        }
                    }
                }
                self.__nd_tuple_index()
            }
            pub fn system_ns_kind(&self) -> Option<SystemNamespaceKind> {
                if self.is::<Namespace>() {
                    if self.is::<SystemNamespace>() {
                        return SystemNamespace(Namespace(self.clone())).system_ns_kind();
                    }
                }
                self.__nd_system_ns_kind()
            }
            pub fn asdoc(&self) -> Option<Rc<Asdoc>> {
                if self.is::<VariableSlot>() {
                    if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone())).asdoc();
                    } else if self.is::<VariableSlotAfterSubstitution>() {
                        return VariableSlotAfterSubstitution(VariableSlot(self.clone()))
                            .asdoc();
                    }
                } else if self.is::<Type>() {
                    if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone())).asdoc();
                    } else if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).asdoc();
                    } else if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone())).asdoc();
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).asdoc();
                    }
                } else if self.is::<VirtualSlot>() {
                    if self.is::<VirtualSlotAfterSubstitution>() {
                        return VirtualSlotAfterSubstitution(VirtualSlot(self.clone()))
                            .asdoc();
                    } else if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone())).asdoc();
                    }
                } else if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone())).asdoc();
                    } else if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .asdoc();
                    }
                } else if self.is::<Package>() {
                    return Package(self.clone()).asdoc();
                }
                self.__nd_asdoc()
            }
            pub fn set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).set_asdoc(asdoc);
                    } else if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).set_asdoc(asdoc);
                    } else if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone())).set_asdoc(asdoc);
                    }
                } else if self.is::<Package>() {
                    return Package(self.clone()).set_asdoc(asdoc);
                } else if self.is::<VariableSlot>() {
                    if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone()))
                            .set_asdoc(asdoc);
                    }
                } else if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .set_asdoc(asdoc);
                    }
                } else if self.is::<VirtualSlot>() {
                    if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone()))
                            .set_asdoc(asdoc);
                    }
                }
                self.__nd_set_asdoc(asdoc)
            }
            pub fn metadata(&self) -> SharedArray<Rc<Metadata>> {
                if self.is::<VariableSlot>() {
                    if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone()))
                            .metadata();
                    } else if self.is::<VariableSlotAfterSubstitution>() {
                        return VariableSlotAfterSubstitution(VariableSlot(self.clone()))
                            .metadata();
                    }
                } else if self.is::<MethodSlot>() {
                    if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .metadata();
                    } else if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone())).metadata();
                    }
                } else if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).metadata();
                    } else if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone())).metadata();
                    } else if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).metadata();
                    } else if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone())).metadata();
                    }
                }
                self.__nd_metadata()
            }
            /// Indicates whether a variable slot is optional for an object initializer
            /// applied to an `[Options]` class.
            pub fn is_opt_variable_for_options_class(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_is_opt_variable_for_options_class(host)
            }
            /// Escapes out of a nullable type layer.
            pub fn escape_of_nullable(&self) -> Entity {
                if self.is::<Type>() {
                    if self.is::<NullableType>() {
                        return NullableType(Type(self.clone())).escape_of_nullable();
                    }
                }
                self.__nd_escape_of_nullable()
            }
            /// Escapes out of a non nullable type layer.
            pub fn escape_of_non_nullable(&self) -> Entity {
                if self.is::<Type>() {
                    if self.is::<NonNullableType>() {
                        return NonNullableType(Type(self.clone()))
                            .escape_of_non_nullable();
                    }
                }
                self.__nd_escape_of_non_nullable()
            }
            /// Escapes out of a nullable or non nullable type layer.
            pub fn escape_of_nullable_or_non_nullable(&self) -> Entity {
                if self.is::<Type>() {
                    if self.is::<NullableType>() {
                        return NullableType(Type(self.clone()))
                            .escape_of_nullable_or_non_nullable();
                    } else if self.is::<NonNullableType>() {
                        return NonNullableType(Type(self.clone()))
                            .escape_of_nullable_or_non_nullable();
                    }
                }
                self.__nd_escape_of_nullable_or_non_nullable()
            }
            pub fn object(&self) -> Entity {
                if self.is::<Scope>() {
                    if self.is::<WithScope>() {
                        return WithScope(Scope(self.clone())).object();
                    }
                }
                self.__nd_object()
            }
            pub fn uri(&self) -> String {
                if self.is::<Namespace>() {
                    if self.is::<UserNamespace>() {
                        return UserNamespace(Namespace(self.clone())).uri();
                    } else if self.is::<ExplicitNamespace>() {
                        return ExplicitNamespace(Namespace(self.clone())).uri();
                    }
                }
                self.__nd_uri()
            }
            pub fn open_ns_set(&self) -> SharedArray<Entity> {
                if self.is::<Scope>() {
                    return Scope(self.clone()).open_ns_set();
                }
                self.__nd_open_ns_set()
            }
            pub fn import_list(&self) -> SharedArray<Entity> {
                if self.is::<Scope>() {
                    return Scope(self.clone()).import_list();
                }
                self.__nd_import_list()
            }
            pub fn is_class_or_equivalent(&self) -> bool {
                self.__nd_is_class_or_equivalent()
            }
            pub fn local_name(&self) -> String {
                if self.is::<Package>() {
                    return Package(self.clone()).local_name();
                }
                self.__nd_local_name()
            }
            pub fn class(&self) -> Entity {
                if self.is::<Scope>() {
                    if self.is::<FixtureScope>() {
                        if self.is::<EnumScope>() {
                            return EnumScope(FixtureScope(Scope(self.clone()))).class();
                        } else if self.is::<ClassScope>() {
                            return ClassScope(FixtureScope(Scope(self.clone()))).class();
                        }
                    }
                }
                self.__nd_class()
            }
            pub fn interface(&self) -> Entity {
                if self.is::<Scope>() {
                    if self.is::<FixtureScope>() {
                        if self.is::<InterfaceScope>() {
                            return InterfaceScope(FixtureScope(Scope(self.clone())))
                                .interface();
                        }
                    }
                }
                self.__nd_interface()
            }
            pub fn package(&self) -> Entity {
                if self.is::<Scope>() {
                    if self.is::<FixtureScope>() {
                        if self.is::<PackageScope>() {
                            return PackageScope(FixtureScope(Scope(self.clone())))
                                .package();
                        }
                    }
                } else if self.is::<Value>() {
                    if self.is::<PackageRecursiveImport>() {
                        return PackageRecursiveImport(Value(self.clone())).package();
                    } else if self.is::<PackageWildcardImport>() {
                        return PackageWildcardImport(Value(self.clone())).package();
                    }
                }
                self.__nd_package()
            }
            pub fn of_method(&self) -> Entity {
                if self.is::<Scope>() {
                    if self.is::<Activation>() {
                        return Activation(Scope(self.clone())).of_method();
                    }
                }
                self.__nd_of_method()
            }
            pub fn search_activation(&self) -> Option<Entity> {
                self.__nd_search_activation()
            }
            pub fn this(&self) -> Option<Entity> {
                if self.is::<Scope>() {
                    if self.is::<Activation>() {
                        return Activation(Scope(self.clone())).this();
                    }
                }
                self.__nd_this()
            }
            pub fn set_this(&self, this: Option<Entity>) {
                if self.is::<Scope>() {
                    if self.is::<Activation>() {
                        return Activation(Scope(self.clone())).set_this(this);
                    }
                }
                self.__nd_set_this(this)
            }
            pub fn property_has_capture(&self, property: &Entity) -> bool {
                if self.is::<Scope>() {
                    if self.is::<Activation>() {
                        return Activation(Scope(self.clone()))
                            .property_has_capture(property);
                    }
                }
                self.__nd_property_has_capture(property)
            }
            pub fn set_property_has_capture(&self, property: &Entity, value: bool) {
                if self.is::<Scope>() {
                    if self.is::<Activation>() {
                        return Activation(Scope(self.clone()))
                            .set_property_has_capture(property, value);
                    }
                }
                self.__nd_set_property_has_capture(property, value)
            }
            pub fn concat_open_ns_set_of_scope_chain(&self) -> SharedArray<Entity> {
                self.__nd_concat_open_ns_set_of_scope_chain()
            }
            pub fn referenced_type(&self) -> Entity {
                if self.is::<Value>() {
                    if self.is::<Constant>() {
                        if self.is::<TypeConstant>() {
                            return TypeConstant(Constant(Value(self.clone())))
                                .referenced_type();
                        }
                    }
                }
                self.__nd_referenced_type()
            }
            pub fn referenced_ns(&self) -> Entity {
                if self.is::<Value>() {
                    if self.is::<Constant>() {
                        if self.is::<NamespaceConstant>() {
                            return NamespaceConstant(Constant(Value(self.clone())))
                                .referenced_ns();
                        }
                    }
                }
                self.__nd_referenced_ns()
            }
            pub fn shorthand_resolution(&self) -> Option<Entity> {
                if self.is::<FieldResolution>() {
                    return FieldResolution(self.clone()).shorthand_resolution();
                }
                self.__nd_shorthand_resolution()
            }
            pub fn set_shorthand_resolution(&self, value: Option<Entity>) {
                if self.is::<FieldResolution>() {
                    return FieldResolution(self.clone()).set_shorthand_resolution(value);
                }
                self.__nd_set_shorthand_resolution(value)
            }
            pub fn field_slot(&self) -> Option<Entity> {
                if self.is::<FieldResolution>() {
                    return FieldResolution(self.clone()).field_slot();
                }
                self.__nd_field_slot()
            }
            pub fn set_field_slot(&self, value: Option<Entity>) {
                if self.is::<FieldResolution>() {
                    return FieldResolution(self.clone()).set_field_slot(value);
                }
                self.__nd_set_field_slot(value)
            }
            pub fn is_entity_after_substitution(&self) -> bool {
                self.__nd_is_entity_after_substitution()
            }
            pub fn parent(&self) -> Option<Entity> {
                if self.is::<Alias>() {
                    return Alias(self.clone()).parent();
                } else if self.is::<VirtualSlot>() {
                    if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone())).parent();
                    } else if self.is::<VirtualSlotAfterSubstitution>() {
                        return VirtualSlotAfterSubstitution(VirtualSlot(self.clone()))
                            .parent();
                    }
                } else if self.is::<Namespace>() {
                    if self.is::<SystemNamespace>() {
                        return SystemNamespace(Namespace(self.clone())).parent();
                    }
                } else if self.is::<Package>() {
                    return Package(self.clone()).parent();
                } else if self.is::<Scope>() {
                    return Scope(self.clone()).parent();
                } else if self.is::<VariableSlot>() {
                    if self.is::<VariableSlotAfterSubstitution>() {
                        return VariableSlotAfterSubstitution(VariableSlot(self.clone()))
                            .parent();
                    } else if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone())).parent();
                    }
                } else if self.is::<Type>() {
                    if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone())).parent();
                    } else if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone())).parent();
                    } else if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).parent();
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).parent();
                    }
                } else if self.is::<MethodSlot>() {
                    if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .parent();
                    } else if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone())).parent();
                    }
                }
                self.__nd_parent()
            }
            pub fn set_parent(&self, p: Option<Entity>) {
                if self.is::<Type>() {
                    if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone())).set_parent(p);
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).set_parent(p);
                    } else if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).set_parent(p);
                    }
                } else if self.is::<Alias>() {
                    return Alias(self.clone()).set_parent(p);
                } else if self.is::<VirtualSlot>() {
                    if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone()))
                            .set_parent(p);
                    }
                } else if self.is::<Scope>() {
                    return Scope(self.clone()).set_parent(p);
                } else if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .set_parent(p);
                    }
                } else if self.is::<Package>() {
                    return Package(self.clone()).set_parent(p);
                } else if self.is::<VariableSlot>() {
                    if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone()))
                            .set_parent(p);
                    }
                }
                self.__nd_set_parent(p)
            }
            pub fn package_concats(&self) -> SharedArray<Entity> {
                if self.is::<Package>() {
                    return Package(self.clone()).package_concats();
                }
                self.__nd_package_concats()
            }
            pub fn public_ns(&self) -> Option<Entity> {
                if self.is::<Scope>() {
                    if self.is::<Activation>() {
                        return Activation(Scope(self.clone())).public_ns();
                    }
                } else if self.is::<Package>() {
                    return Package(self.clone()).public_ns();
                }
                self.__nd_public_ns()
            }
            pub fn set_public_ns(&self, ns: Option<Entity>) {
                if self.is::<Scope>() {
                    if self.is::<Activation>() {
                        return Activation(Scope(self.clone())).set_public_ns(ns);
                    }
                } else if self.is::<Package>() {
                    return Package(self.clone()).set_public_ns(ns);
                }
                self.__nd_set_public_ns(ns)
            }
            pub fn private_ns(&self) -> Option<Entity> {
                if self.is::<Type>() {
                    if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).private_ns();
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).private_ns();
                    }
                }
                self.__nd_private_ns()
            }
            pub fn set_private_ns(&self, ns: Option<Entity>) {
                if self.is::<Type>() {
                    if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).set_private_ns(ns);
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).set_private_ns(ns);
                    }
                }
                self.__nd_set_private_ns(ns)
            }
            pub fn protected_ns(&self) -> Option<Entity> {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).protected_ns();
                    }
                }
                self.__nd_protected_ns()
            }
            pub fn set_protected_ns(&self, ns: Option<Entity>) {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).set_protected_ns(ns);
                    }
                }
                self.__nd_set_protected_ns(ns)
            }
            pub fn static_protected_ns(&self) -> Option<Entity> {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).static_protected_ns();
                    }
                }
                self.__nd_static_protected_ns()
            }
            pub fn set_static_protected_ns(&self, ns: Option<Entity>) {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).set_static_protected_ns(ns);
                    }
                }
                self.__nd_set_static_protected_ns(ns)
            }
            pub fn internal_ns(&self) -> Option<Entity> {
                if self.is::<Scope>() {
                    if self.is::<Activation>() {
                        return Activation(Scope(self.clone())).internal_ns();
                    }
                } else if self.is::<Package>() {
                    return Package(self.clone()).internal_ns();
                }
                self.__nd_internal_ns()
            }
            pub fn set_internal_ns(&self, ns: Option<Entity>) {
                if self.is::<Package>() {
                    return Package(self.clone()).set_internal_ns(ns);
                } else if self.is::<Scope>() {
                    if self.is::<Activation>() {
                        return Activation(Scope(self.clone())).set_internal_ns(ns);
                    }
                }
                self.__nd_set_internal_ns(ns)
            }
            pub fn is_public_ns(&self) -> bool {
                if self.is::<Namespace>() {
                    if self.is::<SystemNamespace>() {
                        return SystemNamespace(Namespace(self.clone())).is_public_ns();
                    }
                }
                self.__nd_is_public_ns()
            }
            pub fn is_private_ns(&self) -> bool {
                if self.is::<Namespace>() {
                    if self.is::<SystemNamespace>() {
                        return SystemNamespace(Namespace(self.clone())).is_private_ns();
                    }
                }
                self.__nd_is_private_ns()
            }
            pub fn is_protected_ns(&self) -> bool {
                if self.is::<Namespace>() {
                    if self.is::<SystemNamespace>() {
                        return SystemNamespace(Namespace(self.clone()))
                            .is_protected_ns();
                    }
                }
                self.__nd_is_protected_ns()
            }
            pub fn is_internal_ns(&self) -> bool {
                if self.is::<Namespace>() {
                    if self.is::<SystemNamespace>() {
                        return SystemNamespace(Namespace(self.clone())).is_internal_ns();
                    }
                }
                self.__nd_is_internal_ns()
            }
            pub fn is_static_protected_ns(&self) -> bool {
                if self.is::<Namespace>() {
                    if self.is::<SystemNamespace>() {
                        return SystemNamespace(Namespace(self.clone()))
                            .is_static_protected_ns();
                    }
                }
                self.__nd_is_static_protected_ns()
            }
            pub fn is_parameterized_type_or_type_after_sub(&self) -> bool {
                self.__nd_is_parameterized_type_or_type_after_sub()
            }
            pub fn is_package_self_referential(&self, pckg: &Entity) -> bool {
                self.__nd_is_package_self_referential(pckg)
            }
            pub fn is_global_initialization(&self) -> bool {
                if self.is::<Scope>() {
                    if self.is::<Activation>() {
                        return Activation(Scope(self.clone()))
                            .is_global_initialization();
                    }
                }
                self.__nd_is_global_initialization()
            }
            pub fn set_is_global_initialization(&self, value: bool) {
                if self.is::<Scope>() {
                    if self.is::<Activation>() {
                        return Activation(Scope(self.clone()))
                            .set_is_global_initialization(value);
                    }
                }
                self.__nd_set_is_global_initialization(value)
            }
            pub fn is_package_initialization(&self) -> bool {
                if self.is::<Scope>() {
                    if self.is::<Activation>() {
                        return Activation(Scope(self.clone()))
                            .is_package_initialization();
                    }
                }
                self.__nd_is_package_initialization()
            }
            pub fn set_is_package_initialization(&self, value: bool) {
                if self.is::<Scope>() {
                    if self.is::<Activation>() {
                        return Activation(Scope(self.clone()))
                            .set_is_package_initialization(value);
                    }
                }
                self.__nd_set_is_package_initialization(value)
            }
            pub fn number_value(&self) -> Number {
                if self.is::<Value>() {
                    if self.is::<Constant>() {
                        if self.is::<NumberConstant>() {
                            return NumberConstant(Constant(Value(self.clone())))
                                .number_value();
                        }
                    }
                }
                self.__nd_number_value()
            }
            pub fn string_value(&self) -> String {
                if self.is::<Value>() {
                    if self.is::<Constant>() {
                        if self.is::<StringConstant>() {
                            return StringConstant(Constant(Value(self.clone())))
                                .string_value();
                        }
                    }
                }
                self.__nd_string_value()
            }
            pub fn boolean_value(&self) -> bool {
                if self.is::<Value>() {
                    if self.is::<Constant>() {
                        if self.is::<BooleanConstant>() {
                            return BooleanConstant(Constant(Value(self.clone())))
                                .boolean_value();
                        }
                    }
                }
                self.__nd_boolean_value()
            }
            pub fn type_default_value(
                &self,
                host: &Database,
            ) -> Result<Option<Entity>, DeferError> {
                if self.is::<Type>() {
                    return Type(self.clone()).type_default_value(host);
                }
                self.__nd_type_default_value(host)
            }
            pub fn conversion_kind(&self) -> ConversionKind {
                if self.is::<Value>() {
                    if self.is::<ConversionValue>() {
                        return ConversionValue(Value(self.clone())).conversion_kind();
                    }
                }
                self.__nd_conversion_kind()
            }
            pub fn conversion_is_opt(&self) -> bool {
                if self.is::<Value>() {
                    if self.is::<ConversionValue>() {
                        return ConversionValue(Value(self.clone())).conversion_is_opt();
                    }
                }
                self.__nd_conversion_is_opt()
            }
            pub fn conversion_target(&self) -> Entity {
                if self.is::<Value>() {
                    if self.is::<ConversionValue>() {
                        return ConversionValue(Value(self.clone())).conversion_target();
                    }
                }
                self.__nd_conversion_target()
            }
            /// Returns whether a type is a class, whether
            /// original or after substitution.
            pub fn is_class_type_possibly_after_sub(&self) -> bool {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone()))
                            .is_class_type_possibly_after_sub();
                    } else if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone()))
                            .is_class_type_possibly_after_sub();
                    }
                }
                self.__nd_is_class_type_possibly_after_sub()
            }
            /// Returns whether a type is an interface, whether
            /// original or after substitution.
            pub fn is_interface_type_possibly_after_sub(&self) -> bool {
                if self.is::<Type>() {
                    if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone()))
                            .is_interface_type_possibly_after_sub();
                    } else if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone()))
                            .is_interface_type_possibly_after_sub();
                    }
                }
                self.__nd_is_interface_type_possibly_after_sub()
            }
            /// Event mapping from `[Event(name="eventName", type="T")]` meta-data.
            pub fn events(&self) -> SharedMap<String, Event> {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).events();
                    } else if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone())).events();
                    } else if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone())).events();
                    }
                }
                self.__nd_events()
            }
            pub fn bindable_event(&self) -> Option<String> {
                if self.is::<VariableSlot>() {
                    if self.is::<VariableSlotAfterSubstitution>() {
                        return VariableSlotAfterSubstitution(VariableSlot(self.clone()))
                            .bindable_event();
                    } else if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone()))
                            .bindable_event();
                    }
                } else if self.is::<VirtualSlot>() {
                    if self.is::<VirtualSlotAfterSubstitution>() {
                        return VirtualSlotAfterSubstitution(VirtualSlot(self.clone()))
                            .bindable_event();
                    } else if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone()))
                            .bindable_event();
                    }
                }
                self.__nd_bindable_event()
            }
            pub fn set_bindable_event(&self, name: Option<String>) {
                if self.is::<VirtualSlot>() {
                    if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone()))
                            .set_bindable_event(name);
                    }
                } else if self.is::<VariableSlot>() {
                    if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone()))
                            .set_bindable_event(name);
                    }
                }
                self.__nd_set_bindable_event(name)
            }
            pub fn scope(&self) -> Entity {
                if self.is::<Value>() {
                    if self.is::<FilterValue>() {
                        return FilterValue(Value(self.clone())).scope();
                    }
                }
                self.__nd_scope()
            }
            pub fn getter(&self, host: &Database) -> Option<Entity> {
                if self.is::<VirtualSlot>() {
                    if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone()))
                            .getter(host);
                    } else if self.is::<VirtualSlotAfterSubstitution>() {
                        return VirtualSlotAfterSubstitution(VirtualSlot(self.clone()))
                            .getter(host);
                    }
                }
                self.__nd_getter(host)
            }
            pub fn set_getter(&self, m: Option<Entity>) {
                if self.is::<VirtualSlot>() {
                    if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone()))
                            .set_getter(m);
                    }
                }
                self.__nd_set_getter(m)
            }
            pub fn setter(&self, host: &Database) -> Option<Entity> {
                if self.is::<VirtualSlot>() {
                    if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone()))
                            .setter(host);
                    } else if self.is::<VirtualSlotAfterSubstitution>() {
                        return VirtualSlotAfterSubstitution(VirtualSlot(self.clone()))
                            .setter(host);
                    }
                }
                self.__nd_setter(host)
            }
            pub fn set_setter(&self, m: Option<Entity>) {
                if self.is::<VirtualSlot>() {
                    if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone()))
                            .set_setter(m);
                    }
                }
                self.__nd_set_setter(m)
            }
            pub fn static_type(&self, host: &Database) -> Entity {
                if self.is::<VariableSlot>() {
                    if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone()))
                            .static_type(host);
                    } else if self.is::<VariableSlotAfterSubstitution>() {
                        return VariableSlotAfterSubstitution(VariableSlot(self.clone()))
                            .static_type(host);
                    }
                } else if self.is::<InvalidationEntity>() {
                    return InvalidationEntity(self.clone()).static_type(host);
                } else if self.is::<VirtualSlot>() {
                    if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone()))
                            .static_type(host);
                    } else if self.is::<VirtualSlotAfterSubstitution>() {
                        return VirtualSlotAfterSubstitution(VirtualSlot(self.clone()))
                            .static_type(host);
                    }
                } else if self.is::<Value>() {
                    return Value(self.clone()).static_type(host);
                }
                self.__nd_static_type(host)
            }
            pub fn set_static_type(&self, value: Entity) {
                if self.is::<Value>() {
                    return Value(self.clone()).set_static_type(value);
                } else if self.is::<VariableSlot>() {
                    if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone()))
                            .set_static_type(value);
                    }
                }
                self.__nd_set_static_type(value)
            }
            pub fn clone_constant(&self, host: &Database) -> Entity {
                if self.is::<Value>() {
                    if self.is::<Constant>() {
                        if self.is::<StringConstant>() {
                            return StringConstant(Constant(Value(self.clone())))
                                .clone_constant(host);
                        } else if self.is::<BooleanConstant>() {
                            return BooleanConstant(Constant(Value(self.clone())))
                                .clone_constant(host);
                        } else if self.is::<UndefinedConstant>() {
                            return UndefinedConstant(Constant(Value(self.clone())))
                                .clone_constant(host);
                        } else if self.is::<NullConstant>() {
                            return NullConstant(Constant(Value(self.clone())))
                                .clone_constant(host);
                        } else if self.is::<TypeConstant>() {
                            return TypeConstant(Constant(Value(self.clone())))
                                .clone_constant(host);
                        } else if self.is::<NumberConstant>() {
                            return NumberConstant(Constant(Value(self.clone())))
                                .clone_constant(host);
                        } else if self.is::<NamespaceConstant>() {
                            return NamespaceConstant(Constant(Value(self.clone())))
                                .clone_constant(host);
                        }
                    }
                }
                self.__nd_clone_constant(host)
            }
            pub fn is_abstract(&self) -> bool {
                if self.is::<Type>() {
                    if self.is::<FunctionType>() {
                        return FunctionType(Type(self.clone())).is_abstract();
                    } else if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).is_abstract();
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).is_abstract();
                    } else if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone())).is_abstract();
                    } else if self.is::<TupleType>() {
                        return TupleType(Type(self.clone())).is_abstract();
                    }
                } else if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .is_abstract();
                    } else if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .is_abstract();
                    }
                }
                self.__nd_is_abstract()
            }
            pub fn set_is_abstract(&self, value: bool) {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).set_is_abstract(value);
                    }
                } else if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .set_is_abstract(value);
                    }
                }
                self.__nd_set_is_abstract(value)
            }
            pub fn is_final(&self) -> bool {
                if self.is::<Type>() {
                    if self.is::<FunctionType>() {
                        return FunctionType(Type(self.clone())).is_final();
                    } else if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone())).is_final();
                    } else if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).is_final();
                    } else if self.is::<TupleType>() {
                        return TupleType(Type(self.clone())).is_final();
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).is_final();
                    }
                } else if self.is::<MethodSlot>() {
                    if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .is_final();
                    } else if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone())).is_final();
                    }
                }
                self.__nd_is_final()
            }
            pub fn set_is_final(&self, value: bool) {
                if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .set_is_final(value);
                    }
                } else if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).set_is_final(value);
                    }
                }
                self.__nd_set_is_final(value)
            }
            pub fn is_dynamic(&self) -> bool {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).is_dynamic();
                    } else if self.is::<TupleType>() {
                        return TupleType(Type(self.clone())).is_dynamic();
                    } else if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone())).is_dynamic();
                    } else if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).is_dynamic();
                    } else if self.is::<FunctionType>() {
                        return FunctionType(Type(self.clone())).is_dynamic();
                    }
                }
                self.__nd_is_dynamic()
            }
            pub fn set_is_dynamic(&self, value: bool) {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).set_is_dynamic(value);
                    }
                }
                self.__nd_set_is_dynamic(value)
            }
            pub fn is_options_class(&self) -> bool {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).is_options_class();
                    } else if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).is_options_class();
                    } else if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone()))
                            .is_options_class();
                    } else if self.is::<TupleType>() {
                        return TupleType(Type(self.clone())).is_options_class();
                    } else if self.is::<FunctionType>() {
                        return FunctionType(Type(self.clone())).is_options_class();
                    }
                }
                self.__nd_is_options_class()
            }
            pub fn set_is_options_class(&self, value: bool) {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).set_is_options_class(value);
                    }
                }
                self.__nd_set_is_options_class(value)
            }
            pub fn is_static(&self) -> bool {
                if self.is::<Type>() {
                    if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone())).is_static();
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).is_static();
                    }
                } else if self.is::<MethodSlot>() {
                    if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .is_static();
                    } else if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone())).is_static();
                    }
                }
                self.__nd_is_static()
            }
            pub fn set_is_static(&self, value: bool) {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).set_is_static(value);
                    }
                } else if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .set_is_static(value);
                    }
                }
                self.__nd_set_is_static(value)
            }
            pub fn is_overriding(&self) -> bool {
                if self.is::<MethodSlot>() {
                    if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .is_overriding();
                    } else if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .is_overriding();
                    }
                }
                self.__nd_is_overriding()
            }
            pub fn set_is_overriding(&self, value: bool) {
                if self.is::<MethodSlot>() {
                    if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .set_is_overriding(value);
                    } else if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .set_is_overriding(value);
                    }
                }
                self.__nd_set_is_overriding(value)
            }
            pub fn is_async(&self) -> bool {
                if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone())).is_async();
                    } else if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .is_async();
                    }
                }
                self.__nd_is_async()
            }
            pub fn set_is_async(&self, value: bool) {
                if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .set_is_async(value);
                    }
                }
                self.__nd_set_is_async(value)
            }
            pub fn is_generator(&self) -> bool {
                if self.is::<MethodSlot>() {
                    if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .is_generator();
                    } else if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .is_generator();
                    }
                }
                self.__nd_is_generator()
            }
            pub fn set_is_generator(&self, value: bool) {
                if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .set_is_generator(value);
                    }
                }
                self.__nd_set_is_generator(value)
            }
            pub fn signature(&self, host: &Database) -> Entity {
                if self.is::<MethodSlot>() {
                    if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .signature(host);
                    } else if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .signature(host);
                    }
                }
                self.__nd_signature(host)
            }
            pub fn set_signature(&self, signature: &Entity) {
                if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .set_signature(signature);
                    }
                }
                self.__nd_set_signature(signature)
            }
            /// If a type is `[T]`, returns `T`, either as an origin type parameter
            /// or as a substitute type.
            pub fn array_element_type(
                &self,
                host: &Database,
            ) -> Result<Option<Entity>, DeferError> {
                self.__nd_array_element_type(host)
            }
            /// If a type is `Vector.<T>`, returns `T`, either as an origin type parameter
            /// or as a substitute type.
            pub fn vector_element_type(
                &self,
                host: &Database,
            ) -> Result<Option<Entity>, DeferError> {
                self.__nd_vector_element_type(host)
            }
            /// If a type is `Promise.<T>`, returns `T`, either as an origin type parameter
            /// or as a substitute type.
            pub fn promise_result_type(
                &self,
                host: &Database,
            ) -> Result<Option<Entity>, DeferError> {
                self.__nd_promise_result_type(host)
            }
            pub fn type_after_sub_has_origin(&self, origin: &Entity) -> bool {
                self.__nd_type_after_sub_has_origin(origin)
            }
            pub fn is_type_or_type_after_sub_has_origin(
                &self,
                type_or_origin: &Entity,
            ) -> bool {
                self.__nd_is_type_or_type_after_sub_has_origin(type_or_origin)
            }
            pub fn origin_or_parameterized_type_identity(&self) -> Option<Entity> {
                self.__nd_origin_or_parameterized_type_identity()
            }
            /// Iterator over a descending class hierarchy.
            pub fn descending_class_hierarchy<'a>(
                &self,
                host: &'a Database,
            ) -> DescendingClassHierarchy<'a> {
                self.__nd_descending_class_hierarchy(host)
            }
            /// Iterator over a descending scope hierarchy.
            pub fn descending_scope_hierarchy(&self) -> DescendingScopeHierarchy {
                self.__nd_descending_scope_hierarchy()
            }
            /// Iterator over a descending definition hierarchy.
            pub fn descending_definition_hierarchy(
                &self,
            ) -> DescendingDefinitionHierarchy {
                self.__nd_descending_definition_hierarchy()
            }
            pub fn is_namespace_or_ns_constant(&self) -> bool {
                if self.is::<Value>() {
                    if self.is::<Constant>() {
                        if self.is::<NamespaceConstant>() {
                            return NamespaceConstant(Constant(Value(self.clone())))
                                .is_namespace_or_ns_constant();
                        }
                    }
                } else if self.is::<Namespace>() {
                    return Namespace(self.clone()).is_namespace_or_ns_constant();
                }
                self.__nd_is_namespace_or_ns_constant()
            }
            pub fn wrap_property_reference(
                &self,
                host: &Database,
            ) -> Result<Entity, DeferError> {
                self.__nd_wrap_property_reference(host)
            }
            pub fn activation(&self) -> Option<Entity> {
                if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone())).activation();
                    }
                } else if self.is::<Value>() {
                    if self.is::<LambdaObject>() {
                        return LambdaObject(Value(self.clone())).activation();
                    }
                }
                self.__nd_activation()
            }
            pub fn set_activation(&self, activation: Option<Entity>) {
                if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .set_activation(activation);
                    }
                }
                self.__nd_set_activation(activation)
            }
            pub fn of_virtual_slot(&self, host: &Database) -> Option<Entity> {
                if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .of_virtual_slot(host);
                    } else if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .of_virtual_slot(host);
                    }
                }
                self.__nd_of_virtual_slot(host)
            }
            pub fn set_of_virtual_slot(&self, virtual_slot: Option<Entity>) {
                if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .set_of_virtual_slot(virtual_slot);
                    }
                }
                self.__nd_set_of_virtual_slot(virtual_slot)
            }
            pub fn overriden_by(&self, host: &Database) -> SharedArray<Entity> {
                if self.is::<MethodSlot>() {
                    if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .overriden_by(host);
                    } else if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .overriden_by(host);
                    }
                }
                self.__nd_overriden_by(host)
            }
            pub fn overrides_method(&self, host: &Database) -> Option<Entity> {
                if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .overrides_method(host);
                    } else if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .overrides_method(host);
                    }
                }
                self.__nd_overrides_method(host)
            }
            pub fn set_overrides_method(&self, method: Option<Entity>) {
                if self.is::<MethodSlot>() {
                    if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .set_overrides_method(method);
                    } else if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .set_overrides_method(method);
                    }
                }
                self.__nd_set_overrides_method(method)
            }
            pub fn is_constructor(&self) -> bool {
                if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .is_constructor();
                    } else if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .is_constructor();
                    }
                }
                self.__nd_is_constructor()
            }
            pub fn set_is_constructor(&self, value: bool) {
                if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .set_is_constructor(value);
                    }
                }
                self.__nd_set_is_constructor(value)
            }
            pub fn constructor_method(&self, host: &Database) -> Option<Entity> {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).constructor_method(host);
                    } else if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone()))
                            .constructor_method(host);
                    }
                }
                self.__nd_constructor_method(host)
            }
            pub fn set_constructor_method(&self, m: Option<Entity>) {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).set_constructor_method(m);
                    }
                }
                self.__nd_set_constructor_method(m)
            }
            pub fn known_subclasses(&self) -> SharedArray<Entity> {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).known_subclasses();
                    }
                }
                self.__nd_known_subclasses()
            }
            /// Includes possibly unresolved.
            pub fn implements(&self, host: &Database) -> SharedArray<Entity> {
                if self.is::<Type>() {
                    if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone()))
                            .implements(host);
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).implements(host);
                    }
                }
                self.__nd_implements(host)
            }
            /// Possibly unresolved.
            pub fn extends_class(&self, host: &Database) -> Option<Entity> {
                if self.is::<Type>() {
                    if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone()))
                            .extends_class(host);
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).extends_class(host);
                    } else if self.is::<TupleType>() {
                        return TupleType(Type(self.clone())).extends_class(host);
                    } else if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).extends_class(host);
                    } else if self.is::<FunctionType>() {
                        return FunctionType(Type(self.clone())).extends_class(host);
                    }
                }
                self.__nd_extends_class(host)
            }
            pub fn set_extends_class(&self, entity: Option<Entity>) {
                if self.is::<Type>() {
                    if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).set_extends_class(entity);
                    }
                }
                self.__nd_set_extends_class(entity)
            }
            pub fn prototype(&self, host: &Database) -> Names {
                if self.is::<Type>() {
                    if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).prototype(host);
                    } else if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone())).prototype(host);
                    } else if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone())).prototype(host);
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).prototype(host);
                    }
                }
                self.__nd_prototype(host)
            }
            pub fn properties(&self, host: &Database) -> Names {
                if self.is::<Scope>() {
                    return Scope(self.clone()).properties(host);
                } else if self.is::<Package>() {
                    return Package(self.clone()).properties(host);
                } else if self.is::<Type>() {
                    if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone()))
                            .properties(host);
                    } else if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).properties(host);
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).properties(host);
                    }
                }
                self.__nd_properties(host)
            }
            pub fn subpackages(&self) -> SharedMap<String, Entity> {
                if self.is::<Package>() {
                    return Package(self.clone()).subpackages();
                }
                self.__nd_subpackages()
            }
            pub fn alias_of(&self) -> Entity {
                if self.is::<Alias>() {
                    return Alias(self.clone()).alias_of();
                }
                self.__nd_alias_of()
            }
            pub fn set_alias_of(&self, value: &Entity) {
                if self.is::<Alias>() {
                    return Alias(self.clone()).set_alias_of(value);
                }
                self.__nd_set_alias_of(value)
            }
            pub fn resolve_alias(&self) -> Entity {
                if self.is::<Alias>() {
                    return Alias(self.clone()).resolve_alias();
                }
                self.__nd_resolve_alias()
            }
            pub fn property(&self) -> Entity {
                if self.is::<Value>() {
                    if self.is::<ReferenceValue>() {
                        if self.is::<FixtureReferenceValue>() {
                            return FixtureReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .property();
                        }
                    } else if self.is::<PackagePropertyImport>() {
                        return PackagePropertyImport(Value(self.clone())).property();
                    }
                }
                self.__nd_property()
            }
            pub fn set_property(&self, value: &Entity) {
                if self.is::<Value>() {
                    if self.is::<PackagePropertyImport>() {
                        return PackagePropertyImport(Value(self.clone()))
                            .set_property(value);
                    }
                }
                self.__nd_set_property(value)
            }
            pub fn includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                if self.is::<InvalidationEntity>() {
                    return InvalidationEntity(self.clone()).includes_undefined(host);
                } else if self.is::<Type>() {
                    return Type(self.clone()).includes_undefined(host);
                }
                self.__nd_includes_undefined(host)
            }
            pub fn includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                if self.is::<InvalidationEntity>() {
                    return InvalidationEntity(self.clone()).includes_null(host);
                } else if self.is::<Type>() {
                    return Type(self.clone()).includes_null(host);
                }
                self.__nd_includes_null(host)
            }
            pub fn name(&self) -> QName {
                if self.is::<VariableSlot>() {
                    if self.is::<VariableSlotAfterSubstitution>() {
                        return VariableSlotAfterSubstitution(VariableSlot(self.clone()))
                            .name();
                    } else if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone())).name();
                    }
                } else if self.is::<Alias>() {
                    return Alias(self.clone()).name();
                } else if self.is::<MethodSlot>() {
                    if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone())).name();
                    } else if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .name();
                    }
                } else if self.is::<Type>() {
                    if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone())).name();
                    } else if self.is::<TypeParameterType>() {
                        return TypeParameterType(Type(self.clone())).name();
                    } else if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).name();
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).name();
                    } else if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone())).name();
                    }
                } else if self.is::<VirtualSlot>() {
                    if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone())).name();
                    } else if self.is::<VirtualSlotAfterSubstitution>() {
                        return VirtualSlotAfterSubstitution(VirtualSlot(self.clone()))
                            .name();
                    }
                }
                self.__nd_name()
            }
            pub fn fully_qualified_name(&self) -> String {
                self.__nd_fully_qualified_name()
            }
            pub fn fully_qualified_name_list(&self) -> Vec<String> {
                self.__nd_fully_qualified_name_list()
            }
            pub fn type_params(&self) -> Option<SharedArray<Entity>> {
                if self.is::<Type>() {
                    if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone())).type_params();
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).type_params();
                    }
                }
                self.__nd_type_params()
            }
            pub fn set_type_params(&self, list: Option<SharedArray<Entity>>) {
                if self.is::<Type>() {
                    if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone())).set_type_params(list);
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).set_type_params(list);
                    }
                }
                self.__nd_set_type_params(list)
            }
            pub fn enum_member_number_mapping(&self) -> SharedMap<String, Number> {
                if self.is::<Type>() {
                    if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).enum_member_number_mapping();
                    }
                }
                self.__nd_enum_member_number_mapping()
            }
            pub fn enum_member_slot_mapping(&self) -> SharedMap<String, Entity> {
                if self.is::<Type>() {
                    if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).enum_member_slot_mapping();
                    }
                }
                self.__nd_enum_member_slot_mapping()
            }
            pub fn known_implementors(&self) -> SharedArray<Entity> {
                if self.is::<Type>() {
                    if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone())).known_implementors();
                    }
                }
                self.__nd_known_implementors()
            }
            /// Includes possibly unresolved.
            pub fn extends_interfaces(&self, host: &Database) -> SharedArray<Entity> {
                if self.is::<Type>() {
                    if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone()))
                            .extends_interfaces(host);
                    } else if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone()))
                            .extends_interfaces(host);
                    }
                }
                self.__nd_extends_interfaces(host)
            }
            pub fn origin(&self) -> Entity {
                if self.is::<MethodSlot>() {
                    if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .origin();
                    }
                } else if self.is::<VariableSlot>() {
                    if self.is::<VariableSlotAfterSubstitution>() {
                        return VariableSlotAfterSubstitution(VariableSlot(self.clone()))
                            .origin();
                    }
                } else if self.is::<VirtualSlot>() {
                    if self.is::<VirtualSlotAfterSubstitution>() {
                        return VirtualSlotAfterSubstitution(VirtualSlot(self.clone()))
                            .origin();
                    }
                } else if self.is::<Type>() {
                    if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone())).origin();
                    }
                }
                self.__nd_origin()
            }
            pub fn substitute_types(&self) -> SharedArray<Entity> {
                if self.is::<Type>() {
                    if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone()))
                            .substitute_types();
                    }
                }
                self.__nd_substitute_types()
            }
            pub fn indirect_type_params(&self) -> SharedArray<Entity> {
                if self.is::<VirtualSlot>() {
                    if self.is::<VirtualSlotAfterSubstitution>() {
                        return VirtualSlotAfterSubstitution(VirtualSlot(self.clone()))
                            .indirect_type_params();
                    }
                } else if self.is::<VariableSlot>() {
                    if self.is::<VariableSlotAfterSubstitution>() {
                        return VariableSlotAfterSubstitution(VariableSlot(self.clone()))
                            .indirect_type_params();
                    }
                } else if self.is::<MethodSlot>() {
                    if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .indirect_type_params();
                    }
                }
                self.__nd_indirect_type_params()
            }
            pub fn indirect_substitute_types(&self) -> SharedArray<Entity> {
                if self.is::<VirtualSlot>() {
                    if self.is::<VirtualSlotAfterSubstitution>() {
                        return VirtualSlotAfterSubstitution(VirtualSlot(self.clone()))
                            .indirect_substitute_types();
                    }
                } else if self.is::<MethodSlot>() {
                    if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .indirect_substitute_types();
                    }
                } else if self.is::<VariableSlot>() {
                    if self.is::<VariableSlotAfterSubstitution>() {
                        return VariableSlotAfterSubstitution(VariableSlot(self.clone()))
                            .indirect_substitute_types();
                    }
                }
                self.__nd_indirect_substitute_types()
            }
            pub fn element_types(&self) -> SharedArray<Entity> {
                if self.is::<Type>() {
                    if self.is::<TupleType>() {
                        return TupleType(Type(self.clone())).element_types();
                    }
                }
                self.__nd_element_types()
            }
            pub fn params(&self) -> SharedArray<Rc<SemanticFunctionTypeParameter>> {
                if self.is::<Type>() {
                    if self.is::<FunctionType>() {
                        return FunctionType(Type(self.clone())).params();
                    }
                }
                self.__nd_params()
            }
            pub fn result_type(&self) -> Entity {
                if self.is::<Type>() {
                    if self.is::<FunctionType>() {
                        return FunctionType(Type(self.clone())).result_type();
                    }
                }
                self.__nd_result_type()
            }
            pub fn base(&self) -> Entity {
                if self.is::<Type>() {
                    if self.is::<NonNullableType>() {
                        return NonNullableType(Type(self.clone())).base();
                    } else if self.is::<NullableType>() {
                        return NullableType(Type(self.clone())).base();
                    }
                } else if self.is::<Value>() {
                    if self.is::<ConversionValue>() {
                        return ConversionValue(Value(self.clone())).base();
                    } else if self.is::<NonNullValue>() {
                        return NonNullValue(Value(self.clone())).base();
                    } else if self.is::<ReferenceValue>() {
                        if self.is::<TupleReferenceValue>() {
                            return TupleReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .base();
                        } else if self.is::<StaticDynamicReferenceValue>() {
                            return StaticDynamicReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .base();
                        } else if self.is::<XmlReferenceValue>() {
                            return XmlReferenceValue(ReferenceValue(Value(self.clone())))
                                .base();
                        } else if self.is::<FixtureReferenceValue>() {
                            return FixtureReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .base();
                        } else if self.is::<VectorElementReferenceValue>() {
                            return VectorElementReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .base();
                        } else if self.is::<ArrayElementReferenceValue>() {
                            return ArrayElementReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .base();
                        } else if self.is::<DynamicReferenceValue>() {
                            return DynamicReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .base();
                        } else if self.is::<DynamicScopeReferenceValue>() {
                            return DynamicScopeReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .base();
                        }
                    }
                } else if self.is::<Scope>() {
                    if self.is::<FilterScope>() {
                        return FilterScope(Scope(self.clone())).base();
                    }
                }
                self.__nd_base()
            }
            /// Performs type substitution.
            pub fn apply_type(
                &self,
                host: &Database,
                type_params: &SharedArray<Entity>,
                substitute_types: &SharedArray<Entity>,
            ) -> Entity {
                self.__nd_apply_type(host, type_params, substitute_types)
            }
            pub fn read_only(&self, host: &Database) -> bool {
                if self.is::<Value>() {
                    if self.is::<ReferenceValue>() {
                        if self.is::<StaticDynamicReferenceValue>() {
                            return StaticDynamicReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .read_only(host);
                        } else if self.is::<FixtureReferenceValue>() {
                            return FixtureReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .read_only(host);
                        } else if self.is::<ArrayElementReferenceValue>() {
                            return ArrayElementReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .read_only(host);
                        } else if self.is::<DynamicScopeReferenceValue>() {
                            return DynamicScopeReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .read_only(host);
                        } else if self.is::<TupleReferenceValue>() {
                            return TupleReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .read_only(host);
                        } else if self.is::<DynamicReferenceValue>() {
                            return DynamicReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .read_only(host);
                        } else if self.is::<VectorElementReferenceValue>() {
                            return VectorElementReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .read_only(host);
                        } else if self.is::<XmlReferenceValue>() {
                            return XmlReferenceValue(ReferenceValue(Value(self.clone())))
                                .read_only(host);
                        }
                    }
                } else if self.is::<VariableSlot>() {
                    if self.is::<VariableSlotAfterSubstitution>() {
                        return VariableSlotAfterSubstitution(VariableSlot(self.clone()))
                            .read_only(host);
                    } else if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone()))
                            .read_only(host);
                    }
                } else if self.is::<VirtualSlot>() {
                    if self.is::<VirtualSlotAfterSubstitution>() {
                        return VirtualSlotAfterSubstitution(VirtualSlot(self.clone()))
                            .read_only(host);
                    } else if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone()))
                            .read_only(host);
                    }
                }
                self.__nd_read_only(host)
            }
            pub fn set_read_only(&self, value: bool) {
                if self.is::<VariableSlot>() {
                    if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone()))
                            .set_read_only(value);
                    }
                }
                self.__nd_set_read_only(value)
            }
            pub fn write_only(&self, host: &Database) -> bool {
                if self.is::<VariableSlot>() {
                    if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone()))
                            .write_only(host);
                    } else if self.is::<VariableSlotAfterSubstitution>() {
                        return VariableSlotAfterSubstitution(VariableSlot(self.clone()))
                            .write_only(host);
                    }
                } else if self.is::<VirtualSlot>() {
                    if self.is::<VirtualSlotAfterSubstitution>() {
                        return VirtualSlotAfterSubstitution(VirtualSlot(self.clone()))
                            .write_only(host);
                    } else if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone()))
                            .write_only(host);
                    }
                } else if self.is::<Value>() {
                    if self.is::<ReferenceValue>() {
                        if self.is::<ArrayElementReferenceValue>() {
                            return ArrayElementReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .write_only(host);
                        } else if self.is::<VectorElementReferenceValue>() {
                            return VectorElementReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .write_only(host);
                        } else if self.is::<FixtureReferenceValue>() {
                            return FixtureReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .write_only(host);
                        } else if self.is::<DynamicReferenceValue>() {
                            return DynamicReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .write_only(host);
                        } else if self.is::<StaticDynamicReferenceValue>() {
                            return StaticDynamicReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .write_only(host);
                        } else if self.is::<DynamicScopeReferenceValue>() {
                            return DynamicScopeReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .write_only(host);
                        } else if self.is::<XmlReferenceValue>() {
                            return XmlReferenceValue(ReferenceValue(Value(self.clone())))
                                .write_only(host);
                        } else if self.is::<TupleReferenceValue>() {
                            return TupleReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .write_only(host);
                        }
                    }
                }
                self.__nd_write_only(host)
            }
            pub fn set_write_only(&self, value: bool) {
                self.__nd_set_write_only(value)
            }
            pub fn deletable(&self, host: &Database) -> bool {
                if self.is::<Value>() {
                    if self.is::<ReferenceValue>() {
                        if self.is::<ArrayElementReferenceValue>() {
                            return ArrayElementReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .deletable(host);
                        } else if self.is::<VectorElementReferenceValue>() {
                            return VectorElementReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .deletable(host);
                        } else if self.is::<StaticDynamicReferenceValue>() {
                            return StaticDynamicReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .deletable(host);
                        } else if self.is::<TupleReferenceValue>() {
                            return TupleReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .deletable(host);
                        } else if self.is::<FixtureReferenceValue>() {
                            return FixtureReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .deletable(host);
                        } else if self.is::<DynamicReferenceValue>() {
                            return DynamicReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .deletable(host);
                        } else if self.is::<XmlReferenceValue>() {
                            return XmlReferenceValue(ReferenceValue(Value(self.clone())))
                                .deletable(host);
                        } else if self.is::<DynamicScopeReferenceValue>() {
                            return DynamicScopeReferenceValue(
                                    ReferenceValue(Value(self.clone())),
                                )
                                .deletable(host);
                        }
                    }
                }
                self.__nd_deletable(host)
            }
            pub fn var_constant(&self) -> Option<Entity> {
                if self.is::<VariableSlot>() {
                    if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone()))
                            .var_constant();
                    } else if self.is::<VariableSlotAfterSubstitution>() {
                        return VariableSlotAfterSubstitution(VariableSlot(self.clone()))
                            .var_constant();
                    }
                }
                self.__nd_var_constant()
            }
            pub fn set_var_constant(&self, k: Option<Entity>) {
                if self.is::<VariableSlot>() {
                    if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone()))
                            .set_var_constant(k);
                    }
                }
                self.__nd_set_var_constant(k)
            }
            pub fn is_ascending_type_of(
                &self,
                possibly_subtype: &Entity,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_is_ascending_type_of(possibly_subtype, host)
            }
            pub fn is_subtype_of(
                &self,
                possibly_ascending_type: &Entity,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_is_subtype_of(possibly_ascending_type, host)
            }
            pub fn is_equals_or_subtype_of(
                &self,
                other: &Entity,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_is_equals_or_subtype_of(other, host)
            }
            /// Returns all ascending types of a type in ascending type order,
            /// each possibly unresolved.
            pub fn all_ascending_types(&self, host: &Database) -> Vec<Entity> {
                self.__nd_all_ascending_types(host)
            }
            fn all_ascending_types_non_circular(
                &self,
                host: &Database,
                descending_most: &Entity,
            ) -> Vec<Entity> {
                self.__nd_all_ascending_types_non_circular(host, descending_most)
            }
            /// Returns direct ascending types of a type, each possibly unresolved.
            pub fn direct_ascending_types(&self, host: &Database) -> Vec<Entity> {
                self.__nd_direct_ascending_types(host)
            }
            pub(crate) fn not_overriden_abstract_getter(
                &self,
                getter_from_base_class: &Entity,
                subclass: &Entity,
                host: &Database,
            ) -> bool {
                self.__nd_not_overriden_abstract_getter(
                    getter_from_base_class,
                    subclass,
                    host,
                )
            }
            pub(crate) fn not_overriden_abstract_setter(
                &self,
                setter_from_base_class: &Entity,
                subclass: &Entity,
                host: &Database,
            ) -> bool {
                self.__nd_not_overriden_abstract_setter(
                    setter_from_base_class,
                    subclass,
                    host,
                )
            }
            pub fn is_comparison_between_unrelated_types(
                &self,
                other: &Entity,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_is_comparison_between_unrelated_types(other, host)
            }
            pub fn expect_type(&self) -> Result<Entity, TypeExpectError> {
                self.__nd_expect_type()
            }
            pub fn as_type(&self) -> Option<Entity> {
                self.__nd_as_type()
            }
            pub fn fixture_reference_value_equals(&self, other: &Entity) -> bool {
                self.__nd_fixture_reference_value_equals(other)
            }
            pub fn control_flow_graph(&self) -> ControlFlowGraph {
                if self.is::<Scope>() {
                    if self.is::<Activation>() {
                        return Activation(Scope(self.clone())).control_flow_graph();
                    }
                }
                self.__nd_control_flow_graph()
            }
            /// Lookups property in an object.
            pub fn lookup_in_object(
                &self,
                host: &Database,
                open_ns_set: &SharedArray<Entity>,
                qual: Option<Entity>,
                key: &PropertyLookupKey,
                calling: bool,
            ) -> Result<Option<Entity>, PropertyLookupError> {
                self.__nd_lookup_in_object(host, open_ns_set, qual, key, calling)
            }
            /// Lookups property in the scope chain.
            pub fn lookup_in_scope_chain(
                &self,
                host: &Database,
                qual: Option<Entity>,
                key: &PropertyLookupKey,
            ) -> Result<Option<Entity>, PropertyLookupError> {
                self.__nd_lookup_in_scope_chain(host, qual, key)
            }
            pub fn search_system_ns_in_scope_chain(
                &self,
                ns: SystemNamespaceKind,
            ) -> Option<Entity> {
                self.__nd_search_system_ns_in_scope_chain(ns)
            }
            pub fn field_reference(&self) -> Option<Entity> {
                if self.is::<DeclarativeFieldDestructuringResolution>() {
                    return DeclarativeFieldDestructuringResolution(self.clone())
                        .field_reference();
                } else if self.is::<AssignmentFieldDestructuringResolution>() {
                    return AssignmentFieldDestructuringResolution(self.clone())
                        .field_reference();
                }
                self.__nd_field_reference()
            }
            pub fn set_field_reference(&self, value: Option<Entity>) {
                if self.is::<AssignmentFieldDestructuringResolution>() {
                    return AssignmentFieldDestructuringResolution(self.clone())
                        .set_field_reference(value);
                } else if self.is::<DeclarativeFieldDestructuringResolution>() {
                    return DeclarativeFieldDestructuringResolution(self.clone())
                        .set_field_reference(value);
                }
                self.__nd_set_field_reference(value)
            }
            pub fn var_slot(&self) -> Option<Entity> {
                if self.is::<DeclarativeFieldDestructuringResolution>() {
                    return DeclarativeFieldDestructuringResolution(self.clone())
                        .var_slot();
                }
                self.__nd_var_slot()
            }
            pub fn set_var_slot(&self, value: Option<Entity>) {
                if self.is::<DeclarativeFieldDestructuringResolution>() {
                    return DeclarativeFieldDestructuringResolution(self.clone())
                        .set_var_slot(value);
                }
                self.__nd_set_var_slot(value)
            }
            pub fn target_reference(&self) -> Option<Entity> {
                if self.is::<AssignmentFieldDestructuringResolution>() {
                    return AssignmentFieldDestructuringResolution(self.clone())
                        .target_reference();
                }
                self.__nd_target_reference()
            }
            pub fn set_target_reference(&self, value: Option<Entity>) {
                if self.is::<AssignmentFieldDestructuringResolution>() {
                    return AssignmentFieldDestructuringResolution(self.clone())
                        .set_target_reference(value);
                }
                self.__nd_set_target_reference(value)
            }
            pub fn search_hoist_scope(&self) -> Entity {
                self.__nd_search_hoist_scope()
            }
            pub fn is_empty_package(&self, host: &Database) -> bool {
                self.__nd_is_empty_package(host)
            }
            pub fn is_empty_package_recursive(&self, host: &Database) -> bool {
                self.__nd_is_empty_package_recursive(host)
            }
            pub fn list_packages_recursively(&self) -> Vec<Entity> {
                self.__nd_list_packages_recursively()
            }
            fn to_string_1(&self) -> String {
                if self.is::<VirtualSlot>() {
                    if self.is::<OriginalVirtualSlot>() {
                        return OriginalVirtualSlot(VirtualSlot(self.clone()))
                            .to_string_1();
                    } else if self.is::<VirtualSlotAfterSubstitution>() {
                        return VirtualSlotAfterSubstitution(VirtualSlot(self.clone()))
                            .to_string_1();
                    }
                } else if self.is::<Package>() {
                    return Package(self.clone()).to_string_1();
                } else if self.is::<Namespace>() {
                    if self.is::<ExplicitNamespace>() {
                        return ExplicitNamespace(Namespace(self.clone())).to_string_1();
                    } else if self.is::<SystemNamespace>() {
                        return SystemNamespace(Namespace(self.clone())).to_string_1();
                    } else if self.is::<UserNamespace>() {
                        return UserNamespace(Namespace(self.clone())).to_string_1();
                    }
                } else if self.is::<VariableSlot>() {
                    if self.is::<VariableSlotAfterSubstitution>() {
                        return VariableSlotAfterSubstitution(VariableSlot(self.clone()))
                            .to_string_1();
                    } else if self.is::<OriginalVariableSlot>() {
                        return OriginalVariableSlot(VariableSlot(self.clone()))
                            .to_string_1();
                    }
                } else if self.is::<MethodSlot>() {
                    if self.is::<MethodSlotAfterSubstitution>() {
                        return MethodSlotAfterSubstitution(MethodSlot(self.clone()))
                            .to_string_1();
                    } else if self.is::<OriginalMethodSlot>() {
                        return OriginalMethodSlot(MethodSlot(self.clone()))
                            .to_string_1();
                    }
                } else if self.is::<Type>() {
                    if self.is::<TypeParameterType>() {
                        return TypeParameterType(Type(self.clone())).to_string_1();
                    } else if self.is::<FunctionType>() {
                        return FunctionType(Type(self.clone())).to_string_1();
                    } else if self.is::<AnyType>() {
                        return AnyType(Type(self.clone())).to_string_1();
                    } else if self.is::<NonNullableType>() {
                        return NonNullableType(Type(self.clone())).to_string_1();
                    } else if self.is::<InterfaceType>() {
                        return InterfaceType(Type(self.clone())).to_string_1();
                    } else if self.is::<NullableType>() {
                        return NullableType(Type(self.clone())).to_string_1();
                    } else if self.is::<VoidType>() {
                        return VoidType(Type(self.clone())).to_string_1();
                    } else if self.is::<ClassType>() {
                        return ClassType(Type(self.clone())).to_string_1();
                    } else if self.is::<EnumType>() {
                        return EnumType(Type(self.clone())).to_string_1();
                    } else if self.is::<TypeAfterSubstitution>() {
                        return TypeAfterSubstitution(Type(self.clone())).to_string_1();
                    } else if self.is::<TupleType>() {
                        return TupleType(Type(self.clone())).to_string_1();
                    }
                } else if self.is::<Alias>() {
                    return Alias(self.clone()).to_string_1();
                } else if self.is::<InvalidationEntity>() {
                    return InvalidationEntity(self.clone()).to_string_1();
                }
                self.__nd_to_string_1()
            }
            pub fn to<T: TryFrom<Entity, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<Entity, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl UnresolvedEntity {
            fn __ctor(&self) {}
            pub(crate) fn new(arena: &EntityArena) -> Self {
                let __cto1 = UnresolvedEntity(
                    Entity(
                        arena
                            .allocate(__data__::__data_Entity {
                                __variant: __data__::__variant_Entity::__data_UnresolvedEntity(
                                    ::std::rc::Rc::new(__data__::__data_UnresolvedEntity {
                                        __variant: __data__::__variant_UnresolvedEntity::__Nothing,
                                    }),
                                ),
                            })
                            .clone(),
                    ),
                );
                Entity::__ctor(&__cto1.0);
                __cto1.__ctor();
                __cto1
            }
            pub fn to<
                T: TryFrom<UnresolvedEntity, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<UnresolvedEntity, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl InvalidationEntity {
            fn __ctor(&self) {}
            pub(crate) fn new(arena: &EntityArena) -> Self {
                let __cto1 = InvalidationEntity(
                    Entity(
                        arena
                            .allocate(__data__::__data_Entity {
                                __variant: __data__::__variant_Entity::__data_InvalidationEntity(
                                    ::std::rc::Rc::new(__data__::__data_InvalidationEntity {
                                        __variant: __data__::__variant_InvalidationEntity::__Nothing,
                                    }),
                                ),
                            })
                            .clone(),
                    ),
                );
                Entity::__ctor(&__cto1.0);
                __cto1.__ctor();
                __cto1
            }
            fn __nd_property_static_type(&self, host: &Database) -> Entity {
                self.clone().into()
            }
            fn __nd_static_type(&self, host: &Database) -> Entity {
                self.clone().into()
            }
            fn __nd_includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                Ok(true)
            }
            fn __nd_includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                Ok(true)
            }
            fn __nd_to_string_1(&self) -> String {
                "[unknown]".into()
            }
            /// Returns the static type of a property, whether for a type, variable, virtual or method slot or namespace,
            /// or act as identity of a value's static type.
            /// Possibly `UnresolvedEntity`.
            pub fn property_static_type(&self, host: &Database) -> Entity {
                self.__nd_property_static_type(host)
            }
            pub fn static_type(&self, host: &Database) -> Entity {
                self.__nd_static_type(host)
            }
            pub fn includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_includes_undefined(host)
            }
            pub fn includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                self.__nd_includes_null(host)
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<InvalidationEntity, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<InvalidationEntity, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl Namespace {
            fn __ctor(&self) {}
            pub(crate) fn new(arena: &EntityArena) -> Self {
                let __cto1 = Namespace(
                    Entity(
                        arena
                            .allocate(__data__::__data_Entity {
                                __variant: __data__::__variant_Entity::__data_Namespace(
                                    ::std::rc::Rc::new(__data__::__data_Namespace {
                                        __variant: __data__::__variant_Namespace::__Nothing,
                                    }),
                                ),
                            })
                            .clone(),
                    ),
                );
                Entity::__ctor(&__cto1.0);
                __cto1.__ctor();
                __cto1
            }
            fn __nd_property_static_type(&self, host: &Database) -> Entity {
                host.namespace_type()
            }
            fn __nd_is_namespace_or_ns_constant(&self) -> bool {
                true
            }
            /// Returns the static type of a property, whether for a type, variable, virtual or method slot or namespace,
            /// or act as identity of a value's static type.
            /// Possibly `UnresolvedEntity`.
            pub fn property_static_type(&self, host: &Database) -> Entity {
                self.__nd_property_static_type(host)
            }
            pub fn is_namespace_or_ns_constant(&self) -> bool {
                self.__nd_is_namespace_or_ns_constant()
            }
            pub fn to<T: TryFrom<Namespace, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<Namespace, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl SystemNamespace {
            #[allow(non_snake_case)]
            fn m_kind(&self) -> SystemNamespaceKind {
                (if let __data__::__variant_Entity::__data_Namespace(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Namespace::__data_SystemNamespace(o) = &o
                        .__variant
                    {
                        (&o.m_kind)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .get()
            }
            #[allow(non_snake_case)]
            fn set_m_kind(&self, v: SystemNamespaceKind) {
                (if let __data__::__variant_Entity::__data_Namespace(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Namespace::__data_SystemNamespace(o) = &o
                        .__variant
                    {
                        (&o.m_kind)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .set(v);
            }
            #[allow(non_snake_case)]
            fn m_parent(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Namespace(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Namespace::__data_SystemNamespace(o) = &o
                        .__variant
                    {
                        (&o.m_parent)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_parent(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Namespace(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Namespace::__data_SystemNamespace(o) = &o
                        .__variant
                    {
                        (&o.m_parent)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, kind: SystemNamespaceKind, parent: Option<Entity>) {
                self.set_m_kind(kind);
                self.set_m_parent(parent);
            }
            pub(crate) fn new(
                arena: &EntityArena,
                kind: SystemNamespaceKind,
                parent: Option<Entity>,
            ) -> Self {
                let __cto1 = SystemNamespace(
                    Namespace(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Namespace(
                                        ::std::rc::Rc::new(__data__::__data_Namespace {
                                            __variant: __data__::__variant_Namespace::__data_SystemNamespace(
                                                ::std::rc::Rc::new(__data__::__data_SystemNamespace {
                                                    m_parent: ::std::cell::RefCell::new(None),
                                                    m_kind: ::std::cell::Cell::new(SystemNamespaceKind::Public),
                                                    __variant: __data__::__variant_SystemNamespace::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Namespace::__ctor(&__cto1.0);
                __cto1.__ctor(kind, parent);
                __cto1
            }
            fn __nd_system_ns_kind(&self) -> Option<SystemNamespaceKind> {
                Some(self.m_kind())
            }
            fn __nd_is_public_ns(&self) -> bool {
                self.m_kind() == SystemNamespaceKind::Public
            }
            fn __nd_is_private_ns(&self) -> bool {
                self.m_kind() == SystemNamespaceKind::Private
            }
            fn __nd_is_protected_ns(&self) -> bool {
                self.m_kind() == SystemNamespaceKind::Protected
            }
            fn __nd_is_internal_ns(&self) -> bool {
                self.m_kind() == SystemNamespaceKind::Internal
            }
            fn __nd_is_static_protected_ns(&self) -> bool {
                self.m_kind() == SystemNamespaceKind::StaticProtected
            }
            fn __nd_parent(&self) -> Option<Entity> {
                self.m_parent()
            }
            fn __nd_to_string_1(&self) -> String {
                self.m_kind().to_string()
            }
            pub fn system_ns_kind(&self) -> Option<SystemNamespaceKind> {
                self.__nd_system_ns_kind()
            }
            pub fn is_public_ns(&self) -> bool {
                self.__nd_is_public_ns()
            }
            pub fn is_private_ns(&self) -> bool {
                self.__nd_is_private_ns()
            }
            pub fn is_protected_ns(&self) -> bool {
                self.__nd_is_protected_ns()
            }
            pub fn is_internal_ns(&self) -> bool {
                self.__nd_is_internal_ns()
            }
            pub fn is_static_protected_ns(&self) -> bool {
                self.__nd_is_static_protected_ns()
            }
            pub fn parent(&self) -> Option<Entity> {
                self.__nd_parent()
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<SystemNamespace, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<SystemNamespace, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl UserNamespace {
            #[allow(non_snake_case)]
            fn m_uri(&self) -> String {
                (if let __data__::__variant_Entity::__data_Namespace(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Namespace::__data_UserNamespace(o) = &o
                        .__variant
                    {
                        (&o.m_uri)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_uri(&self, v: String) {
                (if let __data__::__variant_Entity::__data_Namespace(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Namespace::__data_UserNamespace(o) = &o
                        .__variant
                    {
                        (&o.m_uri)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, uri: String) {
                self.set_m_uri(uri);
            }
            pub(crate) fn new(arena: &EntityArena, uri: String) -> Self {
                let __cto1 = UserNamespace(
                    Namespace(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Namespace(
                                        ::std::rc::Rc::new(__data__::__data_Namespace {
                                            __variant: __data__::__variant_Namespace::__data_UserNamespace(
                                                ::std::rc::Rc::new(__data__::__data_UserNamespace {
                                                    m_uri: ::std::cell::RefCell::new("".into()),
                                                    __variant: __data__::__variant_UserNamespace::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Namespace::__ctor(&__cto1.0);
                __cto1.__ctor(uri);
                __cto1
            }
            fn __nd_uri(&self) -> String {
                self.m_uri()
            }
            fn __nd_to_string_1(&self) -> String {
                self.m_uri()
            }
            pub fn uri(&self) -> String {
                self.__nd_uri()
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<UserNamespace, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<UserNamespace, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl ExplicitNamespace {
            #[allow(non_snake_case)]
            fn m_uri(&self) -> String {
                (if let __data__::__variant_Entity::__data_Namespace(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Namespace::__data_ExplicitNamespace(o) = &o
                        .__variant
                    {
                        (&o.m_uri)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_uri(&self, v: String) {
                (if let __data__::__variant_Entity::__data_Namespace(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Namespace::__data_ExplicitNamespace(o) = &o
                        .__variant
                    {
                        (&o.m_uri)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, uri: String) {
                self.set_m_uri(uri);
            }
            pub(crate) fn new(arena: &EntityArena, uri: String) -> Self {
                let __cto1 = ExplicitNamespace(
                    Namespace(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Namespace(
                                        ::std::rc::Rc::new(__data__::__data_Namespace {
                                            __variant: __data__::__variant_Namespace::__data_ExplicitNamespace(
                                                ::std::rc::Rc::new(__data__::__data_ExplicitNamespace {
                                                    m_uri: ::std::cell::RefCell::new("".into()),
                                                    __variant: __data__::__variant_ExplicitNamespace::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Namespace::__ctor(&__cto1.0);
                __cto1.__ctor(uri);
                __cto1
            }
            fn __nd_uri(&self) -> String {
                self.m_uri()
            }
            fn __nd_to_string_1(&self) -> String {
                self.m_uri()
            }
            pub fn uri(&self) -> String {
                self.__nd_uri()
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<ExplicitNamespace, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<ExplicitNamespace, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl Package {
            #[allow(non_snake_case)]
            fn m_name(&self) -> String {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_name)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_name(&self, v: String) {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_name)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_parent(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_parent)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_parent(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_parent)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_public_ns(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_public_ns)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_public_ns(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_public_ns)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_internal_ns(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_internal_ns)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_internal_ns(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_internal_ns)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_properties(&self) -> Names {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_properties)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_properties(&self, v: Names) {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_properties)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_subpackages(&self) -> SharedMap<String, Entity> {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_subpackages)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_subpackages(&self, v: SharedMap<String, Entity>) {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_subpackages)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_package_concats(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_package_concats)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_package_concats(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_package_concats)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_asdoc(&self) -> Option<Rc<Asdoc>> {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_asdoc)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_asdoc(&self, v: Option<Rc<Asdoc>>) {
                (if let __data__::__variant_Entity::__data_Package(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_asdoc)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, name: String) {
                self.set_m_name(name);
            }
            pub(crate) fn new(arena: &EntityArena, name: String) -> Self {
                let __cto1 = Package(
                    Entity(
                        arena
                            .allocate(__data__::__data_Entity {
                                __variant: __data__::__variant_Entity::__data_Package(
                                    ::std::rc::Rc::new(__data__::__data_Package {
                                        m_name: ::std::cell::RefCell::new("".into()),
                                        m_parent: ::std::cell::RefCell::new(None),
                                        m_public_ns: ::std::cell::RefCell::new(None),
                                        m_internal_ns: ::std::cell::RefCell::new(None),
                                        m_subpackages: ::std::cell::RefCell::new(SharedMap::new()),
                                        m_package_concats: ::std::cell::RefCell::new(
                                            SharedArray::new(),
                                        ),
                                        m_asdoc: ::std::cell::RefCell::new(None),
                                        m_properties: ::std::cell::RefCell::new(Names::new()),
                                        __variant: __data__::__variant_Package::__Nothing,
                                    }),
                                ),
                            })
                            .clone(),
                    ),
                );
                Entity::__ctor(&__cto1.0);
                __cto1.__ctor(name);
                __cto1
            }
            fn __nd_local_name(&self) -> String {
                self.m_name()
            }
            fn __nd_parent(&self) -> Option<Entity> {
                self.m_parent()
            }
            fn __nd_set_parent(&self, p: Option<Entity>) {
                self.set_m_parent(p);
            }
            fn __nd_package_concats(&self) -> SharedArray<Entity> {
                self.m_package_concats()
            }
            fn __nd_public_ns(&self) -> Option<Entity> {
                self.m_public_ns()
            }
            fn __nd_set_public_ns(&self, ns: Option<Entity>) {
                self.set_m_public_ns(ns);
            }
            fn __nd_internal_ns(&self) -> Option<Entity> {
                self.m_internal_ns()
            }
            fn __nd_set_internal_ns(&self, ns: Option<Entity>) {
                self.set_m_internal_ns(ns);
            }
            fn __nd_properties(&self, host: &Database) -> Names {
                self.m_properties()
            }
            fn __nd_subpackages(&self) -> SharedMap<String, Entity> {
                self.m_subpackages()
            }
            fn __nd_asdoc(&self) -> Option<Rc<Asdoc>> {
                self.m_asdoc()
            }
            fn __nd_set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {
                self.set_m_asdoc(asdoc);
            }
            fn __nd_to_string_1(&self) -> String {
                self.fully_qualified_name()
            }
            /// The local name of the package. For the top-level package
            /// this is the empty string.
            pub fn local_name(&self) -> String {
                self.__nd_local_name()
            }
            pub fn parent(&self) -> Option<Entity> {
                self.__nd_parent()
            }
            pub fn set_parent(&self, p: Option<Entity>) {
                self.__nd_set_parent(p)
            }
            /// Concatenated packages.
            pub fn package_concats(&self) -> SharedArray<Entity> {
                self.__nd_package_concats()
            }
            pub fn public_ns(&self) -> Option<Entity> {
                self.__nd_public_ns()
            }
            pub fn set_public_ns(&self, ns: Option<Entity>) {
                self.__nd_set_public_ns(ns)
            }
            pub fn internal_ns(&self) -> Option<Entity> {
                self.__nd_internal_ns()
            }
            pub fn set_internal_ns(&self, ns: Option<Entity>) {
                self.__nd_set_internal_ns(ns)
            }
            pub fn properties(&self, host: &Database) -> Names {
                self.__nd_properties(host)
            }
            pub fn subpackages(&self) -> SharedMap<String, Entity> {
                self.__nd_subpackages()
            }
            pub fn asdoc(&self) -> Option<Rc<Asdoc>> {
                self.__nd_asdoc()
            }
            pub fn set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {
                self.__nd_set_asdoc(asdoc)
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<T: TryFrom<Package, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<Package, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl Alias {
            #[allow(non_snake_case)]
            fn m_name(&self) -> Option<QName> {
                (if let __data__::__variant_Entity::__data_Alias(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_name)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_name(&self, v: Option<QName>) {
                (if let __data__::__variant_Entity::__data_Alias(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_name)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_alias_of(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Alias(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_alias_of)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_alias_of(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Alias(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_alias_of)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_parent(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Alias(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_parent)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_parent(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Alias(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_parent)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_location(&self) -> Option<Location> {
                (if let __data__::__variant_Entity::__data_Alias(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_location)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_location(&self, v: Option<Location>) {
                (if let __data__::__variant_Entity::__data_Alias(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_location)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, name: QName, alias_of: Entity) {
                self.set_m_name(Some(name));
                self.set_m_alias_of(Some(alias_of));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                name: QName,
                alias_of: Entity,
            ) -> Self {
                let __cto1 = Alias(
                    Entity(
                        arena
                            .allocate(__data__::__data_Entity {
                                __variant: __data__::__variant_Entity::__data_Alias(
                                    ::std::rc::Rc::new(__data__::__data_Alias {
                                        m_alias_of: ::std::cell::RefCell::new(None),
                                        m_location: ::std::cell::RefCell::new(None),
                                        m_name: ::std::cell::RefCell::new(None),
                                        m_parent: ::std::cell::RefCell::new(None),
                                        __variant: __data__::__variant_Alias::__Nothing,
                                    }),
                                ),
                            })
                            .clone(),
                    ),
                );
                Entity::__ctor(&__cto1.0);
                __cto1.__ctor(name, alias_of);
                __cto1
            }
            fn __nd_name(&self) -> QName {
                self.m_name().unwrap()
            }
            fn __nd_alias_of(&self) -> Entity {
                self.m_alias_of().unwrap()
            }
            fn __nd_set_alias_of(&self, value: &Entity) {
                self.set_m_alias_of(Some(value.clone()));
            }
            fn __nd_location(&self) -> Option<Location> {
                self.m_location()
            }
            fn __nd_set_location(&self, loc: Option<Location>) {
                self.set_m_location(loc);
            }
            fn __nd_resolve_alias(&self) -> Entity {
                self.alias_of().resolve_alias()
            }
            fn __nd_parent(&self) -> Option<Entity> {
                self.m_parent()
            }
            fn __nd_set_parent(&self, p: Option<Entity>) {
                self.set_m_parent(p);
            }
            fn __nd_to_string_1(&self) -> String {
                self.alias_of().to_string_1()
            }
            pub fn name(&self) -> QName {
                self.__nd_name()
            }
            pub fn alias_of(&self) -> Entity {
                self.__nd_alias_of()
            }
            pub fn set_alias_of(&self, value: &Entity) {
                self.__nd_set_alias_of(value)
            }
            pub fn location(&self) -> Option<Location> {
                self.__nd_location()
            }
            pub fn set_location(&self, loc: Option<Location>) {
                self.__nd_set_location(loc)
            }
            pub fn resolve_alias(&self) -> Entity {
                self.__nd_resolve_alias()
            }
            pub fn parent(&self) -> Option<Entity> {
                self.__nd_parent()
            }
            pub fn set_parent(&self, p: Option<Entity>) {
                self.__nd_set_parent(p)
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<T: TryFrom<Alias, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<Alias, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl Type {
            fn __ctor(&self) {}
            fn new(arena: &EntityArena) -> Self {
                let __cto1 = Type(
                    Entity(
                        arena
                            .allocate(__data__::__data_Entity {
                                __variant: __data__::__variant_Entity::__data_Type(
                                    ::std::rc::Rc::new(__data__::__data_Type {
                                        __variant: __data__::__variant_Type::__Nothing,
                                    }),
                                ),
                            })
                            .clone(),
                    ),
                );
                Entity::__ctor(&__cto1.0);
                __cto1.__ctor();
                __cto1
            }
            fn __nd_includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                Ok(true)
            }
            fn __nd_includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                Ok(false)
            }
            fn __nd_property_static_type(&self, host: &Database) -> Entity {
                host.class_type()
            }
            fn __nd_type_default_value(
                &self,
                host: &Database,
            ) -> Result<Option<Entity>, DeferError> {
                if self.includes_undefined(host)? {
                    Ok(Some(host.factory().create_undefined_constant(self)))
                } else if self.includes_null(host)? {
                    Ok(Some(host.factory().create_null_constant(self)))
                } else if host.numeric_types()?.contains(self) {
                    if host.floating_point_types()?.contains(self) {
                        let v = Number::nan(self, host);
                        return Ok(Some(host.factory().create_number_constant(v, self)));
                    }
                    let v = Number::zero(self, host);
                    Ok(Some(host.factory().create_number_constant(v, self)))
                } else if <Type as Into<Entity>>::into(self.clone())
                    == host.boolean_type().defer()?
                {
                    Ok(Some(host.factory().create_boolean_constant(false, self)))
                } else {
                    Ok(None)
                }
            }
            pub fn includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                if self.is::<FunctionType>() {
                    return FunctionType(self.clone()).includes_undefined(host);
                } else if self.is::<NullableType>() {
                    return NullableType(self.clone()).includes_undefined();
                } else if self.is::<EnumType>() {
                    return EnumType(self.clone()).includes_undefined(host);
                } else if self.is::<InterfaceType>() {
                    return InterfaceType(self.clone()).includes_undefined(host);
                } else if self.is::<NonNullableType>() {
                    return NonNullableType(self.clone()).includes_undefined();
                } else if self.is::<TupleType>() {
                    return TupleType(self.clone()).includes_undefined(host);
                } else if self.is::<ClassType>() {
                    return ClassType(self.clone()).includes_undefined(host);
                } else if self.is::<TypeParameterType>() {
                    return TypeParameterType(self.clone()).includes_undefined();
                } else if self.is::<VoidType>() {
                    return VoidType(self.clone()).includes_undefined(host);
                } else if self.is::<TypeAfterSubstitution>() {
                    return TypeAfterSubstitution(self.clone()).includes_undefined(host);
                } else if self.is::<AnyType>() {
                    return AnyType(self.clone()).includes_undefined(host);
                }
                self.__nd_includes_undefined(host)
            }
            pub fn includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                if self.is::<InterfaceType>() {
                    return InterfaceType(self.clone()).includes_null(host);
                } else if self.is::<ClassType>() {
                    return ClassType(self.clone()).includes_null(host);
                } else if self.is::<FunctionType>() {
                    return FunctionType(self.clone()).includes_null(host);
                } else if self.is::<EnumType>() {
                    return EnumType(self.clone()).includes_null(host);
                } else if self.is::<NullableType>() {
                    return NullableType(self.clone()).includes_null();
                } else if self.is::<VoidType>() {
                    return VoidType(self.clone()).includes_null(host);
                } else if self.is::<NonNullableType>() {
                    return NonNullableType(self.clone()).includes_null();
                } else if self.is::<TypeParameterType>() {
                    return TypeParameterType(self.clone()).includes_null();
                } else if self.is::<AnyType>() {
                    return AnyType(self.clone()).includes_null(host);
                } else if self.is::<TupleType>() {
                    return TupleType(self.clone()).includes_null(host);
                } else if self.is::<TypeAfterSubstitution>() {
                    return TypeAfterSubstitution(self.clone()).includes_null(host);
                }
                self.__nd_includes_null(host)
            }
            /// Returns the static type of a property, whether for a type, variable, virtual or method slot or namespace,
            /// or act as identity of a value's static type.
            /// Possibly `UnresolvedEntity`.
            pub fn property_static_type(&self, host: &Database) -> Entity {
                self.__nd_property_static_type(host)
            }
            pub fn type_default_value(
                &self,
                host: &Database,
            ) -> Result<Option<Entity>, DeferError> {
                self.__nd_type_default_value(host)
            }
            pub fn to<T: TryFrom<Type, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<Type, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl AnyType {
            fn __ctor(&self) {}
            pub(crate) fn new(arena: &EntityArena) -> Self {
                let __cto1 = AnyType(
                    Type(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Type(
                                        ::std::rc::Rc::new(__data__::__data_Type {
                                            __variant: __data__::__variant_Type::__data_AnyType(
                                                ::std::rc::Rc::new(__data__::__data_AnyType {
                                                    __variant: __data__::__variant_AnyType::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Type::__ctor(&__cto1.0);
                __cto1.__ctor();
                __cto1
            }
            fn __nd_includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                Ok(true)
            }
            fn __nd_includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                Ok(true)
            }
            fn __nd_to_string_1(&self) -> String {
                "*".into()
            }
            pub fn includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_includes_undefined(host)
            }
            pub fn includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                self.__nd_includes_null(host)
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<T: TryFrom<AnyType, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<AnyType, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl VoidType {
            fn __ctor(&self) {}
            pub(crate) fn new(arena: &EntityArena) -> Self {
                let __cto1 = VoidType(
                    Type(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Type(
                                        ::std::rc::Rc::new(__data__::__data_Type {
                                            __variant: __data__::__variant_Type::__data_VoidType(
                                                ::std::rc::Rc::new(__data__::__data_VoidType {
                                                    __variant: __data__::__variant_VoidType::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Type::__ctor(&__cto1.0);
                __cto1.__ctor();
                __cto1
            }
            fn __nd_includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                Ok(true)
            }
            fn __nd_includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                Ok(false)
            }
            fn __nd_to_string_1(&self) -> String {
                "void".into()
            }
            pub fn includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_includes_undefined(host)
            }
            pub fn includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                self.__nd_includes_null(host)
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<T: TryFrom<VoidType, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<VoidType, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl ClassType {
            #[allow(non_snake_case)]
            fn m_name(&self) -> Option<QName> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_name)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_name(&self, v: Option<QName>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_name)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_flags(&self) -> ClassTypeFlags {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_flags)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .get()
            }
            #[allow(non_snake_case)]
            fn set_m_flags(&self, v: ClassTypeFlags) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_flags)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .set(v);
            }
            #[allow(non_snake_case)]
            fn m_type_params(&self) -> Option<SharedArray<Entity>> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_type_params)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_type_params(&self, v: Option<SharedArray<Entity>>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_type_params)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_extends_class(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_extends_class)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_extends_class(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_extends_class)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_implements(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_implements)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_implements(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_implements)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_known_subclasses(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_known_subclasses)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_known_subclasses(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_known_subclasses)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_constructor_method(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_constructor_method)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_constructor_method(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_constructor_method)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_parent(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_parent)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_parent(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_parent)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_private_ns(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_private_ns)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_private_ns(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_private_ns)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_protected_ns(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_protected_ns)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_protected_ns(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_protected_ns)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_static_protected_ns(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_static_protected_ns)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_static_protected_ns(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_static_protected_ns)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_properties(&self) -> Names {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_properties)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_properties(&self, v: Names) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_properties)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_prototype(&self) -> Names {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_prototype)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_prototype(&self, v: Names) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_prototype)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_events(&self) -> SharedMap<String, Event> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_events)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_events(&self, v: SharedMap<String, Event>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_events)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_asdoc(&self) -> Option<Rc<Asdoc>> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_asdoc)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_asdoc(&self, v: Option<Rc<Asdoc>>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_asdoc)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_metadata(&self) -> SharedArray<Rc<Metadata>> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_metadata)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_metadata(&self, v: SharedArray<Rc<Metadata>>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_metadata)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_location(&self) -> Option<Location> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_location(&self, v: Option<Location>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_ClassType(o) = &o.__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, name: QName) {
                self.set_m_name(Some(name));
            }
            pub(crate) fn new(arena: &EntityArena, name: QName) -> Self {
                let __cto1 = ClassType(
                    Type(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Type(
                                        ::std::rc::Rc::new(__data__::__data_Type {
                                            __variant: __data__::__variant_Type::__data_ClassType(
                                                ::std::rc::Rc::new(__data__::__data_ClassType {
                                                    m_asdoc: ::std::cell::RefCell::new(None),
                                                    m_type_params: ::std::cell::RefCell::new(None),
                                                    m_constructor_method: ::std::cell::RefCell::new(None),
                                                    m_location: ::std::cell::RefCell::new(None),
                                                    m_name: ::std::cell::RefCell::new(None),
                                                    m_private_ns: ::std::cell::RefCell::new(None),
                                                    m_properties: ::std::cell::RefCell::new(Names::new()),
                                                    m_flags: ::std::cell::Cell::new(ClassTypeFlags::empty()),
                                                    m_implements: ::std::cell::RefCell::new(SharedArray::new()),
                                                    m_static_protected_ns: ::std::cell::RefCell::new(None),
                                                    m_metadata: ::std::cell::RefCell::new(SharedArray::new()),
                                                    m_parent: ::std::cell::RefCell::new(None),
                                                    m_extends_class: ::std::cell::RefCell::new(None),
                                                    m_prototype: ::std::cell::RefCell::new(Names::new()),
                                                    m_protected_ns: ::std::cell::RefCell::new(None),
                                                    m_known_subclasses: ::std::cell::RefCell::new(
                                                        SharedArray::new(),
                                                    ),
                                                    m_events: ::std::cell::RefCell::new(SharedMap::new()),
                                                    __variant: __data__::__variant_ClassType::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Type::__ctor(&__cto1.0);
                __cto1.__ctor(name);
                __cto1
            }
            fn __nd_is_class_type_possibly_after_sub(&self) -> bool {
                true
            }
            fn __nd_name(&self) -> QName {
                self.m_name().unwrap()
            }
            fn __nd_location(&self) -> Option<Location> {
                self.m_location()
            }
            fn __nd_set_location(&self, loc: Option<Location>) {
                self.set_m_location(loc);
            }
            fn __nd_events(&self) -> SharedMap<String, Event> {
                self.m_events()
            }
            fn __nd_private_ns(&self) -> Option<Entity> {
                self.m_private_ns()
            }
            fn __nd_set_private_ns(&self, ns: Option<Entity>) {
                self.set_m_private_ns(ns);
            }
            fn __nd_protected_ns(&self) -> Option<Entity> {
                self.m_protected_ns()
            }
            fn __nd_set_protected_ns(&self, ns: Option<Entity>) {
                self.set_m_protected_ns(ns);
            }
            fn __nd_static_protected_ns(&self) -> Option<Entity> {
                self.m_static_protected_ns()
            }
            fn __nd_set_static_protected_ns(&self, ns: Option<Entity>) {
                self.set_m_static_protected_ns(ns);
            }
            fn __nd_type_params(&self) -> Option<SharedArray<Entity>> {
                self.m_type_params()
            }
            fn __nd_set_type_params(&self, list: Option<SharedArray<Entity>>) {
                self.set_m_type_params(list);
            }
            fn __nd_is_abstract(&self) -> bool {
                self.m_flags().contains(ClassTypeFlags::IS_ABSTRACT)
            }
            fn __nd_set_is_abstract(&self, value: bool) {
                let mut v = self.m_flags();
                v.set(ClassTypeFlags::IS_ABSTRACT, value);
                self.set_m_flags(v);
            }
            fn __nd_is_final(&self) -> bool {
                self.m_flags().contains(ClassTypeFlags::IS_FINAL)
            }
            fn __nd_set_is_final(&self, value: bool) {
                let mut v = self.m_flags();
                v.set(ClassTypeFlags::IS_FINAL, value);
                self.set_m_flags(v);
            }
            fn __nd_is_static(&self) -> bool {
                self.m_flags().contains(ClassTypeFlags::IS_STATIC)
            }
            fn __nd_set_is_static(&self, value: bool) {
                let mut v = self.m_flags();
                v.set(ClassTypeFlags::IS_STATIC, value);
                self.set_m_flags(v);
            }
            fn __nd_is_dynamic(&self) -> bool {
                self.m_flags().contains(ClassTypeFlags::IS_DYNAMIC)
            }
            fn __nd_set_is_dynamic(&self, value: bool) {
                let mut v = self.m_flags();
                v.set(ClassTypeFlags::IS_DYNAMIC, value);
                self.set_m_flags(v);
            }
            fn __nd_is_dynamic_or_inherits_dynamic(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                if self.is_dynamic() {
                    return Ok(true);
                }
                if let Some(cb) = self.extends_class(host) {
                    cb.is_dynamic_or_inherits_dynamic(host)
                } else {
                    Ok(false)
                }
            }
            fn __nd_is_options_class(&self) -> bool {
                self.m_flags().contains(ClassTypeFlags::IS_OPTIONS_CLASS)
            }
            fn __nd_set_is_options_class(&self, value: bool) {
                let mut v = self.m_flags();
                v.set(ClassTypeFlags::IS_OPTIONS_CLASS, value);
                self.set_m_flags(v);
            }
            fn __nd_known_subclasses(&self) -> SharedArray<Entity> {
                self.m_known_subclasses()
            }
            fn __nd_implements(&self, host: &Database) -> SharedArray<Entity> {
                self.m_implements()
            }
            fn __nd_extends_class(&self, host: &Database) -> Option<Entity> {
                self.m_extends_class()
            }
            fn __nd_set_extends_class(&self, entity: Option<Entity>) {
                self.set_m_extends_class(entity);
            }
            fn __nd_properties(&self, host: &Database) -> Names {
                self.m_properties()
            }
            fn __nd_prototype(&self, host: &Database) -> Names {
                self.m_prototype()
            }
            fn __nd_constructor_method(&self, host: &Database) -> Option<Entity> {
                self.m_constructor_method()
            }
            fn __nd_set_constructor_method(&self, m: Option<Entity>) {
                self.set_m_constructor_method(m);
            }
            fn __nd_parent(&self) -> Option<Entity> {
                self.m_parent()
            }
            fn __nd_set_parent(&self, p: Option<Entity>) {
                self.set_m_parent(p);
            }
            fn __nd_asdoc(&self) -> Option<Rc<Asdoc>> {
                self.m_asdoc()
            }
            fn __nd_set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {
                self.set_m_asdoc(asdoc);
            }
            fn __nd_metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.m_metadata()
            }
            fn __nd_includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                Ok(false)
            }
            fn __nd_includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                Ok(!host.non_null_primitive_types()?.contains(&self.clone().into()))
            }
            fn __nd_to_string_1(&self) -> String {
                let name_1 = self.fully_qualified_name();
                let mut p = String::new();
                if let Some(type_params) = self.type_params() {
                    p = ".<".to_owned()
                        + &type_params
                            .iter()
                            .map(|p| p.to_string())
                            .collect::<Vec<String>>()
                            .join(", ") + ">";
                }
                name_1 + &p
            }
            pub fn is_class_type_possibly_after_sub(&self) -> bool {
                self.__nd_is_class_type_possibly_after_sub()
            }
            pub fn name(&self) -> QName {
                self.__nd_name()
            }
            pub fn location(&self) -> Option<Location> {
                self.__nd_location()
            }
            pub fn set_location(&self, loc: Option<Location>) {
                self.__nd_set_location(loc)
            }
            /// Event mapping from `[Event(name="eventName", type="T")]` meta-data.
            pub fn events(&self) -> SharedMap<String, Event> {
                self.__nd_events()
            }
            pub fn private_ns(&self) -> Option<Entity> {
                self.__nd_private_ns()
            }
            pub fn set_private_ns(&self, ns: Option<Entity>) {
                self.__nd_set_private_ns(ns)
            }
            pub fn protected_ns(&self) -> Option<Entity> {
                self.__nd_protected_ns()
            }
            pub fn set_protected_ns(&self, ns: Option<Entity>) {
                self.__nd_set_protected_ns(ns)
            }
            pub fn static_protected_ns(&self) -> Option<Entity> {
                self.__nd_static_protected_ns()
            }
            pub fn set_static_protected_ns(&self, ns: Option<Entity>) {
                self.__nd_set_static_protected_ns(ns)
            }
            pub fn type_params(&self) -> Option<SharedArray<Entity>> {
                self.__nd_type_params()
            }
            pub fn set_type_params(&self, list: Option<SharedArray<Entity>>) {
                self.__nd_set_type_params(list)
            }
            pub fn is_abstract(&self) -> bool {
                self.__nd_is_abstract()
            }
            pub fn set_is_abstract(&self, value: bool) {
                self.__nd_set_is_abstract(value)
            }
            pub fn is_final(&self) -> bool {
                self.__nd_is_final()
            }
            pub fn set_is_final(&self, value: bool) {
                self.__nd_set_is_final(value)
            }
            pub fn is_static(&self) -> bool {
                self.__nd_is_static()
            }
            pub fn set_is_static(&self, value: bool) {
                self.__nd_set_is_static(value)
            }
            pub fn is_dynamic(&self) -> bool {
                self.__nd_is_dynamic()
            }
            pub fn set_is_dynamic(&self, value: bool) {
                self.__nd_set_is_dynamic(value)
            }
            pub fn is_dynamic_or_inherits_dynamic(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_is_dynamic_or_inherits_dynamic(host)
            }
            /// Whether the class is an `[Options]` class.
            pub fn is_options_class(&self) -> bool {
                self.__nd_is_options_class()
            }
            pub fn set_is_options_class(&self, value: bool) {
                self.__nd_set_is_options_class(value)
            }
            pub fn known_subclasses(&self) -> SharedArray<Entity> {
                self.__nd_known_subclasses()
            }
            /// Includes possibly unresolved.
            pub fn implements(&self, host: &Database) -> SharedArray<Entity> {
                self.__nd_implements(host)
            }
            /// Possibly unresolved.
            pub fn extends_class(&self, host: &Database) -> Option<Entity> {
                self.__nd_extends_class(host)
            }
            pub fn set_extends_class(&self, entity: Option<Entity>) {
                self.__nd_set_extends_class(entity)
            }
            pub fn properties(&self, host: &Database) -> Names {
                self.__nd_properties(host)
            }
            pub fn prototype(&self, host: &Database) -> Names {
                self.__nd_prototype(host)
            }
            pub fn constructor_method(&self, host: &Database) -> Option<Entity> {
                self.__nd_constructor_method(host)
            }
            pub fn set_constructor_method(&self, m: Option<Entity>) {
                self.__nd_set_constructor_method(m)
            }
            pub fn parent(&self) -> Option<Entity> {
                self.__nd_parent()
            }
            pub fn set_parent(&self, p: Option<Entity>) {
                self.__nd_set_parent(p)
            }
            pub fn asdoc(&self) -> Option<Rc<Asdoc>> {
                self.__nd_asdoc()
            }
            pub fn set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {
                self.__nd_set_asdoc(asdoc)
            }
            pub fn metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.__nd_metadata()
            }
            pub fn includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_includes_undefined(host)
            }
            pub fn includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                self.__nd_includes_null(host)
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<T: TryFrom<ClassType, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<ClassType, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl EnumType {
            #[allow(non_snake_case)]
            fn m_name(&self) -> Option<QName> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_name)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_name(&self, v: Option<QName>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_name)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_parent(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_parent)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_parent(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_parent)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_private_ns(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_private_ns)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_private_ns(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_private_ns)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_properties(&self) -> Names {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_properties)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_properties(&self, v: Names) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_properties)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_prototype(&self) -> Names {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_prototype)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_prototype(&self, v: Names) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_prototype)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_number_mapping(&self) -> SharedMap<String, Number> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_number_mapping)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_number_mapping(&self, v: SharedMap<String, Number>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_number_mapping)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_slot_mapping(&self) -> SharedMap<String, Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_slot_mapping)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_slot_mapping(&self, v: SharedMap<String, Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_slot_mapping)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_asdoc(&self) -> Option<Rc<Asdoc>> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_asdoc)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_asdoc(&self, v: Option<Rc<Asdoc>>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_asdoc)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_metadata(&self) -> SharedArray<Rc<Metadata>> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_metadata)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_metadata(&self, v: SharedArray<Rc<Metadata>>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_metadata)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_location(&self) -> Option<Location> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_location(&self, v: Option<Location>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_EnumType(o) = &o.__variant {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, name: QName) {
                self.set_m_name(Some(name));
            }
            pub(crate) fn new(arena: &EntityArena, name: QName) -> Self {
                let __cto1 = EnumType(
                    Type(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Type(
                                        ::std::rc::Rc::new(__data__::__data_Type {
                                            __variant: __data__::__variant_Type::__data_EnumType(
                                                ::std::rc::Rc::new(__data__::__data_EnumType {
                                                    m_name: ::std::cell::RefCell::new(None),
                                                    m_parent: ::std::cell::RefCell::new(None),
                                                    m_metadata: ::std::cell::RefCell::new(SharedArray::new()),
                                                    m_asdoc: ::std::cell::RefCell::new(None),
                                                    m_prototype: ::std::cell::RefCell::new(Names::new()),
                                                    m_private_ns: ::std::cell::RefCell::new(None),
                                                    m_slot_mapping: ::std::cell::RefCell::new(SharedMap::new()),
                                                    m_number_mapping: ::std::cell::RefCell::new(
                                                        SharedMap::new(),
                                                    ),
                                                    m_properties: ::std::cell::RefCell::new(Names::new()),
                                                    m_location: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_EnumType::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Type::__ctor(&__cto1.0);
                __cto1.__ctor(name);
                __cto1
            }
            fn __nd_name(&self) -> QName {
                self.m_name().unwrap()
            }
            fn __nd_enum_member_number_mapping(&self) -> SharedMap<String, Number> {
                self.m_number_mapping()
            }
            fn __nd_enum_member_slot_mapping(&self) -> SharedMap<String, Entity> {
                self.m_slot_mapping()
            }
            fn __nd_location(&self) -> Option<Location> {
                self.m_location()
            }
            fn __nd_set_location(&self, loc: Option<Location>) {
                self.set_m_location(loc);
            }
            fn __nd_private_ns(&self) -> Option<Entity> {
                self.m_private_ns()
            }
            fn __nd_set_private_ns(&self, ns: Option<Entity>) {
                self.set_m_private_ns(ns);
            }
            fn __nd_is_abstract(&self) -> bool {
                false
            }
            fn __nd_is_final(&self) -> bool {
                true
            }
            fn __nd_is_dynamic(&self) -> bool {
                false
            }
            fn __nd_is_options_class(&self) -> bool {
                false
            }
            fn __nd_extends_class(&self, host: &Database) -> Option<Entity> {
                Some(host.object_type())
            }
            fn __nd_properties(&self, host: &Database) -> Names {
                self.m_properties()
            }
            fn __nd_prototype(&self, host: &Database) -> Names {
                self.m_prototype()
            }
            fn __nd_parent(&self) -> Option<Entity> {
                self.m_parent()
            }
            fn __nd_set_parent(&self, p: Option<Entity>) {
                self.set_m_parent(p);
            }
            fn __nd_asdoc(&self) -> Option<Rc<Asdoc>> {
                self.m_asdoc()
            }
            fn __nd_set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {
                self.set_m_asdoc(asdoc);
            }
            fn __nd_metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.m_metadata()
            }
            fn __nd_includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                Ok(false)
            }
            fn __nd_includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                Ok(true)
            }
            fn __nd_to_string_1(&self) -> String {
                self.fully_qualified_name()
            }
            pub fn name(&self) -> QName {
                self.__nd_name()
            }
            /// Mapping from member's String to Number.
            pub fn enum_member_number_mapping(&self) -> SharedMap<String, Number> {
                self.__nd_enum_member_number_mapping()
            }
            /// Mapping from member's String to the static variable slot
            /// used in `properties()`.
            pub fn enum_member_slot_mapping(&self) -> SharedMap<String, Entity> {
                self.__nd_enum_member_slot_mapping()
            }
            pub fn location(&self) -> Option<Location> {
                self.__nd_location()
            }
            pub fn set_location(&self, loc: Option<Location>) {
                self.__nd_set_location(loc)
            }
            pub fn private_ns(&self) -> Option<Entity> {
                self.__nd_private_ns()
            }
            pub fn set_private_ns(&self, ns: Option<Entity>) {
                self.__nd_set_private_ns(ns)
            }
            pub fn is_abstract(&self) -> bool {
                self.__nd_is_abstract()
            }
            pub fn is_final(&self) -> bool {
                self.__nd_is_final()
            }
            pub fn is_dynamic(&self) -> bool {
                self.__nd_is_dynamic()
            }
            pub fn is_options_class(&self) -> bool {
                self.__nd_is_options_class()
            }
            /// Possibly unresolved.
            pub fn extends_class(&self, host: &Database) -> Option<Entity> {
                self.__nd_extends_class(host)
            }
            pub fn properties(&self, host: &Database) -> Names {
                self.__nd_properties(host)
            }
            pub fn prototype(&self, host: &Database) -> Names {
                self.__nd_prototype(host)
            }
            pub fn parent(&self) -> Option<Entity> {
                self.__nd_parent()
            }
            pub fn set_parent(&self, p: Option<Entity>) {
                self.__nd_set_parent(p)
            }
            pub fn asdoc(&self) -> Option<Rc<Asdoc>> {
                self.__nd_asdoc()
            }
            pub fn set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {
                self.__nd_set_asdoc(asdoc)
            }
            pub fn metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.__nd_metadata()
            }
            pub fn includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_includes_undefined(host)
            }
            pub fn includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                self.__nd_includes_null(host)
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<T: TryFrom<EnumType, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<EnumType, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl InterfaceType {
            #[allow(non_snake_case)]
            fn m_name(&self) -> Option<QName> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_name)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_name(&self, v: Option<QName>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_name)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_type_params(&self) -> Option<SharedArray<Entity>> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_type_params)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_type_params(&self, v: Option<SharedArray<Entity>>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_type_params)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_events(&self) -> SharedMap<String, Event> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_events)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_events(&self, v: SharedMap<String, Event>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_events)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_extends_interfaces(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_extends_interfaces)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_extends_interfaces(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_extends_interfaces)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_known_implementors(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_known_implementors)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_known_implementors(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_known_implementors)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_parent(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_parent)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_parent(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_parent)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_prototype(&self) -> Names {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_prototype)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_prototype(&self, v: Names) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_prototype)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_asdoc(&self) -> Option<Rc<Asdoc>> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_asdoc)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_asdoc(&self, v: Option<Rc<Asdoc>>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_asdoc)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_metadata(&self) -> SharedArray<Rc<Metadata>> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_metadata)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_metadata(&self, v: SharedArray<Rc<Metadata>>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_metadata)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_location(&self) -> Option<Location> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_location(&self, v: Option<Location>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_InterfaceType(o) = &o
                        .__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, name: QName) {
                self.set_m_name(Some(name));
            }
            pub(crate) fn new(arena: &EntityArena, name: QName) -> Self {
                let __cto1 = InterfaceType(
                    Type(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Type(
                                        ::std::rc::Rc::new(__data__::__data_Type {
                                            __variant: __data__::__variant_Type::__data_InterfaceType(
                                                ::std::rc::Rc::new(__data__::__data_InterfaceType {
                                                    m_extends_interfaces: ::std::cell::RefCell::new(
                                                        SharedArray::new(),
                                                    ),
                                                    m_parent: ::std::cell::RefCell::new(None),
                                                    m_prototype: ::std::cell::RefCell::new(Names::new()),
                                                    m_metadata: ::std::cell::RefCell::new(SharedArray::new()),
                                                    m_location: ::std::cell::RefCell::new(None),
                                                    m_asdoc: ::std::cell::RefCell::new(None),
                                                    m_name: ::std::cell::RefCell::new(None),
                                                    m_type_params: ::std::cell::RefCell::new(None),
                                                    m_known_implementors: ::std::cell::RefCell::new(
                                                        SharedArray::new(),
                                                    ),
                                                    m_events: ::std::cell::RefCell::new(SharedMap::new()),
                                                    __variant: __data__::__variant_InterfaceType::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Type::__ctor(&__cto1.0);
                __cto1.__ctor(name);
                __cto1
            }
            fn __nd_is_interface_type_possibly_after_sub(&self) -> bool {
                true
            }
            fn __nd_name(&self) -> QName {
                self.m_name().unwrap()
            }
            fn __nd_location(&self) -> Option<Location> {
                self.m_location()
            }
            fn __nd_set_location(&self, loc: Option<Location>) {
                self.set_m_location(loc);
            }
            fn __nd_type_params(&self) -> Option<SharedArray<Entity>> {
                self.m_type_params()
            }
            fn __nd_set_type_params(&self, list: Option<SharedArray<Entity>>) {
                self.set_m_type_params(list);
            }
            fn __nd_events(&self) -> SharedMap<String, Event> {
                self.m_events()
            }
            fn __nd_known_implementors(&self) -> SharedArray<Entity> {
                self.m_known_implementors()
            }
            fn __nd_extends_interfaces(&self, host: &Database) -> SharedArray<Entity> {
                self.m_extends_interfaces()
            }
            fn __nd_prototype(&self, host: &Database) -> Names {
                self.m_prototype()
            }
            fn __nd_parent(&self) -> Option<Entity> {
                self.m_parent()
            }
            fn __nd_set_parent(&self, p: Option<Entity>) {
                self.set_m_parent(p);
            }
            fn __nd_asdoc(&self) -> Option<Rc<Asdoc>> {
                self.m_asdoc()
            }
            fn __nd_set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {
                self.set_m_asdoc(asdoc);
            }
            fn __nd_metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.m_metadata()
            }
            fn __nd_includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                Ok(false)
            }
            fn __nd_includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                Ok(true)
            }
            fn __nd_to_string_1(&self) -> String {
                let name_1 = self.fully_qualified_name();
                let mut p = String::new();
                if let Some(type_params) = self.type_params() {
                    p = ".<".to_owned()
                        + &type_params
                            .iter()
                            .map(|p| p.to_string())
                            .collect::<Vec<String>>()
                            .join(", ") + ">";
                }
                name_1 + &p
            }
            pub fn is_interface_type_possibly_after_sub(&self) -> bool {
                self.__nd_is_interface_type_possibly_after_sub()
            }
            pub fn name(&self) -> QName {
                self.__nd_name()
            }
            pub fn location(&self) -> Option<Location> {
                self.__nd_location()
            }
            pub fn set_location(&self, loc: Option<Location>) {
                self.__nd_set_location(loc)
            }
            pub fn type_params(&self) -> Option<SharedArray<Entity>> {
                self.__nd_type_params()
            }
            pub fn set_type_params(&self, list: Option<SharedArray<Entity>>) {
                self.__nd_set_type_params(list)
            }
            /// Event mapping from `[Event(name="eventName", type="T")]` meta-data.
            pub fn events(&self) -> SharedMap<String, Event> {
                self.__nd_events()
            }
            pub fn known_implementors(&self) -> SharedArray<Entity> {
                self.__nd_known_implementors()
            }
            /// Includes possibly unresolved.
            pub fn extends_interfaces(&self, host: &Database) -> SharedArray<Entity> {
                self.__nd_extends_interfaces(host)
            }
            pub fn prototype(&self, host: &Database) -> Names {
                self.__nd_prototype(host)
            }
            pub fn parent(&self) -> Option<Entity> {
                self.__nd_parent()
            }
            pub fn set_parent(&self, p: Option<Entity>) {
                self.__nd_set_parent(p)
            }
            pub fn asdoc(&self) -> Option<Rc<Asdoc>> {
                self.__nd_asdoc()
            }
            pub fn set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {
                self.__nd_set_asdoc(asdoc)
            }
            pub fn metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.__nd_metadata()
            }
            pub fn includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_includes_undefined(host)
            }
            pub fn includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                self.__nd_includes_null(host)
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<InterfaceType, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<InterfaceType, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl TypeAfterSubstitution {
            #[allow(non_snake_case)]
            fn m_origin(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_origin)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_origin(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_origin)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_substitute_types(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_substitute_types)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_substitute_types(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_substitute_types)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_extends_class(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_extends_class)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_extends_class(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_extends_class)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_implements(&self) -> Option<SharedArray<Entity>> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_implements)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_implements(&self, v: Option<SharedArray<Entity>>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_implements)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_extends_interfaces(&self) -> Option<SharedArray<Entity>> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_extends_interfaces)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_extends_interfaces(&self, v: Option<SharedArray<Entity>>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_extends_interfaces)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_properties(&self) -> Option<Names> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_properties)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_properties(&self, v: Option<Names>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_properties)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_prototype(&self) -> Option<Names> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_prototype)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_prototype(&self, v: Option<Names>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_prototype)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_constructor_method(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_constructor_method)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_constructor_method(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeAfterSubstitution(o) = &o
                        .__variant
                    {
                        (&o.m_constructor_method)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, origin: Entity, substitute_types: SharedArray<Entity>) {
                self.set_m_origin(Some(origin));
                self.set_m_substitute_types(substitute_types);
            }
            pub(crate) fn new(
                arena: &EntityArena,
                origin: Entity,
                substitute_types: SharedArray<Entity>,
            ) -> Self {
                let __cto1 = TypeAfterSubstitution(
                    Type(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Type(
                                        ::std::rc::Rc::new(__data__::__data_Type {
                                            __variant: __data__::__variant_Type::__data_TypeAfterSubstitution(
                                                ::std::rc::Rc::new(__data__::__data_TypeAfterSubstitution {
                                                    m_origin: ::std::cell::RefCell::new(None),
                                                    m_implements: ::std::cell::RefCell::new(None),
                                                    m_properties: ::std::cell::RefCell::new(None),
                                                    m_prototype: ::std::cell::RefCell::new(None),
                                                    m_substitute_types: ::std::cell::RefCell::new(
                                                        SharedArray::new(),
                                                    ),
                                                    m_extends_class: ::std::cell::RefCell::new(None),
                                                    m_constructor_method: ::std::cell::RefCell::new(None),
                                                    m_extends_interfaces: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_TypeAfterSubstitution::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Type::__ctor(&__cto1.0);
                __cto1.__ctor(origin, substitute_types);
                __cto1
            }
            fn __nd_is_class_type_possibly_after_sub(&self) -> bool {
                self.origin().is_class_type_possibly_after_sub()
            }
            fn __nd_is_interface_type_possibly_after_sub(&self) -> bool {
                self.origin().is_interface_type_possibly_after_sub()
            }
            fn __nd_origin(&self) -> Entity {
                self.m_origin().unwrap()
            }
            fn __nd_substitute_types(&self) -> SharedArray<Entity> {
                self.m_substitute_types()
            }
            fn __nd_name(&self) -> QName {
                self.origin().name()
            }
            fn __nd_events(&self) -> SharedMap<String, Event> {
                self.origin().events()
            }
            fn __nd_is_abstract(&self) -> bool {
                self.origin().is_abstract()
            }
            fn __nd_is_static(&self) -> bool {
                self.origin().is_static()
            }
            fn __nd_is_final(&self) -> bool {
                self.origin().is_final()
            }
            fn __nd_is_dynamic(&self) -> bool {
                self.origin().is_dynamic()
            }
            fn __nd_is_dynamic_or_inherits_dynamic(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.origin().is_dynamic_or_inherits_dynamic(host)
            }
            fn __nd_is_options_class(&self) -> bool {
                self.origin().is_options_class()
            }
            fn __nd_extends_class(&self, host: &Database) -> Option<Entity> {
                if let Some(r) = self.m_extends_class() {
                    return Some(r.clone());
                }
                let origin = self.origin();
                let r = origin.extends_class(host);
                if r.is_none() {
                    return None;
                }
                let r = r.unwrap();
                if r.is::<UnresolvedEntity>() {
                    return Some(r.clone());
                }
                let r = ApplyType(host)
                    .exec(
                        &r,
                        &origin.type_params().unwrap(),
                        &self.m_substitute_types(),
                    );
                self.set_m_extends_class(Some(r.clone()));
                Some(r)
            }
            fn __nd_implements(&self, host: &Database) -> SharedArray<Entity> {
                if let Some(r) = self.m_implements() {
                    return r;
                }
                let origin = self.origin();
                let r: SharedArray<Entity> = origin
                    .implements(host)
                    .iter()
                    .map(|t| {
                        ApplyType(host)
                            .exec(
                                &t,
                                &origin.type_params().unwrap(),
                                &self.m_substitute_types(),
                            )
                    })
                    .collect();
                self.set_m_implements(Some(r.clone()));
                r
            }
            fn __nd_extends_interfaces(&self, host: &Database) -> SharedArray<Entity> {
                if let Some(r) = self.m_extends_interfaces() {
                    return r;
                }
                let origin = self.origin();
                let r: SharedArray<Entity> = origin
                    .extends_interfaces(host)
                    .iter()
                    .map(|t| {
                        ApplyType(host)
                            .exec(
                                &t,
                                &origin.type_params().unwrap(),
                                &self.m_substitute_types(),
                            )
                    })
                    .collect();
                self.set_m_extends_interfaces(Some(r.clone()));
                r
            }
            fn __nd_prototype(&self, host: &Database) -> Names {
                if let Some(r) = self.m_prototype() {
                    return r;
                }
                let origin = self.origin();
                let mut r = Names::new();
                for (name, entity) in origin.prototype(host).borrow().iter() {
                    let entity = ApplyType(host)
                        .exec(
                            &entity,
                            &origin.type_params().unwrap(),
                            &self.m_substitute_types(),
                        );
                    r.set(name.clone(), entity)
                }
                self.set_m_prototype(Some(r.clone()));
                r
            }
            fn __nd_properties(&self, host: &Database) -> Names {
                if let Some(r) = self.m_properties() {
                    return r;
                }
                let origin = self.origin();
                let mut r = Names::new();
                for (name, entity) in origin.properties(host).borrow().iter() {
                    let entity = ApplyType(host)
                        .exec(
                            &entity,
                            &origin.type_params().unwrap(),
                            &self.m_substitute_types(),
                        );
                    r.set(name.clone(), entity)
                }
                self.set_m_properties(Some(r.clone()));
                r
            }
            fn __nd_constructor_method(&self, host: &Database) -> Option<Entity> {
                if let Some(r) = self.m_constructor_method() {
                    return Some(r.clone());
                }
                let origin = self.origin();
                let r = origin.constructor_method(host);
                if r.is_none() {
                    return None;
                }
                let r = r.unwrap();
                let r = ApplyType(host)
                    .exec(
                        &r,
                        &origin.type_params().unwrap(),
                        &self.m_substitute_types(),
                    );
                self.set_m_constructor_method(Some(r.clone()));
                Some(r)
            }
            fn __nd_parent(&self) -> Option<Entity> {
                self.origin().parent()
            }
            fn __nd_asdoc(&self) -> Option<Rc<Asdoc>> {
                self.origin().asdoc()
            }
            fn __nd_metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.origin().metadata()
            }
            fn __nd_includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                Ok(false)
            }
            fn __nd_includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                Ok(true)
            }
            fn __nd_location(&self) -> Option<Location> {
                None
            }
            fn __nd_to_string_1(&self) -> String {
                let name_1 = self.fully_qualified_name();
                let a = self.m_substitute_types();
                let p = ".<".to_owned()
                    + &a
                        .iter()
                        .map(|a| a.to_string())
                        .collect::<Vec<String>>()
                        .join(", ") + ">";
                name_1 + &p
            }
            pub fn is_class_type_possibly_after_sub(&self) -> bool {
                self.__nd_is_class_type_possibly_after_sub()
            }
            pub fn is_interface_type_possibly_after_sub(&self) -> bool {
                self.__nd_is_interface_type_possibly_after_sub()
            }
            pub fn origin(&self) -> Entity {
                self.__nd_origin()
            }
            pub fn substitute_types(&self) -> SharedArray<Entity> {
                self.__nd_substitute_types()
            }
            pub fn name(&self) -> QName {
                self.__nd_name()
            }
            pub fn events(&self) -> SharedMap<String, Event> {
                self.__nd_events()
            }
            pub fn is_abstract(&self) -> bool {
                self.__nd_is_abstract()
            }
            pub fn is_static(&self) -> bool {
                self.__nd_is_static()
            }
            pub fn is_final(&self) -> bool {
                self.__nd_is_final()
            }
            pub fn is_dynamic(&self) -> bool {
                self.__nd_is_dynamic()
            }
            pub fn is_dynamic_or_inherits_dynamic(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_is_dynamic_or_inherits_dynamic(host)
            }
            pub fn is_options_class(&self) -> bool {
                self.__nd_is_options_class()
            }
            /// Possibly unresolved.
            pub fn extends_class(&self, host: &Database) -> Option<Entity> {
                self.__nd_extends_class(host)
            }
            /// Includes possibly unresolved.
            pub fn implements(&self, host: &Database) -> SharedArray<Entity> {
                self.__nd_implements(host)
            }
            /// Includes possibly unresolved.
            pub fn extends_interfaces(&self, host: &Database) -> SharedArray<Entity> {
                self.__nd_extends_interfaces(host)
            }
            pub fn prototype(&self, host: &Database) -> Names {
                self.__nd_prototype(host)
            }
            pub fn properties(&self, host: &Database) -> Names {
                self.__nd_properties(host)
            }
            pub fn constructor_method(&self, host: &Database) -> Option<Entity> {
                self.__nd_constructor_method(host)
            }
            pub fn parent(&self) -> Option<Entity> {
                self.__nd_parent()
            }
            pub fn asdoc(&self) -> Option<Rc<Asdoc>> {
                self.__nd_asdoc()
            }
            pub fn metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.__nd_metadata()
            }
            pub fn includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_includes_undefined(host)
            }
            pub fn includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                self.__nd_includes_null(host)
            }
            pub fn location(&self) -> Option<Location> {
                self.__nd_location()
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<
                        TypeAfterSubstitution,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        TypeAfterSubstitution,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl TupleType {
            #[allow(non_snake_case)]
            fn m_elements(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TupleType(o) = &o.__variant
                    {
                        (&o.m_elements)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_elements(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TupleType(o) = &o.__variant
                    {
                        (&o.m_elements)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, elements: SharedArray<Entity>) {
                self.set_m_elements(elements);
            }
            pub(crate) fn new(
                arena: &EntityArena,
                elements: SharedArray<Entity>,
            ) -> Self {
                let __cto1 = TupleType(
                    Type(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Type(
                                        ::std::rc::Rc::new(__data__::__data_Type {
                                            __variant: __data__::__variant_Type::__data_TupleType(
                                                ::std::rc::Rc::new(__data__::__data_TupleType {
                                                    m_elements: ::std::cell::RefCell::new(SharedArray::new()),
                                                    __variant: __data__::__variant_TupleType::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Type::__ctor(&__cto1.0);
                __cto1.__ctor(elements);
                __cto1
            }
            fn __nd_element_types(&self) -> SharedArray<Entity> {
                self.m_elements()
            }
            fn __nd_is_abstract(&self) -> bool {
                false
            }
            fn __nd_is_final(&self) -> bool {
                true
            }
            fn __nd_is_dynamic(&self) -> bool {
                true
            }
            fn __nd_is_dynamic_or_inherits_dynamic(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                Ok(self.is_dynamic())
            }
            fn __nd_is_options_class(&self) -> bool {
                false
            }
            fn __nd_extends_class(&self, host: &Database) -> Option<Entity> {
                Some(host.array_type_of_any().unwrap_or(host.unresolved_entity()))
            }
            fn __nd_includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                Ok(false)
            }
            fn __nd_includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                Ok(true)
            }
            fn __nd_to_string_1(&self) -> String {
                ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "[{0}]",
                            self
                                .element_types()
                                .iter()
                                .map(|e| e.to_string())
                                .collect::<Vec<String>>()
                                .join(", "),
                        ),
                    );
                    res
                })
            }
            pub fn element_types(&self) -> SharedArray<Entity> {
                self.__nd_element_types()
            }
            pub fn is_abstract(&self) -> bool {
                self.__nd_is_abstract()
            }
            pub fn is_final(&self) -> bool {
                self.__nd_is_final()
            }
            pub fn is_dynamic(&self) -> bool {
                self.__nd_is_dynamic()
            }
            pub fn is_dynamic_or_inherits_dynamic(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_is_dynamic_or_inherits_dynamic(host)
            }
            pub fn is_options_class(&self) -> bool {
                self.__nd_is_options_class()
            }
            /// Possibly unresolved.
            pub fn extends_class(&self, host: &Database) -> Option<Entity> {
                self.__nd_extends_class(host)
            }
            pub fn includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_includes_undefined(host)
            }
            pub fn includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                self.__nd_includes_null(host)
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<T: TryFrom<TupleType, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<TupleType, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl FunctionType {
            #[allow(non_snake_case)]
            fn m_params(&self) -> SharedArray<Rc<SemanticFunctionTypeParameter>> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_FunctionType(o) = &o
                        .__variant
                    {
                        (&o.m_params)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_params(&self, v: SharedArray<Rc<SemanticFunctionTypeParameter>>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_FunctionType(o) = &o
                        .__variant
                    {
                        (&o.m_params)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_result_type(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_FunctionType(o) = &o
                        .__variant
                    {
                        (&o.m_result_type)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_result_type(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_FunctionType(o) = &o
                        .__variant
                    {
                        (&o.m_result_type)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(
                &self,
                params: SharedArray<Rc<SemanticFunctionTypeParameter>>,
                result_type: Entity,
            ) {
                self.set_m_params(params);
                self.set_m_result_type(Some(result_type));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                params: SharedArray<Rc<SemanticFunctionTypeParameter>>,
                result_type: Entity,
            ) -> Self {
                let __cto1 = FunctionType(
                    Type(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Type(
                                        ::std::rc::Rc::new(__data__::__data_Type {
                                            __variant: __data__::__variant_Type::__data_FunctionType(
                                                ::std::rc::Rc::new(__data__::__data_FunctionType {
                                                    m_params: ::std::cell::RefCell::new(SharedArray::new()),
                                                    m_result_type: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_FunctionType::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Type::__ctor(&__cto1.0);
                __cto1.__ctor(params, result_type);
                __cto1
            }
            fn __nd_params(&self) -> SharedArray<Rc<SemanticFunctionTypeParameter>> {
                self.m_params()
            }
            fn __nd_result_type(&self) -> Entity {
                self.m_result_type().unwrap()
            }
            fn __nd_is_abstract(&self) -> bool {
                false
            }
            fn __nd_is_final(&self) -> bool {
                true
            }
            fn __nd_is_dynamic(&self) -> bool {
                false
            }
            fn __nd_is_dynamic_or_inherits_dynamic(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                Ok(self.is_dynamic())
            }
            fn __nd_is_options_class(&self) -> bool {
                false
            }
            fn __nd_extends_class(&self, host: &Database) -> Option<Entity> {
                Some(host.function_type())
            }
            fn __nd_includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                Ok(false)
            }
            fn __nd_includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                Ok(true)
            }
            fn __nd_to_string_1(&self) -> String {
                let mut p = Vec::<String>::new();
                for p1 in self.params().iter() {
                    match p1.kind {
                        ParameterKind::Required => {
                            p.push(p1.static_type.to_string());
                        }
                        ParameterKind::Optional => {
                            p.push(p1.static_type.to_string() + &"=".to_owned());
                        }
                        ParameterKind::Rest => {
                            p.push("...".to_owned() + &p1.static_type.to_string());
                        }
                    }
                }
                ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "function({0}) : {1}",
                            p.join(", "),
                            self.result_type().to_string(),
                        ),
                    );
                    res
                })
            }
            pub fn params(&self) -> SharedArray<Rc<SemanticFunctionTypeParameter>> {
                self.__nd_params()
            }
            pub fn result_type(&self) -> Entity {
                self.__nd_result_type()
            }
            pub fn is_abstract(&self) -> bool {
                self.__nd_is_abstract()
            }
            pub fn is_final(&self) -> bool {
                self.__nd_is_final()
            }
            pub fn is_dynamic(&self) -> bool {
                self.__nd_is_dynamic()
            }
            pub fn is_dynamic_or_inherits_dynamic(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_is_dynamic_or_inherits_dynamic(host)
            }
            pub fn is_options_class(&self) -> bool {
                self.__nd_is_options_class()
            }
            /// Possibly unresolved.
            pub fn extends_class(&self, host: &Database) -> Option<Entity> {
                self.__nd_extends_class(host)
            }
            pub fn includes_undefined(
                &self,
                host: &Database,
            ) -> Result<bool, DeferError> {
                self.__nd_includes_undefined(host)
            }
            pub fn includes_null(&self, host: &Database) -> Result<bool, DeferError> {
                self.__nd_includes_null(host)
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<FunctionType, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<FunctionType, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl NullableType {
            #[allow(non_snake_case)]
            fn m_base(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_NullableType(o) = &o
                        .__variant
                    {
                        (&o.m_base)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_base(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_NullableType(o) = &o
                        .__variant
                    {
                        (&o.m_base)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, base: Entity) {
                self.set_m_base(Some(base));
            }
            pub(crate) fn new(arena: &EntityArena, base: Entity) -> Self {
                let __cto1 = NullableType(
                    Type(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Type(
                                        ::std::rc::Rc::new(__data__::__data_Type {
                                            __variant: __data__::__variant_Type::__data_NullableType(
                                                ::std::rc::Rc::new(__data__::__data_NullableType {
                                                    m_base: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_NullableType::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Type::__ctor(&__cto1.0);
                __cto1.__ctor(base);
                __cto1
            }
            fn __nd_base(&self) -> Entity {
                self.m_base().unwrap()
            }
            fn __nd_includes_undefined(&self) -> Result<bool, DeferError> {
                Ok(false)
            }
            fn __nd_includes_null(&self) -> Result<bool, DeferError> {
                Ok(true)
            }
            fn __nd_escape_of_nullable(&self) -> Entity {
                self.base()
            }
            fn __nd_escape_of_nullable_or_non_nullable(&self) -> Entity {
                self.base()
            }
            fn __nd_to_string_1(&self) -> String {
                if let Ok(ft) = self.base().to::<FunctionType>() {
                    ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!("?{0}", ft.to_string()),
                        );
                        res
                    })
                } else {
                    ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!("{0}?", self.base().to_string()),
                        );
                        res
                    })
                }
            }
            /// The type that is made nullable.
            pub fn base(&self) -> Entity {
                self.__nd_base()
            }
            pub fn includes_undefined(&self) -> Result<bool, DeferError> {
                self.__nd_includes_undefined()
            }
            pub fn includes_null(&self) -> Result<bool, DeferError> {
                self.__nd_includes_null()
            }
            /// Escapes out of a nullable type layer.
            pub fn escape_of_nullable(&self) -> Entity {
                self.__nd_escape_of_nullable()
            }
            pub fn escape_of_nullable_or_non_nullable(&self) -> Entity {
                self.__nd_escape_of_nullable_or_non_nullable()
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<NullableType, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<NullableType, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl NonNullableType {
            #[allow(non_snake_case)]
            fn m_base(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_NonNullableType(o) = &o
                        .__variant
                    {
                        (&o.m_base)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_base(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_NonNullableType(o) = &o
                        .__variant
                    {
                        (&o.m_base)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, base: Entity) {
                self.set_m_base(Some(base));
            }
            pub(crate) fn new(arena: &EntityArena, base: Entity) -> Self {
                let __cto1 = NonNullableType(
                    Type(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Type(
                                        ::std::rc::Rc::new(__data__::__data_Type {
                                            __variant: __data__::__variant_Type::__data_NonNullableType(
                                                ::std::rc::Rc::new(__data__::__data_NonNullableType {
                                                    m_base: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_NonNullableType::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Type::__ctor(&__cto1.0);
                __cto1.__ctor(base);
                __cto1
            }
            fn __nd_base(&self) -> Entity {
                self.m_base().unwrap()
            }
            fn __nd_includes_undefined(&self) -> Result<bool, DeferError> {
                Ok(false)
            }
            fn __nd_includes_null(&self) -> Result<bool, DeferError> {
                Ok(false)
            }
            fn __nd_escape_of_non_nullable(&self) -> Entity {
                self.base()
            }
            fn __nd_escape_of_nullable_or_non_nullable(&self) -> Entity {
                self.base()
            }
            fn __nd_to_string_1(&self) -> String {
                if let Ok(ft) = self.base().to::<FunctionType>() {
                    ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!("({0})!", ft.to_string()),
                        );
                        res
                    })
                } else {
                    ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!("{0}!", self.base().to_string()),
                        );
                        res
                    })
                }
            }
            /// The type that is made non-nullable.
            pub fn base(&self) -> Entity {
                self.__nd_base()
            }
            pub fn includes_undefined(&self) -> Result<bool, DeferError> {
                self.__nd_includes_undefined()
            }
            pub fn includes_null(&self) -> Result<bool, DeferError> {
                self.__nd_includes_null()
            }
            /// Escapes out of a non nullable type layer.
            pub fn escape_of_non_nullable(&self) -> Entity {
                self.__nd_escape_of_non_nullable()
            }
            pub fn escape_of_nullable_or_non_nullable(&self) -> Entity {
                self.__nd_escape_of_nullable_or_non_nullable()
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<NonNullableType, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<NonNullableType, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl TypeParameterType {
            #[allow(non_snake_case)]
            fn m_name(&self) -> Option<QName> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeParameterType(o) = &o
                        .__variant
                    {
                        (&o.m_name)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_name(&self, v: Option<QName>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeParameterType(o) = &o
                        .__variant
                    {
                        (&o.m_name)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_location(&self) -> Option<Location> {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeParameterType(o) = &o
                        .__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_location(&self, v: Option<Location>) {
                (if let __data__::__variant_Entity::__data_Type(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Type::__data_TypeParameterType(o) = &o
                        .__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, name: QName) {
                self.set_m_name(Some(name));
            }
            pub(crate) fn new(arena: &EntityArena, name: QName) -> Self {
                let __cto1 = TypeParameterType(
                    Type(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Type(
                                        ::std::rc::Rc::new(__data__::__data_Type {
                                            __variant: __data__::__variant_Type::__data_TypeParameterType(
                                                ::std::rc::Rc::new(__data__::__data_TypeParameterType {
                                                    m_location: ::std::cell::RefCell::new(None),
                                                    m_name: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_TypeParameterType::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Type::__ctor(&__cto1.0);
                __cto1.__ctor(name);
                __cto1
            }
            fn __nd_name(&self) -> QName {
                self.m_name().unwrap()
            }
            fn __nd_location(&self) -> Option<Location> {
                self.m_location()
            }
            fn __nd_set_location(&self, loc: Option<Location>) {
                self.set_m_location(loc);
            }
            fn __nd_includes_undefined(&self) -> Result<bool, DeferError> {
                Ok(false)
            }
            fn __nd_includes_null(&self) -> Result<bool, DeferError> {
                Ok(false)
            }
            fn __nd_to_string_1(&self) -> String {
                self.name().to_string()
            }
            pub fn name(&self) -> QName {
                self.__nd_name()
            }
            pub fn location(&self) -> Option<Location> {
                self.__nd_location()
            }
            pub fn set_location(&self, loc: Option<Location>) {
                self.__nd_set_location(loc)
            }
            pub fn includes_undefined(&self) -> Result<bool, DeferError> {
                self.__nd_includes_undefined()
            }
            pub fn includes_null(&self) -> Result<bool, DeferError> {
                self.__nd_includes_null()
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<TypeParameterType, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<TypeParameterType, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl VariableSlot {
            fn __ctor(&self) {}
            fn new(arena: &EntityArena) -> Self {
                let __cto1 = VariableSlot(
                    Entity(
                        arena
                            .allocate(__data__::__data_Entity {
                                __variant: __data__::__variant_Entity::__data_VariableSlot(
                                    ::std::rc::Rc::new(__data__::__data_VariableSlot {
                                        __variant: __data__::__variant_VariableSlot::__Nothing,
                                    }),
                                ),
                            })
                            .clone(),
                    ),
                );
                Entity::__ctor(&__cto1.0);
                __cto1.__ctor();
                __cto1
            }
            fn __nd_property_static_type(&self, host: &Database) -> Entity {
                self.static_type(host)
            }
            /// Returns the static type of a property, whether for a type, variable, virtual or method slot or namespace,
            /// or act as identity of a value's static type.
            /// Possibly `UnresolvedEntity`.
            pub fn property_static_type(&self, host: &Database) -> Entity {
                self.__nd_property_static_type(host)
            }
            pub fn to<
                T: TryFrom<VariableSlot, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<VariableSlot, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl OriginalVariableSlot {
            #[allow(non_snake_case)]
            fn m_name(&self) -> Option<QName> {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_name)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_name(&self, v: Option<QName>) {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_name)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_location(&self) -> Option<Location> {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_location(&self, v: Option<Location>) {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_asdoc(&self) -> Option<Rc<Asdoc>> {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_asdoc)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_asdoc(&self, v: Option<Rc<Asdoc>>) {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_asdoc)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_metadata(&self) -> SharedArray<Rc<Metadata>> {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_metadata)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_metadata(&self, v: SharedArray<Rc<Metadata>>) {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_metadata)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_constant(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_constant)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_constant(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_constant)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_static_type(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_static_type)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_static_type(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_static_type)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_parent(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_parent)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_parent(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_parent)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_flags(&self) -> VariableSlotFlags {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_flags)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .get()
            }
            #[allow(non_snake_case)]
            fn set_m_flags(&self, v: VariableSlotFlags) {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_flags)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .set(v);
            }
            #[allow(non_snake_case)]
            fn m_bindable_event(&self) -> Option<String> {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_bindable_event)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_bindable_event(&self, v: Option<String>) {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_bindable_event)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, name: &QName, read_only: bool, static_type: &Entity) {
                self.set_m_name(Some(name.clone()));
                self.set_read_only(read_only);
                self.set_m_static_type(Some(static_type.clone()));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                name: &QName,
                read_only: bool,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = OriginalVariableSlot(
                    VariableSlot(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_VariableSlot(
                                        ::std::rc::Rc::new(__data__::__data_VariableSlot {
                                            __variant: __data__::__variant_VariableSlot::__data_OriginalVariableSlot(
                                                ::std::rc::Rc::new(__data__::__data_OriginalVariableSlot {
                                                    m_constant: ::std::cell::RefCell::new(None),
                                                    m_name: ::std::cell::RefCell::new(None),
                                                    m_bindable_event: ::std::cell::RefCell::new(None),
                                                    m_parent: ::std::cell::RefCell::new(None),
                                                    m_location: ::std::cell::RefCell::new(None),
                                                    m_static_type: ::std::cell::RefCell::new(None),
                                                    m_asdoc: ::std::cell::RefCell::new(None),
                                                    m_metadata: ::std::cell::RefCell::new(SharedArray::new()),
                                                    m_flags: ::std::cell::Cell::new(VariableSlotFlags::empty()),
                                                    __variant: __data__::__variant_OriginalVariableSlot::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                VariableSlot::__ctor(&__cto1.0);
                __cto1.__ctor(name, read_only, static_type);
                __cto1
            }
            fn __nd_name(&self) -> QName {
                self.m_name().unwrap()
            }
            fn __nd_var_constant(&self) -> Option<Entity> {
                self.m_constant()
            }
            fn __nd_set_var_constant(&self, k: Option<Entity>) {
                self.set_m_constant(k);
            }
            fn __nd_read_only(&self, host: &Database) -> bool {
                self.m_flags().contains(VariableSlotFlags::READ_ONLY)
            }
            fn __nd_set_read_only(&self, value: bool) {
                let mut v = self.m_flags();
                v.set(VariableSlotFlags::READ_ONLY, value);
                self.set_m_flags(v);
            }
            fn __nd_write_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_static_type(&self, host: &Database) -> Entity {
                self.m_static_type().unwrap()
            }
            fn __nd_set_static_type(&self, value: Entity) {
                self.set_m_static_type(Some(value));
            }
            fn __nd_location(&self) -> Option<Location> {
                self.m_location()
            }
            fn __nd_set_location(&self, loc: Option<Location>) {
                self.set_m_location(loc);
            }
            fn __nd_bindable_event(&self) -> Option<String> {
                self.m_bindable_event()
            }
            fn __nd_set_bindable_event(&self, name: Option<String>) {
                self.set_m_bindable_event(name);
            }
            fn __nd_parent(&self) -> Option<Entity> {
                self.m_parent()
            }
            fn __nd_set_parent(&self, p: Option<Entity>) {
                self.set_m_parent(p);
            }
            fn __nd_asdoc(&self) -> Option<Rc<Asdoc>> {
                self.m_asdoc()
            }
            fn __nd_set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {
                self.set_m_asdoc(asdoc);
            }
            fn __nd_metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.m_metadata()
            }
            fn __nd_to_string_1(&self) -> String {
                self.fully_qualified_name()
            }
            pub fn name(&self) -> QName {
                self.__nd_name()
            }
            /// The constant initially assigned to that variable slot.
            pub fn var_constant(&self) -> Option<Entity> {
                self.__nd_var_constant()
            }
            /// The constant initially assigned to that variable slot.
            pub fn set_var_constant(&self, k: Option<Entity>) {
                self.__nd_set_var_constant(k)
            }
            pub fn read_only(&self, host: &Database) -> bool {
                self.__nd_read_only(host)
            }
            pub fn set_read_only(&self, value: bool) {
                self.__nd_set_read_only(value)
            }
            pub fn write_only(&self, host: &Database) -> bool {
                self.__nd_write_only(host)
            }
            pub fn static_type(&self, host: &Database) -> Entity {
                self.__nd_static_type(host)
            }
            pub fn set_static_type(&self, value: Entity) {
                self.__nd_set_static_type(value)
            }
            pub fn location(&self) -> Option<Location> {
                self.__nd_location()
            }
            pub fn set_location(&self, loc: Option<Location>) {
                self.__nd_set_location(loc)
            }
            /// The event name indicated by a `[Bindable]` meta-data tag.
            pub fn bindable_event(&self) -> Option<String> {
                self.__nd_bindable_event()
            }
            pub fn set_bindable_event(&self, name: Option<String>) {
                self.__nd_set_bindable_event(name)
            }
            pub fn parent(&self) -> Option<Entity> {
                self.__nd_parent()
            }
            pub fn set_parent(&self, p: Option<Entity>) {
                self.__nd_set_parent(p)
            }
            pub fn asdoc(&self) -> Option<Rc<Asdoc>> {
                self.__nd_asdoc()
            }
            pub fn set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {
                self.__nd_set_asdoc(asdoc)
            }
            pub fn metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.__nd_metadata()
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<
                        OriginalVariableSlot,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        OriginalVariableSlot,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl VariableSlotAfterSubstitution {
            #[allow(non_snake_case)]
            fn m_origin(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_VariableSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_origin)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_origin(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_VariableSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_origin)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_indirect_type_params(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_VariableSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_indirect_type_params)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_indirect_type_params(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_VariableSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_indirect_type_params)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_indirect_substitute_types(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_VariableSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_indirect_substitute_types)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_indirect_substitute_types(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_VariableSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_indirect_substitute_types)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_static_type(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_VariableSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_static_type)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_static_type(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_VariableSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VariableSlot::__data_VariableSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_static_type)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(
                &self,
                origin: &Entity,
                indirect_type_params: &SharedArray<Entity>,
                indirect_substitute_types: &SharedArray<Entity>,
            ) {
                self.set_m_origin(Some(origin.clone()));
                self.set_m_indirect_type_params(indirect_type_params.clone());
                self.set_m_indirect_substitute_types(indirect_substitute_types.clone());
            }
            pub(crate) fn new(
                arena: &EntityArena,
                origin: &Entity,
                indirect_type_params: &SharedArray<Entity>,
                indirect_substitute_types: &SharedArray<Entity>,
            ) -> Self {
                let __cto1 = VariableSlotAfterSubstitution(
                    VariableSlot(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_VariableSlot(
                                        ::std::rc::Rc::new(__data__::__data_VariableSlot {
                                            __variant: __data__::__variant_VariableSlot::__data_VariableSlotAfterSubstitution(
                                                ::std::rc::Rc::new(__data__::__data_VariableSlotAfterSubstitution {
                                                    m_origin: ::std::cell::RefCell::new(None),
                                                    m_static_type: ::std::cell::RefCell::new(None),
                                                    m_indirect_substitute_types: ::std::cell::RefCell::new(
                                                        SharedArray::new(),
                                                    ),
                                                    m_indirect_type_params: ::std::cell::RefCell::new(
                                                        SharedArray::new(),
                                                    ),
                                                    __variant: __data__::__variant_VariableSlotAfterSubstitution::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                VariableSlot::__ctor(&__cto1.0);
                __cto1.__ctor(origin, indirect_type_params, indirect_substitute_types);
                __cto1
            }
            fn __nd_origin(&self) -> Entity {
                self.m_origin().unwrap()
            }
            fn __nd_indirect_type_params(&self) -> SharedArray<Entity> {
                self.m_indirect_type_params()
            }
            fn __nd_indirect_substitute_types(&self) -> SharedArray<Entity> {
                self.m_indirect_substitute_types()
            }
            fn __nd_name(&self) -> QName {
                self.origin().name()
            }
            fn __nd_var_constant(&self) -> Option<Entity> {
                None
            }
            fn __nd_read_only(&self, host: &Database) -> bool {
                self.origin().read_only(host)
            }
            fn __nd_write_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_static_type(&self, host: &Database) -> Entity {
                if let Some(r) = self.m_static_type() {
                    return r.clone();
                }
                let r = self.origin().static_type(host);
                if r.is::<UnresolvedEntity>() {
                    return r.clone();
                }
                let r = ApplyType(host)
                    .exec(
                        &r,
                        &self.m_indirect_type_params(),
                        &self.m_indirect_substitute_types(),
                    );
                self.set_m_static_type(Some(r.clone()));
                r
            }
            fn __nd_location(&self) -> Option<Location> {
                None
            }
            fn __nd_bindable_event(&self) -> Option<String> {
                self.origin().bindable_event()
            }
            fn __nd_parent(&self) -> Option<Entity> {
                self.origin().parent()
            }
            fn __nd_asdoc(&self) -> Option<Rc<Asdoc>> {
                self.origin().asdoc()
            }
            fn __nd_metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.origin().metadata()
            }
            fn __nd_to_string_1(&self) -> String {
                self.fully_qualified_name()
            }
            pub fn origin(&self) -> Entity {
                self.__nd_origin()
            }
            pub fn indirect_type_params(&self) -> SharedArray<Entity> {
                self.__nd_indirect_type_params()
            }
            pub fn indirect_substitute_types(&self) -> SharedArray<Entity> {
                self.__nd_indirect_substitute_types()
            }
            pub fn name(&self) -> QName {
                self.__nd_name()
            }
            /// The constant initially assigned to that variable slot.
            pub fn var_constant(&self) -> Option<Entity> {
                self.__nd_var_constant()
            }
            pub fn read_only(&self, host: &Database) -> bool {
                self.__nd_read_only(host)
            }
            pub fn write_only(&self, host: &Database) -> bool {
                self.__nd_write_only(host)
            }
            pub fn static_type(&self, host: &Database) -> Entity {
                self.__nd_static_type(host)
            }
            pub fn location(&self) -> Option<Location> {
                self.__nd_location()
            }
            /// The event name indicated by a `[Bindable]` meta-data tag.
            pub fn bindable_event(&self) -> Option<String> {
                self.__nd_bindable_event()
            }
            pub fn parent(&self) -> Option<Entity> {
                self.__nd_parent()
            }
            pub fn asdoc(&self) -> Option<Rc<Asdoc>> {
                self.__nd_asdoc()
            }
            pub fn metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.__nd_metadata()
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<
                        VariableSlotAfterSubstitution,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        VariableSlotAfterSubstitution,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl VirtualSlot {
            fn __ctor(&self) {}
            fn new(arena: &EntityArena) -> Self {
                let __cto1 = VirtualSlot(
                    Entity(
                        arena
                            .allocate(__data__::__data_Entity {
                                __variant: __data__::__variant_Entity::__data_VirtualSlot(
                                    ::std::rc::Rc::new(__data__::__data_VirtualSlot {
                                        __variant: __data__::__variant_VirtualSlot::__Nothing,
                                    }),
                                ),
                            })
                            .clone(),
                    ),
                );
                Entity::__ctor(&__cto1.0);
                __cto1.__ctor();
                __cto1
            }
            fn __nd_property_static_type(&self, host: &Database) -> Entity {
                self.static_type(host)
            }
            /// Returns the static type of a property, whether for a type, variable, virtual or method slot or namespace,
            /// or act as identity of a value's static type.
            /// Possibly `UnresolvedEntity`.
            pub fn property_static_type(&self, host: &Database) -> Entity {
                self.__nd_property_static_type(host)
            }
            pub fn to<
                T: TryFrom<VirtualSlot, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<VirtualSlot, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl OriginalVirtualSlot {
            #[allow(non_snake_case)]
            fn m_name(&self) -> Option<QName> {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_name)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_name(&self, v: Option<QName>) {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_name)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_location(&self) -> Option<Location> {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_location(&self, v: Option<Location>) {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_asdoc(&self) -> Option<Rc<Asdoc>> {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_asdoc)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_asdoc(&self, v: Option<Rc<Asdoc>>) {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_asdoc)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_getter(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_getter)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_getter(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_getter)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_setter(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_setter)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_setter(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_setter)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_static_type(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_static_type)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_static_type(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_static_type)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_parent(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_parent)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_parent(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_parent)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_flags(&self) -> VirtualSlotFlags {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_flags)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .get()
            }
            #[allow(non_snake_case)]
            fn set_m_flags(&self, v: VirtualSlotFlags) {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_flags)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .set(v);
            }
            #[allow(non_snake_case)]
            fn m_bindable_event(&self) -> Option<String> {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_bindable_event)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_bindable_event(&self, v: Option<String>) {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_bindable_event)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, name: &QName) {
                self.set_m_name(Some(name.clone()));
            }
            pub(crate) fn new(arena: &EntityArena, name: &QName) -> Self {
                let __cto1 = OriginalVirtualSlot(
                    VirtualSlot(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_VirtualSlot(
                                        ::std::rc::Rc::new(__data__::__data_VirtualSlot {
                                            __variant: __data__::__variant_VirtualSlot::__data_OriginalVirtualSlot(
                                                ::std::rc::Rc::new(__data__::__data_OriginalVirtualSlot {
                                                    m_asdoc: ::std::cell::RefCell::new(None),
                                                    m_name: ::std::cell::RefCell::new(None),
                                                    m_bindable_event: ::std::cell::RefCell::new(None),
                                                    m_static_type: ::std::cell::RefCell::new(None),
                                                    m_flags: ::std::cell::Cell::new(VirtualSlotFlags::empty()),
                                                    m_setter: ::std::cell::RefCell::new(None),
                                                    m_getter: ::std::cell::RefCell::new(None),
                                                    m_parent: ::std::cell::RefCell::new(None),
                                                    m_location: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_OriginalVirtualSlot::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                VirtualSlot::__ctor(&__cto1.0);
                __cto1.__ctor(name);
                __cto1
            }
            fn __nd_name(&self) -> QName {
                self.m_name().unwrap()
            }
            fn __nd_getter(&self, host: &Database) -> Option<Entity> {
                self.m_getter()
            }
            fn __nd_set_getter(&self, m: Option<Entity>) {
                self.set_m_getter(m);
            }
            fn __nd_setter(&self, host: &Database) -> Option<Entity> {
                self.m_setter()
            }
            fn __nd_set_setter(&self, m: Option<Entity>) {
                self.set_m_setter(m);
            }
            fn __nd_read_only(&self, host: &Database) -> bool {
                self.setter(host).is_none()
            }
            fn __nd_write_only(&self, host: &Database) -> bool {
                self.getter(host).is_none()
            }
            fn __nd_static_type(&self, host: &Database) -> Entity {
                if let Some(r) = self.m_static_type() {
                    return r.clone();
                }
                let mut deduced_type: Option<Entity> = None;
                if let Some(getter) = self.m_getter() {
                    let signature: Entity = getter.signature(host);
                    if !signature.is::<UnresolvedEntity>() {
                        deduced_type = Some(signature.result_type());
                    }
                }
                if let Some(setter) = self.m_setter() {
                    let signature: Entity = setter.signature(host);
                    if !signature.is::<UnresolvedEntity>() {
                        deduced_type = Some(
                            signature.params().get(0).unwrap().static_type.clone(),
                        );
                    }
                }
                if deduced_type.is_none() {
                    return host.unresolved_entity();
                }
                self.set_m_static_type(deduced_type.clone());
                deduced_type.unwrap()
            }
            fn __nd_location(&self) -> Option<Location> {
                self.m_location()
            }
            fn __nd_set_location(&self, loc: Option<Location>) {
                self.set_m_location(loc);
            }
            fn __nd_bindable_event(&self) -> Option<String> {
                self.m_bindable_event()
            }
            fn __nd_set_bindable_event(&self, name: Option<String>) {
                self.set_m_bindable_event(name);
            }
            fn __nd_parent(&self) -> Option<Entity> {
                self.m_parent()
            }
            fn __nd_set_parent(&self, p: Option<Entity>) {
                self.set_m_parent(p);
            }
            fn __nd_asdoc(&self) -> Option<Rc<Asdoc>> {
                self.m_asdoc()
            }
            fn __nd_set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {
                self.set_m_asdoc(asdoc);
            }
            fn __nd_to_string_1(&self) -> String {
                self.fully_qualified_name()
            }
            pub fn name(&self) -> QName {
                self.__nd_name()
            }
            pub fn getter(&self, host: &Database) -> Option<Entity> {
                self.__nd_getter(host)
            }
            pub fn set_getter(&self, m: Option<Entity>) {
                self.__nd_set_getter(m)
            }
            pub fn setter(&self, host: &Database) -> Option<Entity> {
                self.__nd_setter(host)
            }
            pub fn set_setter(&self, m: Option<Entity>) {
                self.__nd_set_setter(m)
            }
            pub fn read_only(&self, host: &Database) -> bool {
                self.__nd_read_only(host)
            }
            pub fn write_only(&self, host: &Database) -> bool {
                self.__nd_write_only(host)
            }
            pub fn static_type(&self, host: &Database) -> Entity {
                self.__nd_static_type(host)
            }
            pub fn location(&self) -> Option<Location> {
                self.__nd_location()
            }
            pub fn set_location(&self, loc: Option<Location>) {
                self.__nd_set_location(loc)
            }
            /// The event name indicated by a `[Bindable]` meta-data tag.
            pub fn bindable_event(&self) -> Option<String> {
                self.__nd_bindable_event()
            }
            pub fn set_bindable_event(&self, name: Option<String>) {
                self.__nd_set_bindable_event(name)
            }
            pub fn parent(&self) -> Option<Entity> {
                self.__nd_parent()
            }
            pub fn set_parent(&self, p: Option<Entity>) {
                self.__nd_set_parent(p)
            }
            pub fn asdoc(&self) -> Option<Rc<Asdoc>> {
                self.__nd_asdoc()
            }
            pub fn set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {
                self.__nd_set_asdoc(asdoc)
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<
                        OriginalVirtualSlot,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        OriginalVirtualSlot,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl VirtualSlotAfterSubstitution {
            #[allow(non_snake_case)]
            fn m_origin(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_VirtualSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_origin)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_origin(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_VirtualSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_origin)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_indirect_type_params(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_VirtualSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_indirect_type_params)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_indirect_type_params(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_VirtualSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_indirect_type_params)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_indirect_substitute_types(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_VirtualSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_indirect_substitute_types)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_indirect_substitute_types(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_VirtualSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_indirect_substitute_types)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_getter(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_VirtualSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_getter)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_getter(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_VirtualSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_getter)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_setter(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_VirtualSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_setter)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_setter(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_VirtualSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_setter)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_static_type(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_VirtualSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_static_type)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_static_type(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_VirtualSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_VirtualSlot::__data_VirtualSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_static_type)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(
                &self,
                origin: &Entity,
                indirect_type_params: &SharedArray<Entity>,
                indirect_substitute_types: &SharedArray<Entity>,
            ) {
                self.set_m_origin(Some(origin.clone()));
                self.set_m_indirect_type_params(indirect_type_params.clone());
                self.set_m_indirect_substitute_types(indirect_substitute_types.clone());
            }
            pub(crate) fn new(
                arena: &EntityArena,
                origin: &Entity,
                indirect_type_params: &SharedArray<Entity>,
                indirect_substitute_types: &SharedArray<Entity>,
            ) -> Self {
                let __cto1 = VirtualSlotAfterSubstitution(
                    VirtualSlot(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_VirtualSlot(
                                        ::std::rc::Rc::new(__data__::__data_VirtualSlot {
                                            __variant: __data__::__variant_VirtualSlot::__data_VirtualSlotAfterSubstitution(
                                                ::std::rc::Rc::new(__data__::__data_VirtualSlotAfterSubstitution {
                                                    m_origin: ::std::cell::RefCell::new(None),
                                                    m_indirect_substitute_types: ::std::cell::RefCell::new(
                                                        SharedArray::new(),
                                                    ),
                                                    m_getter: ::std::cell::RefCell::new(None),
                                                    m_setter: ::std::cell::RefCell::new(None),
                                                    m_static_type: ::std::cell::RefCell::new(None),
                                                    m_indirect_type_params: ::std::cell::RefCell::new(
                                                        SharedArray::new(),
                                                    ),
                                                    __variant: __data__::__variant_VirtualSlotAfterSubstitution::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                VirtualSlot::__ctor(&__cto1.0);
                __cto1.__ctor(origin, indirect_type_params, indirect_substitute_types);
                __cto1
            }
            fn __nd_location(&self) -> Option<Location> {
                None
            }
            fn __nd_origin(&self) -> Entity {
                self.m_origin().unwrap()
            }
            fn __nd_indirect_type_params(&self) -> SharedArray<Entity> {
                self.m_indirect_type_params()
            }
            fn __nd_indirect_substitute_types(&self) -> SharedArray<Entity> {
                self.m_indirect_substitute_types()
            }
            fn __nd_name(&self) -> QName {
                self.origin().name()
            }
            fn __nd_getter(&self, host: &Database) -> Option<Entity> {
                if let Some(r) = self.m_getter() {
                    return Some(r);
                }
                let r = self.origin().getter(host);
                if r.is_none() {
                    return r;
                }
                let r = ApplyType(host)
                    .exec(
                        &r.unwrap(),
                        &self.indirect_type_params(),
                        &self.indirect_substitute_types(),
                    );
                self.set_m_getter(Some(r.clone()));
                Some(r)
            }
            fn __nd_setter(&self, host: &Database) -> Option<Entity> {
                if let Some(r) = self.m_setter() {
                    return Some(r);
                }
                let r = self.origin().setter(host);
                if r.is_none() {
                    return r;
                }
                let r = ApplyType(host)
                    .exec(
                        &r.unwrap(),
                        &self.indirect_type_params(),
                        &self.indirect_substitute_types(),
                    );
                self.set_m_setter(Some(r.clone()));
                Some(r)
            }
            fn __nd_read_only(&self, host: &Database) -> bool {
                self.origin().read_only(host)
            }
            fn __nd_write_only(&self, host: &Database) -> bool {
                self.origin().write_only(host)
            }
            fn __nd_static_type(&self, host: &Database) -> Entity {
                if let Some(r) = self.m_static_type() {
                    return r;
                }
                let r = self.origin().static_type(host);
                if r.is::<UnresolvedEntity>() {
                    return r;
                }
                let r = ApplyType(host)
                    .exec(
                        &r,
                        &self.indirect_type_params(),
                        &self.indirect_substitute_types(),
                    );
                self.set_m_static_type(Some(r.clone()));
                r
            }
            fn __nd_bindable_event(&self) -> Option<String> {
                self.origin().bindable_event()
            }
            fn __nd_parent(&self) -> Option<Entity> {
                self.origin().parent()
            }
            fn __nd_asdoc(&self) -> Option<Rc<Asdoc>> {
                self.origin().asdoc()
            }
            fn __nd_to_string_1(&self) -> String {
                self.fully_qualified_name()
            }
            pub fn location(&self) -> Option<Location> {
                self.__nd_location()
            }
            pub fn origin(&self) -> Entity {
                self.__nd_origin()
            }
            pub fn indirect_type_params(&self) -> SharedArray<Entity> {
                self.__nd_indirect_type_params()
            }
            pub fn indirect_substitute_types(&self) -> SharedArray<Entity> {
                self.__nd_indirect_substitute_types()
            }
            pub fn name(&self) -> QName {
                self.__nd_name()
            }
            pub fn getter(&self, host: &Database) -> Option<Entity> {
                self.__nd_getter(host)
            }
            pub fn setter(&self, host: &Database) -> Option<Entity> {
                self.__nd_setter(host)
            }
            pub fn read_only(&self, host: &Database) -> bool {
                self.__nd_read_only(host)
            }
            pub fn write_only(&self, host: &Database) -> bool {
                self.__nd_write_only(host)
            }
            pub fn static_type(&self, host: &Database) -> Entity {
                self.__nd_static_type(host)
            }
            pub fn bindable_event(&self) -> Option<String> {
                self.__nd_bindable_event()
            }
            pub fn parent(&self) -> Option<Entity> {
                self.__nd_parent()
            }
            pub fn asdoc(&self) -> Option<Rc<Asdoc>> {
                self.__nd_asdoc()
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<
                        VirtualSlotAfterSubstitution,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        VirtualSlotAfterSubstitution,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl MethodSlot {
            fn __ctor(&self) {}
            fn new(arena: &EntityArena) -> Self {
                let __cto1 = MethodSlot(
                    Entity(
                        arena
                            .allocate(__data__::__data_Entity {
                                __variant: __data__::__variant_Entity::__data_MethodSlot(
                                    ::std::rc::Rc::new(__data__::__data_MethodSlot {
                                        __variant: __data__::__variant_MethodSlot::__Nothing,
                                    }),
                                ),
                            })
                            .clone(),
                    ),
                );
                Entity::__ctor(&__cto1.0);
                __cto1.__ctor();
                __cto1
            }
            fn __nd_property_static_type(&self, host: &Database) -> Entity {
                host.function_type()
            }
            /// Returns the static type of a property, whether for a type, variable, virtual or method slot or namespace,
            /// or act as identity of a value's static type.
            /// Possibly `UnresolvedEntity`.
            pub fn property_static_type(&self, host: &Database) -> Entity {
                self.__nd_property_static_type(host)
            }
            pub fn to<T: TryFrom<MethodSlot, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<MethodSlot, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl OriginalMethodSlot {
            #[allow(non_snake_case)]
            fn m_name(&self) -> Option<QName> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_name)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_name(&self, v: Option<QName>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_name)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_location(&self) -> Option<Location> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_location(&self, v: Option<Location>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_asdoc(&self) -> Option<Rc<Asdoc>> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_asdoc)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_asdoc(&self, v: Option<Rc<Asdoc>>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_asdoc)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_metadata(&self) -> SharedArray<Rc<Metadata>> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_metadata)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_metadata(&self, v: SharedArray<Rc<Metadata>>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_metadata)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_activation(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_activation)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_activation(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_activation)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_signature(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_signature)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_signature(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_signature)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_parent(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_parent)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_parent(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_parent)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_of_virtual_slot(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_of_virtual_slot)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_of_virtual_slot(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_of_virtual_slot)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_overriden_by(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_overriden_by)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_overriden_by(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_overriden_by)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_overrides_method(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_overrides_method)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_overrides_method(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_overrides_method)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_flags(&self) -> MethodSlotFlags {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_flags)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .get()
            }
            #[allow(non_snake_case)]
            fn set_m_flags(&self, v: MethodSlotFlags) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_flags)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .set(v);
            }
            fn __ctor(&self, name: &QName, signature: &Entity) {
                self.set_m_name(Some(name.clone()));
                self.set_m_signature(Some(signature.clone()));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                name: &QName,
                signature: &Entity,
            ) -> Self {
                let __cto1 = OriginalMethodSlot(
                    MethodSlot(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_MethodSlot(
                                        ::std::rc::Rc::new(__data__::__data_MethodSlot {
                                            __variant: __data__::__variant_MethodSlot::__data_OriginalMethodSlot(
                                                ::std::rc::Rc::new(__data__::__data_OriginalMethodSlot {
                                                    m_asdoc: ::std::cell::RefCell::new(None),
                                                    m_overrides_method: ::std::cell::RefCell::new(None),
                                                    m_signature: ::std::cell::RefCell::new(None),
                                                    m_name: ::std::cell::RefCell::new(None),
                                                    m_flags: ::std::cell::Cell::new(MethodSlotFlags::empty()),
                                                    m_of_virtual_slot: ::std::cell::RefCell::new(None),
                                                    m_overriden_by: ::std::cell::RefCell::new(
                                                        SharedArray::new(),
                                                    ),
                                                    m_location: ::std::cell::RefCell::new(None),
                                                    m_metadata: ::std::cell::RefCell::new(SharedArray::new()),
                                                    m_parent: ::std::cell::RefCell::new(None),
                                                    m_activation: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_OriginalMethodSlot::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                MethodSlot::__ctor(&__cto1.0);
                __cto1.__ctor(name, signature);
                __cto1
            }
            fn __nd_name(&self) -> QName {
                self.m_name().unwrap()
            }
            fn __nd_is_final(&self) -> bool {
                self.m_flags().contains(MethodSlotFlags::IS_FINAL)
            }
            fn __nd_set_is_final(&self, value: bool) {
                let mut v = self.m_flags();
                v.set(MethodSlotFlags::IS_FINAL, value);
                self.set_m_flags(v);
            }
            fn __nd_is_static(&self) -> bool {
                self.m_flags().contains(MethodSlotFlags::IS_STATIC)
            }
            fn __nd_set_is_static(&self, value: bool) {
                let mut v = self.m_flags();
                v.set(MethodSlotFlags::IS_STATIC, value);
                self.set_m_flags(v);
            }
            fn __nd_is_abstract(&self) -> bool {
                self.m_flags().contains(MethodSlotFlags::IS_ABSTRACT)
            }
            fn __nd_set_is_abstract(&self, value: bool) {
                let mut v = self.m_flags();
                v.set(MethodSlotFlags::IS_ABSTRACT, value);
                self.set_m_flags(v);
            }
            fn __nd_is_overriding(&self) -> bool {
                self.m_flags().contains(MethodSlotFlags::IS_OVERRIDING)
            }
            fn __nd_set_is_overriding(&self, value: bool) {
                let mut v = self.m_flags();
                v.set(MethodSlotFlags::IS_OVERRIDING, value);
                self.set_m_flags(v);
            }
            fn __nd_is_async(&self) -> bool {
                self.m_flags().contains(MethodSlotFlags::IS_ASYNC)
            }
            fn __nd_set_is_async(&self, value: bool) {
                let mut v = self.m_flags();
                v.set(MethodSlotFlags::IS_ASYNC, value);
                self.set_m_flags(v);
            }
            fn __nd_is_generator(&self) -> bool {
                self.m_flags().contains(MethodSlotFlags::IS_GENERATOR)
            }
            fn __nd_set_is_generator(&self, value: bool) {
                let mut v = self.m_flags();
                v.set(MethodSlotFlags::IS_GENERATOR, value);
                self.set_m_flags(v);
            }
            fn __nd_is_constructor(&self) -> bool {
                self.m_flags().contains(MethodSlotFlags::IS_CONSTRUCTOR)
            }
            fn __nd_set_is_constructor(&self, value: bool) {
                let mut v = self.m_flags();
                v.set(MethodSlotFlags::IS_CONSTRUCTOR, value);
                self.set_m_flags(v);
            }
            fn __nd_location(&self) -> Option<Location> {
                self.m_location()
            }
            fn __nd_set_location(&self, loc: Option<Location>) {
                self.set_m_location(loc);
            }
            fn __nd_parent(&self) -> Option<Entity> {
                self.m_parent()
            }
            fn __nd_set_parent(&self, p: Option<Entity>) {
                self.set_m_parent(p);
            }
            fn __nd_asdoc(&self) -> Option<Rc<Asdoc>> {
                self.m_asdoc()
            }
            fn __nd_set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {
                self.set_m_asdoc(asdoc);
            }
            fn __nd_metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.m_metadata()
            }
            fn __nd_signature(&self, host: &Database) -> Entity {
                self.m_signature().unwrap()
            }
            fn __nd_set_signature(&self, signature: &Entity) {
                self.set_m_signature(Some(signature.clone()));
            }
            fn __nd_activation(&self) -> Option<Entity> {
                self.m_activation()
            }
            fn __nd_set_activation(&self, activation: Option<Entity>) {
                self.set_m_activation(activation);
            }
            fn __nd_of_virtual_slot(&self, host: &Database) -> Option<Entity> {
                self.m_of_virtual_slot()
            }
            fn __nd_set_of_virtual_slot(&self, virtual_slot: Option<Entity>) {
                self.set_m_of_virtual_slot(virtual_slot);
            }
            fn __nd_overriden_by(&self, host: &Database) -> SharedArray<Entity> {
                self.m_overriden_by()
            }
            fn __nd_overrides_method(&self, host: &Database) -> Option<Entity> {
                self.m_overrides_method()
            }
            fn __nd_set_overrides_method(&self, method: Option<Entity>) {
                self.set_m_overrides_method(method);
            }
            fn __nd_to_string_1(&self) -> String {
                self.fully_qualified_name()
            }
            pub fn name(&self) -> QName {
                self.__nd_name()
            }
            pub fn is_final(&self) -> bool {
                self.__nd_is_final()
            }
            pub fn set_is_final(&self, value: bool) {
                self.__nd_set_is_final(value)
            }
            pub fn is_static(&self) -> bool {
                self.__nd_is_static()
            }
            pub fn set_is_static(&self, value: bool) {
                self.__nd_set_is_static(value)
            }
            pub fn is_abstract(&self) -> bool {
                self.__nd_is_abstract()
            }
            pub fn set_is_abstract(&self, value: bool) {
                self.__nd_set_is_abstract(value)
            }
            pub fn is_overriding(&self) -> bool {
                self.__nd_is_overriding()
            }
            pub fn set_is_overriding(&self, value: bool) {
                self.__nd_set_is_overriding(value)
            }
            pub fn is_async(&self) -> bool {
                self.__nd_is_async()
            }
            pub fn set_is_async(&self, value: bool) {
                self.__nd_set_is_async(value)
            }
            pub fn is_generator(&self) -> bool {
                self.__nd_is_generator()
            }
            pub fn set_is_generator(&self, value: bool) {
                self.__nd_set_is_generator(value)
            }
            pub fn is_constructor(&self) -> bool {
                self.__nd_is_constructor()
            }
            pub fn set_is_constructor(&self, value: bool) {
                self.__nd_set_is_constructor(value)
            }
            pub fn location(&self) -> Option<Location> {
                self.__nd_location()
            }
            pub fn set_location(&self, loc: Option<Location>) {
                self.__nd_set_location(loc)
            }
            pub fn parent(&self) -> Option<Entity> {
                self.__nd_parent()
            }
            pub fn set_parent(&self, p: Option<Entity>) {
                self.__nd_set_parent(p)
            }
            pub fn asdoc(&self) -> Option<Rc<Asdoc>> {
                self.__nd_asdoc()
            }
            pub fn set_asdoc(&self, asdoc: Option<Rc<Asdoc>>) {
                self.__nd_set_asdoc(asdoc)
            }
            pub fn metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.__nd_metadata()
            }
            pub fn signature(&self, host: &Database) -> Entity {
                self.__nd_signature(host)
            }
            pub fn set_signature(&self, signature: &Entity) {
                self.__nd_set_signature(signature)
            }
            pub fn activation(&self) -> Option<Entity> {
                self.__nd_activation()
            }
            pub fn set_activation(&self, activation: Option<Entity>) {
                self.__nd_set_activation(activation)
            }
            pub fn of_virtual_slot(&self, host: &Database) -> Option<Entity> {
                self.__nd_of_virtual_slot(host)
            }
            pub fn set_of_virtual_slot(&self, virtual_slot: Option<Entity>) {
                self.__nd_set_of_virtual_slot(virtual_slot)
            }
            pub fn overriden_by(&self, host: &Database) -> SharedArray<Entity> {
                self.__nd_overriden_by(host)
            }
            pub fn overrides_method(&self, host: &Database) -> Option<Entity> {
                self.__nd_overrides_method(host)
            }
            pub fn set_overrides_method(&self, method: Option<Entity>) {
                self.__nd_set_overrides_method(method)
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<OriginalMethodSlot, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<OriginalMethodSlot, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl MethodSlotAfterSubstitution {
            #[allow(non_snake_case)]
            fn m_origin(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_origin)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_origin(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_origin)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_indirect_type_params(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_indirect_type_params)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_indirect_type_params(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_indirect_type_params)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_indirect_substitute_types(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_indirect_substitute_types)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_indirect_substitute_types(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_indirect_substitute_types)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_signature(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_signature)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_signature(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_signature)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_of_virtual_slot(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_of_virtual_slot)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_of_virtual_slot(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_of_virtual_slot)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_overriden_by(&self) -> Option<SharedArray<Entity>> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_overriden_by)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_overriden_by(&self, v: Option<SharedArray<Entity>>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_overriden_by)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_overrides_method(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_overrides_method)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_overrides_method(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_overrides_method)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_is_overriding(&self) -> bool {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_is_overriding)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .get()
            }
            #[allow(non_snake_case)]
            fn set_m_is_overriding(&self, v: bool) {
                (if let __data__::__variant_Entity::__data_MethodSlot(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_is_overriding)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .set(v);
            }
            fn __ctor(
                &self,
                origin: &Entity,
                indirect_type_params: &SharedArray<Entity>,
                indirect_substitute_types: &SharedArray<Entity>,
            ) {
                self.set_m_origin(Some(origin.clone()));
                self.set_m_indirect_type_params(indirect_type_params.clone());
                self.set_m_indirect_substitute_types(indirect_substitute_types.clone());
            }
            pub fn new(
                arena: &EntityArena,
                origin: &Entity,
                indirect_type_params: &SharedArray<Entity>,
                indirect_substitute_types: &SharedArray<Entity>,
            ) -> Self {
                let __cto1 = MethodSlotAfterSubstitution(
                    MethodSlot(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_MethodSlot(
                                        ::std::rc::Rc::new(__data__::__data_MethodSlot {
                                            __variant: __data__::__variant_MethodSlot::__data_MethodSlotAfterSubstitution(
                                                ::std::rc::Rc::new(__data__::__data_MethodSlotAfterSubstitution {
                                                    m_indirect_type_params: ::std::cell::RefCell::new(
                                                        SharedArray::new(),
                                                    ),
                                                    m_origin: ::std::cell::RefCell::new(None),
                                                    m_of_virtual_slot: ::std::cell::RefCell::new(None),
                                                    m_overrides_method: ::std::cell::RefCell::new(None),
                                                    m_is_overriding: ::std::cell::Cell::new(false),
                                                    m_signature: ::std::cell::RefCell::new(None),
                                                    m_indirect_substitute_types: ::std::cell::RefCell::new(
                                                        SharedArray::new(),
                                                    ),
                                                    m_overriden_by: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_MethodSlotAfterSubstitution::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                MethodSlot::__ctor(&__cto1.0);
                __cto1.__ctor(origin, indirect_type_params, indirect_substitute_types);
                __cto1
            }
            fn __nd_origin(&self) -> Entity {
                self.m_origin().unwrap()
            }
            fn __nd_indirect_type_params(&self) -> SharedArray<Entity> {
                self.m_indirect_type_params()
            }
            fn __nd_indirect_substitute_types(&self) -> SharedArray<Entity> {
                self.m_indirect_substitute_types()
            }
            fn __nd_name(&self) -> QName {
                self.origin().name()
            }
            fn __nd_is_final(&self) -> bool {
                self.origin().is_final()
            }
            fn __nd_is_static(&self) -> bool {
                self.origin().is_static()
            }
            fn __nd_is_abstract(&self) -> bool {
                self.origin().is_abstract()
            }
            fn __nd_is_overriding(&self) -> bool {
                self.m_is_overriding()
            }
            fn __nd_set_is_overriding(&self, value: bool) {
                self.set_m_is_overriding(value);
            }
            fn __nd_is_async(&self) -> bool {
                self.origin().is_async()
            }
            fn __nd_is_generator(&self) -> bool {
                self.origin().is_generator()
            }
            fn __nd_is_constructor(&self) -> bool {
                self.origin().is_constructor()
            }
            fn __nd_location(&self) -> Option<Location> {
                None
            }
            fn __nd_parent(&self) -> Option<Entity> {
                self.origin().parent()
            }
            fn __nd_asdoc(&self) -> Option<Rc<Asdoc>> {
                self.origin().asdoc()
            }
            fn __nd_metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.origin().metadata()
            }
            fn __nd_signature(&self, host: &Database) -> Entity {
                if let Some(r) = self.m_signature() {
                    return r;
                }
                let r = self.origin().signature(host);
                if r.is::<UnresolvedEntity>() {
                    return r.clone();
                }
                let r = ApplyType(host)
                    .exec(
                        &r,
                        &self.m_indirect_type_params(),
                        &self.m_indirect_substitute_types(),
                    );
                self.set_m_signature(Some(r.clone()));
                r
            }
            fn __nd_of_virtual_slot(&self, host: &Database) -> Option<Entity> {
                if let Some(r) = self.m_of_virtual_slot() {
                    return Some(r);
                }
                let r = self.origin().of_virtual_slot(host);
                if r.is_none() {
                    return None;
                }
                let r = ApplyType(host)
                    .exec(
                        &r.unwrap(),
                        &self.m_indirect_type_params(),
                        &self.m_indirect_substitute_types(),
                    );
                self.set_m_of_virtual_slot(Some(r.clone()));
                Some(r)
            }
            fn __nd_overriden_by(&self, host: &Database) -> SharedArray<Entity> {
                if let Some(r) = self.m_overriden_by() {
                    return r;
                }
                let r = self.origin().overriden_by(host);
                let r: SharedArray<Entity> = r
                    .iter()
                    .map(|r| {
                        ApplyType(host)
                            .exec(
                                &r,
                                &self.m_indirect_type_params(),
                                &self.indirect_substitute_types(),
                            )
                    })
                    .collect();
                self.set_m_overriden_by(Some(r.clone()));
                r
            }
            fn __nd_overrides_method(&self, host: &Database) -> Option<Entity> {
                if let Some(r) = self.m_overrides_method() {
                    return Some(r);
                }
                let r = self.origin().overrides_method(host);
                if r.is_none() {
                    return None;
                }
                let r = ApplyType(host)
                    .exec(
                        &r.unwrap(),
                        &self.m_indirect_type_params(),
                        &self.m_indirect_substitute_types(),
                    );
                self.set_m_overrides_method(Some(r.clone()));
                Some(r)
            }
            fn __nd_set_overrides_method(&self, method: Option<Entity>) {
                self.set_m_overrides_method(method);
            }
            fn __nd_to_string_1(&self) -> String {
                self.fully_qualified_name()
            }
            pub fn origin(&self) -> Entity {
                self.__nd_origin()
            }
            pub fn indirect_type_params(&self) -> SharedArray<Entity> {
                self.__nd_indirect_type_params()
            }
            pub fn indirect_substitute_types(&self) -> SharedArray<Entity> {
                self.__nd_indirect_substitute_types()
            }
            pub fn name(&self) -> QName {
                self.__nd_name()
            }
            pub fn is_final(&self) -> bool {
                self.__nd_is_final()
            }
            pub fn is_static(&self) -> bool {
                self.__nd_is_static()
            }
            pub fn is_abstract(&self) -> bool {
                self.__nd_is_abstract()
            }
            pub fn is_overriding(&self) -> bool {
                self.__nd_is_overriding()
            }
            pub fn set_is_overriding(&self, value: bool) {
                self.__nd_set_is_overriding(value)
            }
            pub fn is_async(&self) -> bool {
                self.__nd_is_async()
            }
            pub fn is_generator(&self) -> bool {
                self.__nd_is_generator()
            }
            pub fn is_constructor(&self) -> bool {
                self.__nd_is_constructor()
            }
            pub fn location(&self) -> Option<Location> {
                self.__nd_location()
            }
            pub fn parent(&self) -> Option<Entity> {
                self.__nd_parent()
            }
            pub fn asdoc(&self) -> Option<Rc<Asdoc>> {
                self.__nd_asdoc()
            }
            pub fn metadata(&self) -> SharedArray<Rc<Metadata>> {
                self.__nd_metadata()
            }
            pub fn signature(&self, host: &Database) -> Entity {
                self.__nd_signature(host)
            }
            pub fn of_virtual_slot(&self, host: &Database) -> Option<Entity> {
                self.__nd_of_virtual_slot(host)
            }
            pub fn overriden_by(&self, host: &Database) -> SharedArray<Entity> {
                self.__nd_overriden_by(host)
            }
            pub fn overrides_method(&self, host: &Database) -> Option<Entity> {
                self.__nd_overrides_method(host)
            }
            pub fn set_overrides_method(&self, method: Option<Entity>) {
                self.__nd_set_overrides_method(method)
            }
            fn to_string_1(&self) -> String {
                self.__nd_to_string_1()
            }
            pub fn to<
                T: TryFrom<
                        MethodSlotAfterSubstitution,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        MethodSlotAfterSubstitution,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl Scope {
            #[allow(non_snake_case)]
            fn m_parent(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_parent)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_parent(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_parent)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_properties(&self) -> Names {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_properties)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_properties(&self, v: Names) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_properties)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_open_ns_set(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_open_ns_set)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_open_ns_set(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_open_ns_set)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_import_list(&self) -> SharedArray<Entity> {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_import_list)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_import_list(&self, v: SharedArray<Entity>) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_import_list)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self) {}
            pub(crate) fn new(arena: &EntityArena) -> Self {
                let __cto1 = Scope(
                    Entity(
                        arena
                            .allocate(__data__::__data_Entity {
                                __variant: __data__::__variant_Entity::__data_Scope(
                                    ::std::rc::Rc::new(__data__::__data_Scope {
                                        m_import_list: ::std::cell::RefCell::new(
                                            SharedArray::new(),
                                        ),
                                        m_parent: ::std::cell::RefCell::new(None),
                                        m_open_ns_set: ::std::cell::RefCell::new(
                                            SharedArray::new(),
                                        ),
                                        m_properties: ::std::cell::RefCell::new(Names::new()),
                                        __variant: __data__::__variant_Scope::__Nothing,
                                    }),
                                ),
                            })
                            .clone(),
                    ),
                );
                Entity::__ctor(&__cto1.0);
                __cto1.__ctor();
                __cto1
            }
            fn __nd_parent(&self) -> Option<Entity> {
                self.m_parent()
            }
            fn __nd_set_parent(&self, p: Option<Entity>) {
                self.set_m_parent(p);
            }
            fn __nd_properties(&self, host: &Database) -> Names {
                self.m_properties()
            }
            fn __nd_open_ns_set(&self) -> SharedArray<Entity> {
                self.m_open_ns_set()
            }
            fn __nd_import_list(&self) -> SharedArray<Entity> {
                self.m_import_list()
            }
            pub fn parent(&self) -> Option<Entity> {
                self.__nd_parent()
            }
            pub fn set_parent(&self, p: Option<Entity>) {
                self.__nd_set_parent(p)
            }
            pub fn properties(&self, host: &Database) -> Names {
                self.__nd_properties(host)
            }
            pub fn open_ns_set(&self) -> SharedArray<Entity> {
                self.__nd_open_ns_set()
            }
            /// List of [`PackagePropertyImport`], [`PackageWildcardImport`], or [`PackageRecursiveImport`].
            pub fn import_list(&self) -> SharedArray<Entity> {
                self.__nd_import_list()
            }
            pub fn to<T: TryFrom<Scope, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<Scope, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl WithScope {
            #[allow(non_snake_case)]
            fn m_object(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_WithScope(o) = &o.__variant
                    {
                        (&o.m_object)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_object(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_WithScope(o) = &o.__variant
                    {
                        (&o.m_object)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, object: &Entity) {
                self.set_m_object(Some(object.clone()));
            }
            pub(crate) fn new(arena: &EntityArena, object: &Entity) -> Self {
                let __cto1 = WithScope(
                    Scope(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Scope(
                                        ::std::rc::Rc::new(__data__::__data_Scope {
                                            m_import_list: ::std::cell::RefCell::new(
                                                SharedArray::new(),
                                            ),
                                            m_parent: ::std::cell::RefCell::new(None),
                                            m_open_ns_set: ::std::cell::RefCell::new(
                                                SharedArray::new(),
                                            ),
                                            m_properties: ::std::cell::RefCell::new(Names::new()),
                                            __variant: __data__::__variant_Scope::__data_WithScope(
                                                ::std::rc::Rc::new(__data__::__data_WithScope {
                                                    m_object: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_WithScope::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Scope::__ctor(&__cto1.0);
                __cto1.__ctor(object);
                __cto1
            }
            fn __nd_object(&self) -> Entity {
                self.m_object().unwrap()
            }
            pub fn object(&self) -> Entity {
                self.__nd_object()
            }
            pub fn to<T: TryFrom<WithScope, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<WithScope, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl FilterScope {
            #[allow(non_snake_case)]
            fn m_base(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_FilterScope(o) = &o
                        .__variant
                    {
                        (&o.m_base)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_base(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_FilterScope(o) = &o
                        .__variant
                    {
                        (&o.m_base)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, base: &Entity) {
                self.set_m_base(Some(base.clone()));
            }
            pub(crate) fn new(arena: &EntityArena, base: &Entity) -> Self {
                let __cto1 = FilterScope(
                    Scope(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Scope(
                                        ::std::rc::Rc::new(__data__::__data_Scope {
                                            m_import_list: ::std::cell::RefCell::new(
                                                SharedArray::new(),
                                            ),
                                            m_parent: ::std::cell::RefCell::new(None),
                                            m_open_ns_set: ::std::cell::RefCell::new(
                                                SharedArray::new(),
                                            ),
                                            m_properties: ::std::cell::RefCell::new(Names::new()),
                                            __variant: __data__::__variant_Scope::__data_FilterScope(
                                                ::std::rc::Rc::new(__data__::__data_FilterScope {
                                                    m_base: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_FilterScope::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Scope::__ctor(&__cto1.0);
                __cto1.__ctor(base);
                __cto1
            }
            fn __nd_base(&self) -> Entity {
                self.m_base().unwrap()
            }
            pub fn base(&self) -> Entity {
                self.__nd_base()
            }
            pub fn to<
                T: TryFrom<FilterScope, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<FilterScope, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl Activation {
            #[allow(non_snake_case)]
            fn m_kind(&self) -> u8 {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_Activation(o) = &o
                        .__variant
                    {
                        (&o.m_kind)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .get()
            }
            #[allow(non_snake_case)]
            fn set_m_kind(&self, v: u8) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_Activation(o) = &o
                        .__variant
                    {
                        (&o.m_kind)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .set(v);
            }
            #[allow(non_snake_case)]
            fn m_method(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_Activation(o) = &o
                        .__variant
                    {
                        (&o.m_method)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_method(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_Activation(o) = &o
                        .__variant
                    {
                        (&o.m_method)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_this(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_Activation(o) = &o
                        .__variant
                    {
                        (&o.m_this)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_this(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_Activation(o) = &o
                        .__variant
                    {
                        (&o.m_this)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_property_has_capture(&self) -> Option<SharedArray<Entity>> {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_Activation(o) = &o
                        .__variant
                    {
                        (&o.m_property_has_capture)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_property_has_capture(&self, v: Option<SharedArray<Entity>>) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_Activation(o) = &o
                        .__variant
                    {
                        (&o.m_property_has_capture)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_cfg(&self) -> ControlFlowGraph {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_Activation(o) = &o
                        .__variant
                    {
                        (&o.m_cfg)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_cfg(&self, v: ControlFlowGraph) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_Activation(o) = &o
                        .__variant
                    {
                        (&o.m_cfg)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_public_ns(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_Activation(o) = &o
                        .__variant
                    {
                        (&o.m_public_ns)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_public_ns(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_Activation(o) = &o
                        .__variant
                    {
                        (&o.m_public_ns)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_internal_ns(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_Activation(o) = &o
                        .__variant
                    {
                        (&o.m_internal_ns)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_internal_ns(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_Activation(o) = &o
                        .__variant
                    {
                        (&o.m_internal_ns)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, of_method: &Entity) {
                self.set_m_method(Some(of_method.clone()));
            }
            pub(crate) fn new(arena: &EntityArena, of_method: &Entity) -> Self {
                let __cto1 = Activation(
                    Scope(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Scope(
                                        ::std::rc::Rc::new(__data__::__data_Scope {
                                            m_import_list: ::std::cell::RefCell::new(
                                                SharedArray::new(),
                                            ),
                                            m_parent: ::std::cell::RefCell::new(None),
                                            m_open_ns_set: ::std::cell::RefCell::new(
                                                SharedArray::new(),
                                            ),
                                            m_properties: ::std::cell::RefCell::new(Names::new()),
                                            __variant: __data__::__variant_Scope::__data_Activation(
                                                ::std::rc::Rc::new(__data__::__data_Activation {
                                                    m_public_ns: ::std::cell::RefCell::new(None),
                                                    m_this: ::std::cell::RefCell::new(None),
                                                    m_internal_ns: ::std::cell::RefCell::new(None),
                                                    m_cfg: ::std::cell::RefCell::new(ControlFlowGraph::new()),
                                                    m_property_has_capture: ::std::cell::RefCell::new(None),
                                                    m_kind: ::std::cell::Cell::new(DEFAULT_ACTIVATION),
                                                    m_method: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_Activation::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Scope::__ctor(&__cto1.0);
                __cto1.__ctor(of_method);
                __cto1
            }
            fn __nd_of_method(&self) -> Entity {
                self.m_method().unwrap()
            }
            fn __nd_this(&self) -> Option<Entity> {
                self.m_this()
            }
            fn __nd_set_this(&self, this: Option<Entity>) {
                self.set_m_this(this);
            }
            fn __nd_property_has_capture(&self, property: &Entity) -> bool {
                if let Some(set) = self.m_property_has_capture() {
                    set.includes(property)
                } else {
                    false
                }
            }
            fn __nd_set_property_has_capture(&self, property: &Entity, value: bool) {
                if let Some(mut set) = self.m_property_has_capture() {
                    if value {
                        if !set.includes(property) {
                            set.push(property.clone());
                        }
                    } else {
                        let i = set.index_of(property);
                        if let Some(i) = i {
                            set.remove(i);
                        }
                    }
                } else if value {
                    self.set_m_property_has_capture(
                        Some(SharedArray::from([property.clone()])),
                    );
                }
            }
            fn __nd_control_flow_graph(&self) -> ControlFlowGraph {
                self.m_cfg()
            }
            fn __nd_is_global_initialization(&self) -> bool {
                self.m_kind() == GLOBAL_INIT_ACTIVATION
            }
            fn __nd_set_is_global_initialization(&self, value: bool) {
                self.set_m_kind(
                    if value { GLOBAL_INIT_ACTIVATION } else { DEFAULT_ACTIVATION },
                );
            }
            fn __nd_is_package_initialization(&self) -> bool {
                self.m_kind() == PACKAGE_INIT_ACTIVATION
            }
            fn __nd_set_is_package_initialization(&self, value: bool) {
                self.set_m_kind(
                    if value { PACKAGE_INIT_ACTIVATION } else { DEFAULT_ACTIVATION },
                );
            }
            fn __nd_public_ns(&self) -> Option<Entity> {
                self.m_public_ns()
            }
            fn __nd_set_public_ns(&self, ns: Option<Entity>) {
                self.set_m_public_ns(ns);
            }
            fn __nd_internal_ns(&self) -> Option<Entity> {
                self.m_internal_ns()
            }
            fn __nd_set_internal_ns(&self, ns: Option<Entity>) {
                self.set_m_internal_ns(ns);
            }
            pub fn of_method(&self) -> Entity {
                self.__nd_of_method()
            }
            /// An optional `ThisObject` value.
            pub fn this(&self) -> Option<Entity> {
                self.__nd_this()
            }
            /// Sets a `ThisObject` value.
            pub fn set_this(&self, this: Option<Entity>) {
                self.__nd_set_this(this)
            }
            /// Indicates whether an activation's property has been captured
            /// by a subsequent activation. Properties include, for example, the range from the
            /// activation to an inner most block scope.
            pub fn property_has_capture(&self, property: &Entity) -> bool {
                self.__nd_property_has_capture(property)
            }
            pub fn set_property_has_capture(&self, property: &Entity, value: bool) {
                self.__nd_set_property_has_capture(property, value)
            }
            pub fn control_flow_graph(&self) -> ControlFlowGraph {
                self.__nd_control_flow_graph()
            }
            pub fn is_global_initialization(&self) -> bool {
                self.__nd_is_global_initialization()
            }
            pub fn set_is_global_initialization(&self, value: bool) {
                self.__nd_set_is_global_initialization(value)
            }
            pub fn is_package_initialization(&self) -> bool {
                self.__nd_is_package_initialization()
            }
            pub fn set_is_package_initialization(&self, value: bool) {
                self.__nd_set_is_package_initialization(value)
            }
            pub fn public_ns(&self) -> Option<Entity> {
                self.__nd_public_ns()
            }
            pub fn set_public_ns(&self, ns: Option<Entity>) {
                self.__nd_set_public_ns(ns)
            }
            pub fn internal_ns(&self) -> Option<Entity> {
                self.__nd_internal_ns()
            }
            pub fn set_internal_ns(&self, ns: Option<Entity>) {
                self.__nd_set_internal_ns(ns)
            }
            pub fn to<T: TryFrom<Activation, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<Activation, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl FixtureScope {
            fn __ctor(&self) {}
            pub(crate) fn new(arena: &EntityArena) -> Self {
                let __cto1 = FixtureScope(
                    Scope(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Scope(
                                        ::std::rc::Rc::new(__data__::__data_Scope {
                                            m_import_list: ::std::cell::RefCell::new(
                                                SharedArray::new(),
                                            ),
                                            m_parent: ::std::cell::RefCell::new(None),
                                            m_open_ns_set: ::std::cell::RefCell::new(
                                                SharedArray::new(),
                                            ),
                                            m_properties: ::std::cell::RefCell::new(Names::new()),
                                            __variant: __data__::__variant_Scope::__data_FixtureScope(
                                                ::std::rc::Rc::new(__data__::__data_FixtureScope {
                                                    __variant: __data__::__variant_FixtureScope::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Scope::__ctor(&__cto1.0);
                __cto1.__ctor();
                __cto1
            }
            pub fn to<
                T: TryFrom<FixtureScope, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<FixtureScope, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl ClassScope {
            #[allow(non_snake_case)]
            fn m_class(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_FixtureScope(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_FixtureScope::__data_ClassScope(o) = &o
                            .__variant
                        {
                            (&o.m_class)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_class(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_FixtureScope(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_FixtureScope::__data_ClassScope(o) = &o
                            .__variant
                        {
                            (&o.m_class)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, class: &Entity) {
                self.set_m_class(Some(class.clone()));
            }
            pub(crate) fn new(arena: &EntityArena, class: &Entity) -> Self {
                let __cto1 = ClassScope(
                    FixtureScope(
                        Scope(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Scope(
                                            ::std::rc::Rc::new(__data__::__data_Scope {
                                                m_import_list: ::std::cell::RefCell::new(
                                                    SharedArray::new(),
                                                ),
                                                m_parent: ::std::cell::RefCell::new(None),
                                                m_open_ns_set: ::std::cell::RefCell::new(
                                                    SharedArray::new(),
                                                ),
                                                m_properties: ::std::cell::RefCell::new(Names::new()),
                                                __variant: __data__::__variant_Scope::__data_FixtureScope(
                                                    ::std::rc::Rc::new(__data__::__data_FixtureScope {
                                                        __variant: __data__::__variant_FixtureScope::__data_ClassScope(
                                                            ::std::rc::Rc::new(__data__::__data_ClassScope {
                                                                m_class: ::std::cell::RefCell::new(None),
                                                                __variant: __data__::__variant_ClassScope::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                FixtureScope::__ctor(&__cto1.0);
                __cto1.__ctor(class);
                __cto1
            }
            fn __nd_class(&self) -> Entity {
                self.m_class().unwrap()
            }
            pub fn class(&self) -> Entity {
                self.__nd_class()
            }
            pub fn to<T: TryFrom<ClassScope, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<ClassScope, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl EnumScope {
            #[allow(non_snake_case)]
            fn m_class(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_FixtureScope(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_FixtureScope::__data_EnumScope(o) = &o
                            .__variant
                        {
                            (&o.m_class)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_class(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_FixtureScope(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_FixtureScope::__data_EnumScope(o) = &o
                            .__variant
                        {
                            (&o.m_class)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, class: &Entity) {
                self.set_m_class(Some(class.clone()));
            }
            pub(crate) fn new(arena: &EntityArena, class: &Entity) -> Self {
                let __cto1 = EnumScope(
                    FixtureScope(
                        Scope(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Scope(
                                            ::std::rc::Rc::new(__data__::__data_Scope {
                                                m_import_list: ::std::cell::RefCell::new(
                                                    SharedArray::new(),
                                                ),
                                                m_parent: ::std::cell::RefCell::new(None),
                                                m_open_ns_set: ::std::cell::RefCell::new(
                                                    SharedArray::new(),
                                                ),
                                                m_properties: ::std::cell::RefCell::new(Names::new()),
                                                __variant: __data__::__variant_Scope::__data_FixtureScope(
                                                    ::std::rc::Rc::new(__data__::__data_FixtureScope {
                                                        __variant: __data__::__variant_FixtureScope::__data_EnumScope(
                                                            ::std::rc::Rc::new(__data__::__data_EnumScope {
                                                                m_class: ::std::cell::RefCell::new(None),
                                                                __variant: __data__::__variant_EnumScope::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                FixtureScope::__ctor(&__cto1.0);
                __cto1.__ctor(class);
                __cto1
            }
            fn __nd_class(&self) -> Entity {
                self.m_class().unwrap()
            }
            pub fn class(&self) -> Entity {
                self.__nd_class()
            }
            pub fn to<T: TryFrom<EnumScope, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<EnumScope, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl InterfaceScope {
            #[allow(non_snake_case)]
            fn m_itrfc(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_FixtureScope(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_FixtureScope::__data_InterfaceScope(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_itrfc)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_itrfc(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_FixtureScope(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_FixtureScope::__data_InterfaceScope(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_itrfc)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, itrfc: &Entity) {
                self.set_m_itrfc(Some(itrfc.clone()));
            }
            pub(crate) fn new(arena: &EntityArena, itrfc: &Entity) -> Self {
                let __cto1 = InterfaceScope(
                    FixtureScope(
                        Scope(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Scope(
                                            ::std::rc::Rc::new(__data__::__data_Scope {
                                                m_import_list: ::std::cell::RefCell::new(
                                                    SharedArray::new(),
                                                ),
                                                m_parent: ::std::cell::RefCell::new(None),
                                                m_open_ns_set: ::std::cell::RefCell::new(
                                                    SharedArray::new(),
                                                ),
                                                m_properties: ::std::cell::RefCell::new(Names::new()),
                                                __variant: __data__::__variant_Scope::__data_FixtureScope(
                                                    ::std::rc::Rc::new(__data__::__data_FixtureScope {
                                                        __variant: __data__::__variant_FixtureScope::__data_InterfaceScope(
                                                            ::std::rc::Rc::new(__data__::__data_InterfaceScope {
                                                                m_itrfc: ::std::cell::RefCell::new(None),
                                                                __variant: __data__::__variant_InterfaceScope::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                FixtureScope::__ctor(&__cto1.0);
                __cto1.__ctor(itrfc);
                __cto1
            }
            fn __nd_interface(&self) -> Entity {
                self.m_itrfc().unwrap()
            }
            pub fn interface(&self) -> Entity {
                self.__nd_interface()
            }
            pub fn to<
                T: TryFrom<InterfaceScope, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<InterfaceScope, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl PackageScope {
            #[allow(non_snake_case)]
            fn m_pckg(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_FixtureScope(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_FixtureScope::__data_PackageScope(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_pckg)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_pckg(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Scope(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Scope::__data_FixtureScope(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_FixtureScope::__data_PackageScope(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_pckg)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, pckg: &Entity) {
                self.set_m_pckg(Some(pckg.clone()));
            }
            pub(crate) fn new(arena: &EntityArena, pckg: &Entity) -> Self {
                let __cto1 = PackageScope(
                    FixtureScope(
                        Scope(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Scope(
                                            ::std::rc::Rc::new(__data__::__data_Scope {
                                                m_import_list: ::std::cell::RefCell::new(
                                                    SharedArray::new(),
                                                ),
                                                m_parent: ::std::cell::RefCell::new(None),
                                                m_open_ns_set: ::std::cell::RefCell::new(
                                                    SharedArray::new(),
                                                ),
                                                m_properties: ::std::cell::RefCell::new(Names::new()),
                                                __variant: __data__::__variant_Scope::__data_FixtureScope(
                                                    ::std::rc::Rc::new(__data__::__data_FixtureScope {
                                                        __variant: __data__::__variant_FixtureScope::__data_PackageScope(
                                                            ::std::rc::Rc::new(__data__::__data_PackageScope {
                                                                m_pckg: ::std::cell::RefCell::new(None),
                                                                __variant: __data__::__variant_PackageScope::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                FixtureScope::__ctor(&__cto1.0);
                __cto1.__ctor(pckg);
                __cto1
            }
            fn __nd_package(&self) -> Entity {
                self.m_pckg().unwrap()
            }
            pub fn package(&self) -> Entity {
                self.__nd_package()
            }
            pub fn to<
                T: TryFrom<PackageScope, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<PackageScope, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl Value {
            #[allow(non_snake_case)]
            fn m_static_type(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_static_type)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_static_type(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_static_type)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, static_type: &Entity) {
                self.set_m_static_type(Some(static_type.clone()));
            }
            pub(crate) fn new(arena: &EntityArena, static_type: &Entity) -> Self {
                let __cto1 = Value(
                    Entity(
                        arena
                            .allocate(__data__::__data_Entity {
                                __variant: __data__::__variant_Entity::__data_Value(
                                    ::std::rc::Rc::new(__data__::__data_Value {
                                        m_static_type: ::std::cell::RefCell::new(None),
                                        __variant: __data__::__variant_Value::__Nothing,
                                    }),
                                ),
                            })
                            .clone(),
                    ),
                );
                Entity::__ctor(&__cto1.0);
                __cto1.__ctor(static_type);
                __cto1
            }
            fn __nd_static_type(&self, host: &Database) -> Entity {
                self.m_static_type().unwrap()
            }
            fn __nd_set_static_type(&self, value: Entity) {
                self.set_m_static_type(Some(value));
            }
            fn __nd_property_static_type(&self, host: &Database) -> Entity {
                self.static_type(host)
            }
            pub fn static_type(&self, host: &Database) -> Entity {
                self.__nd_static_type(host)
            }
            pub fn set_static_type(&self, value: Entity) {
                self.__nd_set_static_type(value)
            }
            /// Returns the static type of a property, whether for a type, variable, virtual or method slot or namespace,
            /// or act as identity of a value's static type.
            /// Possibly `UnresolvedEntity`.
            pub fn property_static_type(&self, host: &Database) -> Entity {
                self.__nd_property_static_type(host)
            }
            pub fn to<T: TryFrom<Value, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<Value, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl PackagePropertyImport {
            #[allow(non_snake_case)]
            fn m_property(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_PackagePropertyImport(o) = &o
                        .__variant
                    {
                        (&o.m_property)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_property(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_PackagePropertyImport(o) = &o
                        .__variant
                    {
                        (&o.m_property)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_location(&self) -> Option<Location> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_PackagePropertyImport(o) = &o
                        .__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_location(&self, v: Option<Location>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_PackagePropertyImport(o) = &o
                        .__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(
                &self,
                property: &Entity,
                location: Option<Location>,
                static_type: &Entity,
            ) {
                self.set_m_property(Some(property.clone()));
                self.set_m_location(location);
            }
            pub(crate) fn new(
                arena: &EntityArena,
                property: &Entity,
                location: Option<Location>,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = PackagePropertyImport(
                    Value(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Value(
                                        ::std::rc::Rc::new(__data__::__data_Value {
                                            m_static_type: ::std::cell::RefCell::new(None),
                                            __variant: __data__::__variant_Value::__data_PackagePropertyImport(
                                                ::std::rc::Rc::new(__data__::__data_PackagePropertyImport {
                                                    m_location: ::std::cell::RefCell::new(None),
                                                    m_property: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_PackagePropertyImport::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Value::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(property, location, static_type);
                __cto1
            }
            fn __nd_property(&self) -> Entity {
                self.m_property().unwrap()
            }
            fn __nd_set_property(&self, value: &Entity) {
                self.set_m_property(Some(value.clone()));
            }
            fn __nd_location(&self) -> Option<Location> {
                self.m_location()
            }
            fn __nd_set_location(&self, loc: Option<Location>) {
                self.set_m_location(loc);
            }
            pub fn property(&self) -> Entity {
                self.__nd_property()
            }
            pub fn set_property(&self, value: &Entity) {
                self.__nd_set_property(value)
            }
            pub fn location(&self) -> Option<Location> {
                self.__nd_location()
            }
            pub fn set_location(&self, loc: Option<Location>) {
                self.__nd_set_location(loc)
            }
            pub fn to<
                T: TryFrom<
                        PackagePropertyImport,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        PackagePropertyImport,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl PackageWildcardImport {
            #[allow(non_snake_case)]
            fn m_package(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_PackageWildcardImport(o) = &o
                        .__variant
                    {
                        (&o.m_package)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_package(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_PackageWildcardImport(o) = &o
                        .__variant
                    {
                        (&o.m_package)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_location(&self) -> Option<Location> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_PackageWildcardImport(o) = &o
                        .__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_location(&self, v: Option<Location>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_PackageWildcardImport(o) = &o
                        .__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(
                &self,
                package: &Entity,
                location: Option<Location>,
                static_type: &Entity,
            ) {
                self.set_m_package(Some(package.clone()));
                self.set_m_location(location);
            }
            pub(crate) fn new(
                arena: &EntityArena,
                package: &Entity,
                location: Option<Location>,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = PackageWildcardImport(
                    Value(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Value(
                                        ::std::rc::Rc::new(__data__::__data_Value {
                                            m_static_type: ::std::cell::RefCell::new(None),
                                            __variant: __data__::__variant_Value::__data_PackageWildcardImport(
                                                ::std::rc::Rc::new(__data__::__data_PackageWildcardImport {
                                                    m_location: ::std::cell::RefCell::new(None),
                                                    m_package: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_PackageWildcardImport::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Value::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(package, location, static_type);
                __cto1
            }
            fn __nd_package(&self) -> Entity {
                self.m_package().unwrap()
            }
            fn __nd_location(&self) -> Option<Location> {
                self.m_location()
            }
            fn __nd_set_location(&self, loc: Option<Location>) {
                self.set_m_location(loc);
            }
            pub fn package(&self) -> Entity {
                self.__nd_package()
            }
            pub fn location(&self) -> Option<Location> {
                self.__nd_location()
            }
            pub fn set_location(&self, loc: Option<Location>) {
                self.__nd_set_location(loc)
            }
            pub fn to<
                T: TryFrom<
                        PackageWildcardImport,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        PackageWildcardImport,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl PackageRecursiveImport {
            #[allow(non_snake_case)]
            fn m_package(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_PackageRecursiveImport(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_package)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_package(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_PackageRecursiveImport(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_package)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_location(&self) -> Option<Location> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_PackageRecursiveImport(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_location(&self, v: Option<Location>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_PackageRecursiveImport(
                        o,
                    ) = &o.__variant
                    {
                        (&o.m_location)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(
                &self,
                package: &Entity,
                location: Option<Location>,
                static_type: &Entity,
            ) {
                self.set_m_package(Some(package.clone()));
                self.set_m_location(location);
            }
            pub(crate) fn new(
                arena: &EntityArena,
                package: &Entity,
                location: Option<Location>,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = PackageRecursiveImport(
                    Value(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Value(
                                        ::std::rc::Rc::new(__data__::__data_Value {
                                            m_static_type: ::std::cell::RefCell::new(None),
                                            __variant: __data__::__variant_Value::__data_PackageRecursiveImport(
                                                ::std::rc::Rc::new(__data__::__data_PackageRecursiveImport {
                                                    m_package: ::std::cell::RefCell::new(None),
                                                    m_location: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_PackageRecursiveImport::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Value::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(package, location, static_type);
                __cto1
            }
            fn __nd_package(&self) -> Entity {
                self.m_package().unwrap()
            }
            fn __nd_location(&self) -> Option<Location> {
                self.m_location()
            }
            fn __nd_set_location(&self, loc: Option<Location>) {
                self.set_m_location(loc);
            }
            pub fn package(&self) -> Entity {
                self.__nd_package()
            }
            pub fn location(&self) -> Option<Location> {
                self.__nd_location()
            }
            pub fn set_location(&self, loc: Option<Location>) {
                self.__nd_set_location(loc)
            }
            pub fn to<
                T: TryFrom<
                        PackageRecursiveImport,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        PackageRecursiveImport,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl Constant {
            fn __ctor(&self, static_type: &Entity) {}
            pub(crate) fn new(arena: &EntityArena, static_type: &Entity) -> Self {
                let __cto1 = Constant(
                    Value(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Value(
                                        ::std::rc::Rc::new(__data__::__data_Value {
                                            m_static_type: ::std::cell::RefCell::new(None),
                                            __variant: __data__::__variant_Value::__data_Constant(
                                                ::std::rc::Rc::new(__data__::__data_Constant {
                                                    __variant: __data__::__variant_Constant::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Value::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(static_type);
                __cto1
            }
            pub fn to<T: TryFrom<Constant, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<Constant, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl UndefinedConstant {
            fn __ctor(&self, static_type: &Entity) {}
            pub(crate) fn new(arena: &EntityArena, static_type: &Entity) -> Self {
                let __cto1 = UndefinedConstant(
                    Constant(
                        Value(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Value(
                                            ::std::rc::Rc::new(__data__::__data_Value {
                                                m_static_type: ::std::cell::RefCell::new(None),
                                                __variant: __data__::__variant_Value::__data_Constant(
                                                    ::std::rc::Rc::new(__data__::__data_Constant {
                                                        __variant: __data__::__variant_Constant::__data_UndefinedConstant(
                                                            ::std::rc::Rc::new(__data__::__data_UndefinedConstant {
                                                                __variant: __data__::__variant_UndefinedConstant::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                Constant::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(static_type);
                __cto1
            }
            fn __nd_clone_constant(&self, host: &Database) -> Entity {
                host.factory().create_undefined_constant(&self.static_type(host))
            }
            pub fn clone_constant(&self, host: &Database) -> Entity {
                self.__nd_clone_constant(host)
            }
            pub fn to<
                T: TryFrom<UndefinedConstant, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<UndefinedConstant, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl NullConstant {
            fn __ctor(&self, static_type: &Entity) {}
            pub(crate) fn new(arena: &EntityArena, static_type: &Entity) -> Self {
                let __cto1 = NullConstant(
                    Constant(
                        Value(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Value(
                                            ::std::rc::Rc::new(__data__::__data_Value {
                                                m_static_type: ::std::cell::RefCell::new(None),
                                                __variant: __data__::__variant_Value::__data_Constant(
                                                    ::std::rc::Rc::new(__data__::__data_Constant {
                                                        __variant: __data__::__variant_Constant::__data_NullConstant(
                                                            ::std::rc::Rc::new(__data__::__data_NullConstant {
                                                                __variant: __data__::__variant_NullConstant::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                Constant::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(static_type);
                __cto1
            }
            fn __nd_clone_constant(&self, host: &Database) -> Entity {
                host.factory().create_null_constant(&self.static_type(host))
            }
            pub fn clone_constant(&self, host: &Database) -> Entity {
                self.__nd_clone_constant(host)
            }
            pub fn to<
                T: TryFrom<NullConstant, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<NullConstant, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl NamespaceConstant {
            #[allow(non_snake_case)]
            fn m_ns(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_Constant(o) = &o.__variant
                    {
                        (if let __data__::__variant_Constant::__data_NamespaceConstant(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_ns)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_ns(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_Constant(o) = &o.__variant
                    {
                        (if let __data__::__variant_Constant::__data_NamespaceConstant(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_ns)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, referenced_ns: &Entity, static_type: &Entity) {
                self.set_m_ns(Some(referenced_ns.clone()));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                referenced_ns: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = NamespaceConstant(
                    Constant(
                        Value(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Value(
                                            ::std::rc::Rc::new(__data__::__data_Value {
                                                m_static_type: ::std::cell::RefCell::new(None),
                                                __variant: __data__::__variant_Value::__data_Constant(
                                                    ::std::rc::Rc::new(__data__::__data_Constant {
                                                        __variant: __data__::__variant_Constant::__data_NamespaceConstant(
                                                            ::std::rc::Rc::new(__data__::__data_NamespaceConstant {
                                                                m_ns: ::std::cell::RefCell::new(None),
                                                                __variant: __data__::__variant_NamespaceConstant::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                Constant::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(referenced_ns, static_type);
                __cto1
            }
            fn __nd_referenced_ns(&self) -> Entity {
                self.m_ns().unwrap()
            }
            fn __nd_is_namespace_or_ns_constant(&self) -> bool {
                true
            }
            fn __nd_clone_constant(&self, host: &Database) -> Entity {
                host.factory()
                    .create_namespace_constant_with_static_type(
                        &self.referenced_ns(),
                        &self.static_type(host),
                    )
            }
            pub fn referenced_ns(&self) -> Entity {
                self.__nd_referenced_ns()
            }
            pub fn is_namespace_or_ns_constant(&self) -> bool {
                self.__nd_is_namespace_or_ns_constant()
            }
            pub fn clone_constant(&self, host: &Database) -> Entity {
                self.__nd_clone_constant(host)
            }
            pub fn to<
                T: TryFrom<NamespaceConstant, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<NamespaceConstant, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl TypeConstant {
            #[allow(non_snake_case)]
            fn m_type(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_Constant(o) = &o.__variant
                    {
                        (if let __data__::__variant_Constant::__data_TypeConstant(o) = &o
                            .__variant
                        {
                            (&o.m_type)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_type(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_Constant(o) = &o.__variant
                    {
                        (if let __data__::__variant_Constant::__data_TypeConstant(o) = &o
                            .__variant
                        {
                            (&o.m_type)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, referenced_type: &Entity, static_type: &Entity) {
                self.set_m_type(Some(referenced_type.clone()));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                referenced_type: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = TypeConstant(
                    Constant(
                        Value(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Value(
                                            ::std::rc::Rc::new(__data__::__data_Value {
                                                m_static_type: ::std::cell::RefCell::new(None),
                                                __variant: __data__::__variant_Value::__data_Constant(
                                                    ::std::rc::Rc::new(__data__::__data_Constant {
                                                        __variant: __data__::__variant_Constant::__data_TypeConstant(
                                                            ::std::rc::Rc::new(__data__::__data_TypeConstant {
                                                                m_type: ::std::cell::RefCell::new(None),
                                                                __variant: __data__::__variant_TypeConstant::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                Constant::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(referenced_type, static_type);
                __cto1
            }
            fn __nd_referenced_type(&self) -> Entity {
                self.m_type().unwrap()
            }
            fn __nd_clone_constant(&self, host: &Database) -> Entity {
                host.factory()
                    .create_type_constant_with_static_type(
                        &self.referenced_type(),
                        &self.static_type(host),
                    )
            }
            pub fn referenced_type(&self) -> Entity {
                self.__nd_referenced_type()
            }
            pub fn clone_constant(&self, host: &Database) -> Entity {
                self.__nd_clone_constant(host)
            }
            pub fn to<
                T: TryFrom<TypeConstant, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<TypeConstant, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl NumberConstant {
            #[allow(non_snake_case)]
            fn m_value(&self) -> Number {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_Constant(o) = &o.__variant
                    {
                        (if let __data__::__variant_Constant::__data_NumberConstant(o) = &o
                            .__variant
                        {
                            (&o.m_value)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_value(&self, v: Number) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_Constant(o) = &o.__variant
                    {
                        (if let __data__::__variant_Constant::__data_NumberConstant(o) = &o
                            .__variant
                        {
                            (&o.m_value)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, value: Number, static_type: &Entity) {
                self.set_m_value(value);
            }
            pub(crate) fn new(
                arena: &EntityArena,
                value: Number,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = NumberConstant(
                    Constant(
                        Value(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Value(
                                            ::std::rc::Rc::new(__data__::__data_Value {
                                                m_static_type: ::std::cell::RefCell::new(None),
                                                __variant: __data__::__variant_Value::__data_Constant(
                                                    ::std::rc::Rc::new(__data__::__data_Constant {
                                                        __variant: __data__::__variant_Constant::__data_NumberConstant(
                                                            ::std::rc::Rc::new(__data__::__data_NumberConstant {
                                                                m_value: ::std::cell::RefCell::new(Number::Int(0)),
                                                                __variant: __data__::__variant_NumberConstant::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                Constant::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(value, static_type);
                __cto1
            }
            fn __nd_number_value(&self) -> Number {
                self.m_value()
            }
            fn __nd_clone_constant(&self, host: &Database) -> Entity {
                host.factory()
                    .create_number_constant(self.m_value(), &self.static_type(host))
            }
            pub fn number_value(&self) -> Number {
                self.__nd_number_value()
            }
            pub fn clone_constant(&self, host: &Database) -> Entity {
                self.__nd_clone_constant(host)
            }
            pub fn to<
                T: TryFrom<NumberConstant, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<NumberConstant, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl StringConstant {
            #[allow(non_snake_case)]
            fn m_value(&self) -> String {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_Constant(o) = &o.__variant
                    {
                        (if let __data__::__variant_Constant::__data_StringConstant(o) = &o
                            .__variant
                        {
                            (&o.m_value)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_value(&self, v: String) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_Constant(o) = &o.__variant
                    {
                        (if let __data__::__variant_Constant::__data_StringConstant(o) = &o
                            .__variant
                        {
                            (&o.m_value)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, value: String, static_type: &Entity) {
                self.set_m_value(value);
            }
            pub(crate) fn new(
                arena: &EntityArena,
                value: String,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = StringConstant(
                    Constant(
                        Value(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Value(
                                            ::std::rc::Rc::new(__data__::__data_Value {
                                                m_static_type: ::std::cell::RefCell::new(None),
                                                __variant: __data__::__variant_Value::__data_Constant(
                                                    ::std::rc::Rc::new(__data__::__data_Constant {
                                                        __variant: __data__::__variant_Constant::__data_StringConstant(
                                                            ::std::rc::Rc::new(__data__::__data_StringConstant {
                                                                m_value: ::std::cell::RefCell::new(String::new()),
                                                                __variant: __data__::__variant_StringConstant::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                Constant::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(value, static_type);
                __cto1
            }
            fn __nd_string_value(&self) -> String {
                self.m_value()
            }
            fn __nd_clone_constant(&self, host: &Database) -> Entity {
                host.factory()
                    .create_string_constant(self.m_value(), &self.static_type(host))
            }
            pub fn string_value(&self) -> String {
                self.__nd_string_value()
            }
            pub fn clone_constant(&self, host: &Database) -> Entity {
                self.__nd_clone_constant(host)
            }
            pub fn to<
                T: TryFrom<StringConstant, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<StringConstant, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl BooleanConstant {
            #[allow(non_snake_case)]
            fn m_value(&self) -> bool {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_Constant(o) = &o.__variant
                    {
                        (if let __data__::__variant_Constant::__data_BooleanConstant(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_value)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .get()
            }
            #[allow(non_snake_case)]
            fn set_m_value(&self, v: bool) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_Constant(o) = &o.__variant
                    {
                        (if let __data__::__variant_Constant::__data_BooleanConstant(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_value)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .set(v);
            }
            fn __ctor(&self, value: bool, static_type: &Entity) {
                self.set_m_value(value);
            }
            pub(crate) fn new(
                arena: &EntityArena,
                value: bool,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = BooleanConstant(
                    Constant(
                        Value(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Value(
                                            ::std::rc::Rc::new(__data__::__data_Value {
                                                m_static_type: ::std::cell::RefCell::new(None),
                                                __variant: __data__::__variant_Value::__data_Constant(
                                                    ::std::rc::Rc::new(__data__::__data_Constant {
                                                        __variant: __data__::__variant_Constant::__data_BooleanConstant(
                                                            ::std::rc::Rc::new(__data__::__data_BooleanConstant {
                                                                m_value: ::std::cell::Cell::new(true),
                                                                __variant: __data__::__variant_BooleanConstant::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                Constant::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(value, static_type);
                __cto1
            }
            fn __nd_boolean_value(&self) -> bool {
                self.m_value()
            }
            fn __nd_clone_constant(&self, host: &Database) -> Entity {
                host.factory()
                    .create_boolean_constant(self.m_value(), &self.static_type(host))
            }
            pub fn boolean_value(&self) -> bool {
                self.__nd_boolean_value()
            }
            pub fn clone_constant(&self, host: &Database) -> Entity {
                self.__nd_clone_constant(host)
            }
            pub fn to<
                T: TryFrom<BooleanConstant, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<BooleanConstant, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl ThisObject {
            fn __ctor(&self, static_type: &Entity) {}
            pub(crate) fn new(arena: &EntityArena, static_type: &Entity) -> Self {
                let __cto1 = ThisObject(
                    Value(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Value(
                                        ::std::rc::Rc::new(__data__::__data_Value {
                                            m_static_type: ::std::cell::RefCell::new(None),
                                            __variant: __data__::__variant_Value::__data_ThisObject(
                                                ::std::rc::Rc::new(__data__::__data_ThisObject {
                                                    __variant: __data__::__variant_ThisObject::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Value::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(static_type);
                __cto1
            }
            pub fn to<T: TryFrom<ThisObject, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<T: TryFrom<ThisObject, Error = ::hydroperfox_smodel::SModelError>>(
                &self,
            ) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl MetaProperty {
            fn __ctor(&self, static_type: &Entity) {}
            pub(crate) fn new(arena: &EntityArena, static_type: &Entity) -> Self {
                let __cto1 = MetaProperty(
                    Value(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Value(
                                        ::std::rc::Rc::new(__data__::__data_Value {
                                            m_static_type: ::std::cell::RefCell::new(None),
                                            __variant: __data__::__variant_Value::__data_MetaProperty(
                                                ::std::rc::Rc::new(__data__::__data_MetaProperty {
                                                    __variant: __data__::__variant_MetaProperty::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Value::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(static_type);
                __cto1
            }
            pub fn to<
                T: TryFrom<MetaProperty, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<MetaProperty, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl MetaEnvProperty {
            fn __ctor(&self, static_type: &Entity) {}
            pub(crate) fn new(arena: &EntityArena, static_type: &Entity) -> Self {
                let __cto1 = MetaEnvProperty(
                    Value(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Value(
                                        ::std::rc::Rc::new(__data__::__data_Value {
                                            m_static_type: ::std::cell::RefCell::new(None),
                                            __variant: __data__::__variant_Value::__data_MetaEnvProperty(
                                                ::std::rc::Rc::new(__data__::__data_MetaEnvProperty {
                                                    __variant: __data__::__variant_MetaEnvProperty::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Value::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(static_type);
                __cto1
            }
            pub fn to<
                T: TryFrom<MetaEnvProperty, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<MetaEnvProperty, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl ReferenceValue {
            fn __ctor(&self, static_type: &Entity) {}
            pub(crate) fn new(arena: &EntityArena, static_type: &Entity) -> Self {
                let __cto1 = ReferenceValue(
                    Value(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Value(
                                        ::std::rc::Rc::new(__data__::__data_Value {
                                            m_static_type: ::std::cell::RefCell::new(None),
                                            __variant: __data__::__variant_Value::__data_ReferenceValue(
                                                ::std::rc::Rc::new(__data__::__data_ReferenceValue {
                                                    __variant: __data__::__variant_ReferenceValue::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Value::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(static_type);
                __cto1
            }
            pub fn to<
                T: TryFrom<ReferenceValue, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<ReferenceValue, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl XmlReferenceValue {
            #[allow(non_snake_case)]
            fn m_base(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_XmlReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_base(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_XmlReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_qual(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_XmlReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_qual)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_qual(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_XmlReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_qual)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_key(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_XmlReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_key)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_key(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_XmlReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_key)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(
                &self,
                base: &Entity,
                qualifier: Option<Entity>,
                key: &Entity,
                static_type: &Entity,
            ) {
                self.set_m_base(Some(base.clone()));
                self.set_m_qual(qualifier);
                self.set_m_key(Some(key.clone()));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                base: &Entity,
                qualifier: Option<Entity>,
                key: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = XmlReferenceValue(
                    ReferenceValue(
                        Value(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Value(
                                            ::std::rc::Rc::new(__data__::__data_Value {
                                                m_static_type: ::std::cell::RefCell::new(None),
                                                __variant: __data__::__variant_Value::__data_ReferenceValue(
                                                    ::std::rc::Rc::new(__data__::__data_ReferenceValue {
                                                        __variant: __data__::__variant_ReferenceValue::__data_XmlReferenceValue(
                                                            ::std::rc::Rc::new(__data__::__data_XmlReferenceValue {
                                                                m_qual: ::std::cell::RefCell::new(None),
                                                                m_base: ::std::cell::RefCell::new(None),
                                                                m_key: ::std::cell::RefCell::new(None),
                                                                __variant: __data__::__variant_XmlReferenceValue::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                ReferenceValue::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(base, qualifier, key, static_type);
                __cto1
            }
            fn __nd_base(&self) -> Entity {
                self.m_base().unwrap()
            }
            fn __nd_qualifier(&self) -> Option<Entity> {
                self.m_qual()
            }
            fn __nd_key(&self) -> Entity {
                self.m_key().unwrap()
            }
            fn __nd_read_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_write_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_deletable(&self, host: &Database) -> bool {
                true
            }
            pub fn base(&self) -> Entity {
                self.__nd_base()
            }
            pub fn qualifier(&self) -> Option<Entity> {
                self.__nd_qualifier()
            }
            pub fn key(&self) -> Entity {
                self.__nd_key()
            }
            pub fn read_only(&self, host: &Database) -> bool {
                self.__nd_read_only(host)
            }
            pub fn write_only(&self, host: &Database) -> bool {
                self.__nd_write_only(host)
            }
            pub fn deletable(&self, host: &Database) -> bool {
                self.__nd_deletable(host)
            }
            pub fn to<
                T: TryFrom<XmlReferenceValue, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<XmlReferenceValue, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl DynamicReferenceValue {
            #[allow(non_snake_case)]
            fn m_base(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_DynamicReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_base(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_DynamicReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_qual(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_DynamicReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_qual)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_qual(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_DynamicReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_qual)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_key(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_DynamicReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_key)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_key(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_DynamicReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_key)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(
                &self,
                base: &Entity,
                qualifier: Option<Entity>,
                key: &Entity,
                static_type: &Entity,
            ) {
                self.set_m_base(Some(base.clone()));
                self.set_m_qual(qualifier);
                self.set_m_key(Some(key.clone()));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                base: &Entity,
                qualifier: Option<Entity>,
                key: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = DynamicReferenceValue(
                    ReferenceValue(
                        Value(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Value(
                                            ::std::rc::Rc::new(__data__::__data_Value {
                                                m_static_type: ::std::cell::RefCell::new(None),
                                                __variant: __data__::__variant_Value::__data_ReferenceValue(
                                                    ::std::rc::Rc::new(__data__::__data_ReferenceValue {
                                                        __variant: __data__::__variant_ReferenceValue::__data_DynamicReferenceValue(
                                                            ::std::rc::Rc::new(__data__::__data_DynamicReferenceValue {
                                                                m_base: ::std::cell::RefCell::new(None),
                                                                m_qual: ::std::cell::RefCell::new(None),
                                                                m_key: ::std::cell::RefCell::new(None),
                                                                __variant: __data__::__variant_DynamicReferenceValue::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                ReferenceValue::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(base, qualifier, key, static_type);
                __cto1
            }
            fn __nd_base(&self) -> Entity {
                self.m_base().unwrap()
            }
            fn __nd_qualifier(&self) -> Option<Entity> {
                self.m_qual()
            }
            fn __nd_key(&self) -> Entity {
                self.m_key().unwrap()
            }
            fn __nd_read_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_write_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_deletable(&self, host: &Database) -> bool {
                true
            }
            pub fn base(&self) -> Entity {
                self.__nd_base()
            }
            pub fn qualifier(&self) -> Option<Entity> {
                self.__nd_qualifier()
            }
            pub fn key(&self) -> Entity {
                self.__nd_key()
            }
            pub fn read_only(&self, host: &Database) -> bool {
                self.__nd_read_only(host)
            }
            pub fn write_only(&self, host: &Database) -> bool {
                self.__nd_write_only(host)
            }
            pub fn deletable(&self, host: &Database) -> bool {
                self.__nd_deletable(host)
            }
            pub fn to<
                T: TryFrom<
                        DynamicReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        DynamicReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl FixtureReferenceValue {
            #[allow(non_snake_case)]
            fn m_base(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_base(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_property(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_property)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_property(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_property)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, base: &Entity, property: &Entity, static_type: &Entity) {
                self.set_m_base(Some(base.clone()));
                self.set_m_property(Some(property.clone()));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                base: &Entity,
                property: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = FixtureReferenceValue(
                    ReferenceValue(
                        Value(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Value(
                                            ::std::rc::Rc::new(__data__::__data_Value {
                                                m_static_type: ::std::cell::RefCell::new(None),
                                                __variant: __data__::__variant_Value::__data_ReferenceValue(
                                                    ::std::rc::Rc::new(__data__::__data_ReferenceValue {
                                                        __variant: __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                                                            ::std::rc::Rc::new(__data__::__data_FixtureReferenceValue {
                                                                m_property: ::std::cell::RefCell::new(None),
                                                                m_base: ::std::cell::RefCell::new(None),
                                                                __variant: __data__::__variant_FixtureReferenceValue::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                ReferenceValue::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(base, property, static_type);
                __cto1
            }
            fn __nd_base(&self) -> Entity {
                self.m_base().unwrap()
            }
            fn __nd_property(&self) -> Entity {
                self.m_property().unwrap()
            }
            fn __nd_read_only(&self, host: &Database) -> bool {
                self.property().read_only(host)
            }
            fn __nd_write_only(&self, host: &Database) -> bool {
                self.property().write_only(host)
            }
            fn __nd_deletable(&self, host: &Database) -> bool {
                false
            }
            pub fn base(&self) -> Entity {
                self.__nd_base()
            }
            pub fn property(&self) -> Entity {
                self.__nd_property()
            }
            pub fn read_only(&self, host: &Database) -> bool {
                self.__nd_read_only(host)
            }
            pub fn write_only(&self, host: &Database) -> bool {
                self.__nd_write_only(host)
            }
            pub fn deletable(&self, host: &Database) -> bool {
                self.__nd_deletable(host)
            }
            pub fn to<
                T: TryFrom<
                        FixtureReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        FixtureReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl StaticReferenceValue {
            fn __ctor(&self, base: &Entity, property: &Entity, static_type: &Entity) {}
            pub(crate) fn new(
                arena: &EntityArena,
                base: &Entity,
                property: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = StaticReferenceValue(
                    FixtureReferenceValue(
                        ReferenceValue(
                            Value(
                                Entity(
                                    arena
                                        .allocate(__data__::__data_Entity {
                                            __variant: __data__::__variant_Entity::__data_Value(
                                                ::std::rc::Rc::new(__data__::__data_Value {
                                                    m_static_type: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_Value::__data_ReferenceValue(
                                                        ::std::rc::Rc::new(__data__::__data_ReferenceValue {
                                                            __variant: __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                                                                ::std::rc::Rc::new(__data__::__data_FixtureReferenceValue {
                                                                    m_property: ::std::cell::RefCell::new(None),
                                                                    m_base: ::std::cell::RefCell::new(None),
                                                                    __variant: __data__::__variant_FixtureReferenceValue::__data_StaticReferenceValue(
                                                                        ::std::rc::Rc::new(__data__::__data_StaticReferenceValue {
                                                                            __variant: __data__::__variant_StaticReferenceValue::__Nothing,
                                                                        }),
                                                                    ),
                                                                }),
                                                            ),
                                                        }),
                                                    ),
                                                }),
                                            ),
                                        })
                                        .clone(),
                                ),
                            ),
                        ),
                    ),
                );
                FixtureReferenceValue::__ctor(&__cto1.0, base, property, static_type);
                __cto1.__ctor(base, property, static_type);
                __cto1
            }
            pub fn to<
                T: TryFrom<
                        StaticReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        StaticReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl StaticDynamicReferenceValue {
            #[allow(non_snake_case)]
            fn m_base(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_StaticDynamicReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_base(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_StaticDynamicReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_qual(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_StaticDynamicReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_qual)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_qual(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_StaticDynamicReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_qual)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_key(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_StaticDynamicReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_key)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_key(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_StaticDynamicReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_key)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(
                &self,
                base: &Entity,
                qualifier: Option<Entity>,
                key: &Entity,
                static_type: &Entity,
            ) {
                self.set_m_base(Some(base.clone()));
                self.set_m_qual(qualifier);
                self.set_m_key(Some(key.clone()));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                base: &Entity,
                qualifier: Option<Entity>,
                key: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = StaticDynamicReferenceValue(
                    ReferenceValue(
                        Value(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Value(
                                            ::std::rc::Rc::new(__data__::__data_Value {
                                                m_static_type: ::std::cell::RefCell::new(None),
                                                __variant: __data__::__variant_Value::__data_ReferenceValue(
                                                    ::std::rc::Rc::new(__data__::__data_ReferenceValue {
                                                        __variant: __data__::__variant_ReferenceValue::__data_StaticDynamicReferenceValue(
                                                            ::std::rc::Rc::new(__data__::__data_StaticDynamicReferenceValue {
                                                                m_key: ::std::cell::RefCell::new(None),
                                                                m_qual: ::std::cell::RefCell::new(None),
                                                                m_base: ::std::cell::RefCell::new(None),
                                                                __variant: __data__::__variant_StaticDynamicReferenceValue::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                ReferenceValue::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(base, qualifier, key, static_type);
                __cto1
            }
            fn __nd_base(&self) -> Entity {
                self.m_base().unwrap()
            }
            fn __nd_qualifier(&self) -> Option<Entity> {
                self.m_qual()
            }
            fn __nd_key(&self) -> Entity {
                self.m_key().unwrap()
            }
            fn __nd_read_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_write_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_deletable(&self, host: &Database) -> bool {
                false
            }
            pub fn base(&self) -> Entity {
                self.__nd_base()
            }
            pub fn qualifier(&self) -> Option<Entity> {
                self.__nd_qualifier()
            }
            pub fn key(&self) -> Entity {
                self.__nd_key()
            }
            pub fn read_only(&self, host: &Database) -> bool {
                self.__nd_read_only(host)
            }
            pub fn write_only(&self, host: &Database) -> bool {
                self.__nd_write_only(host)
            }
            pub fn deletable(&self, host: &Database) -> bool {
                self.__nd_deletable(host)
            }
            pub fn to<
                T: TryFrom<
                        StaticDynamicReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        StaticDynamicReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl InstanceReferenceValue {
            fn __ctor(&self, base: &Entity, property: &Entity, static_type: &Entity) {}
            pub(crate) fn new(
                arena: &EntityArena,
                base: &Entity,
                property: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = InstanceReferenceValue(
                    FixtureReferenceValue(
                        ReferenceValue(
                            Value(
                                Entity(
                                    arena
                                        .allocate(__data__::__data_Entity {
                                            __variant: __data__::__variant_Entity::__data_Value(
                                                ::std::rc::Rc::new(__data__::__data_Value {
                                                    m_static_type: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_Value::__data_ReferenceValue(
                                                        ::std::rc::Rc::new(__data__::__data_ReferenceValue {
                                                            __variant: __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                                                                ::std::rc::Rc::new(__data__::__data_FixtureReferenceValue {
                                                                    m_property: ::std::cell::RefCell::new(None),
                                                                    m_base: ::std::cell::RefCell::new(None),
                                                                    __variant: __data__::__variant_FixtureReferenceValue::__data_InstanceReferenceValue(
                                                                        ::std::rc::Rc::new(__data__::__data_InstanceReferenceValue {
                                                                            __variant: __data__::__variant_InstanceReferenceValue::__Nothing,
                                                                        }),
                                                                    ),
                                                                }),
                                                            ),
                                                        }),
                                                    ),
                                                }),
                                            ),
                                        })
                                        .clone(),
                                ),
                            ),
                        ),
                    ),
                );
                FixtureReferenceValue::__ctor(&__cto1.0, base, property, static_type);
                __cto1.__ctor(base, property, static_type);
                __cto1
            }
            pub fn to<
                T: TryFrom<
                        InstanceReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        InstanceReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl TupleReferenceValue {
            #[allow(non_snake_case)]
            fn m_base(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_TupleReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_base(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_TupleReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_index(&self) -> usize {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_TupleReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_index)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_index(&self, v: usize) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_TupleReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_index)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, base: &Entity, index: usize, static_type: &Entity) {
                self.set_m_base(Some(base.clone()));
                self.set_m_index(index);
            }
            pub(crate) fn new(
                arena: &EntityArena,
                base: &Entity,
                index: usize,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = TupleReferenceValue(
                    ReferenceValue(
                        Value(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Value(
                                            ::std::rc::Rc::new(__data__::__data_Value {
                                                m_static_type: ::std::cell::RefCell::new(None),
                                                __variant: __data__::__variant_Value::__data_ReferenceValue(
                                                    ::std::rc::Rc::new(__data__::__data_ReferenceValue {
                                                        __variant: __data__::__variant_ReferenceValue::__data_TupleReferenceValue(
                                                            ::std::rc::Rc::new(__data__::__data_TupleReferenceValue {
                                                                m_index: ::std::cell::RefCell::new(0),
                                                                m_base: ::std::cell::RefCell::new(None),
                                                                __variant: __data__::__variant_TupleReferenceValue::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                ReferenceValue::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(base, index, static_type);
                __cto1
            }
            fn __nd_base(&self) -> Entity {
                self.m_base().unwrap()
            }
            fn __nd_tuple_index(&self) -> usize {
                self.m_index()
            }
            fn __nd_read_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_write_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_deletable(&self, host: &Database) -> bool {
                false
            }
            pub fn base(&self) -> Entity {
                self.__nd_base()
            }
            pub fn tuple_index(&self) -> usize {
                self.__nd_tuple_index()
            }
            pub fn read_only(&self, host: &Database) -> bool {
                self.__nd_read_only(host)
            }
            pub fn write_only(&self, host: &Database) -> bool {
                self.__nd_write_only(host)
            }
            pub fn deletable(&self, host: &Database) -> bool {
                self.__nd_deletable(host)
            }
            pub fn to<
                T: TryFrom<
                        TupleReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        TupleReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl ScopeReferenceValue {
            fn __ctor(&self, base: &Entity, property: &Entity, static_type: &Entity) {}
            pub(crate) fn new(
                arena: &EntityArena,
                base: &Entity,
                property: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = ScopeReferenceValue(
                    FixtureReferenceValue(
                        ReferenceValue(
                            Value(
                                Entity(
                                    arena
                                        .allocate(__data__::__data_Entity {
                                            __variant: __data__::__variant_Entity::__data_Value(
                                                ::std::rc::Rc::new(__data__::__data_Value {
                                                    m_static_type: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_Value::__data_ReferenceValue(
                                                        ::std::rc::Rc::new(__data__::__data_ReferenceValue {
                                                            __variant: __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                                                                ::std::rc::Rc::new(__data__::__data_FixtureReferenceValue {
                                                                    m_property: ::std::cell::RefCell::new(None),
                                                                    m_base: ::std::cell::RefCell::new(None),
                                                                    __variant: __data__::__variant_FixtureReferenceValue::__data_ScopeReferenceValue(
                                                                        ::std::rc::Rc::new(__data__::__data_ScopeReferenceValue {
                                                                            __variant: __data__::__variant_ScopeReferenceValue::__Nothing,
                                                                        }),
                                                                    ),
                                                                }),
                                                            ),
                                                        }),
                                                    ),
                                                }),
                                            ),
                                        })
                                        .clone(),
                                ),
                            ),
                        ),
                    ),
                );
                FixtureReferenceValue::__ctor(&__cto1.0, base, property, static_type);
                __cto1.__ctor(base, property, static_type);
                __cto1
            }
            pub fn to<
                T: TryFrom<
                        ScopeReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        ScopeReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl DynamicScopeReferenceValue {
            #[allow(non_snake_case)]
            fn m_base(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_DynamicScopeReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_base(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_DynamicScopeReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_qual(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_DynamicScopeReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_qual)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_qual(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_DynamicScopeReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_qual)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_key(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_DynamicScopeReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_key)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_key(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_DynamicScopeReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_key)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(
                &self,
                base: &Entity,
                qualifier: Option<Entity>,
                key: &Entity,
                static_type: &Entity,
            ) {
                self.set_m_base(Some(base.clone()));
                self.set_m_qual(qualifier);
                self.set_m_key(Some(key.clone()));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                base: &Entity,
                qualifier: Option<Entity>,
                key: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = DynamicScopeReferenceValue(
                    ReferenceValue(
                        Value(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Value(
                                            ::std::rc::Rc::new(__data__::__data_Value {
                                                m_static_type: ::std::cell::RefCell::new(None),
                                                __variant: __data__::__variant_Value::__data_ReferenceValue(
                                                    ::std::rc::Rc::new(__data__::__data_ReferenceValue {
                                                        __variant: __data__::__variant_ReferenceValue::__data_DynamicScopeReferenceValue(
                                                            ::std::rc::Rc::new(__data__::__data_DynamicScopeReferenceValue {
                                                                m_qual: ::std::cell::RefCell::new(None),
                                                                m_base: ::std::cell::RefCell::new(None),
                                                                m_key: ::std::cell::RefCell::new(None),
                                                                __variant: __data__::__variant_DynamicScopeReferenceValue::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                ReferenceValue::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(base, qualifier, key, static_type);
                __cto1
            }
            fn __nd_base(&self) -> Entity {
                self.m_base().unwrap()
            }
            fn __nd_qualifier(&self) -> Option<Entity> {
                self.m_qual()
            }
            fn __nd_key(&self) -> Entity {
                self.m_key().unwrap()
            }
            fn __nd_read_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_write_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_deletable(&self, host: &Database) -> bool {
                true
            }
            pub fn base(&self) -> Entity {
                self.__nd_base()
            }
            pub fn qualifier(&self) -> Option<Entity> {
                self.__nd_qualifier()
            }
            pub fn key(&self) -> Entity {
                self.__nd_key()
            }
            pub fn read_only(&self, host: &Database) -> bool {
                self.__nd_read_only(host)
            }
            pub fn write_only(&self, host: &Database) -> bool {
                self.__nd_write_only(host)
            }
            pub fn deletable(&self, host: &Database) -> bool {
                self.__nd_deletable(host)
            }
            pub fn to<
                T: TryFrom<
                        DynamicScopeReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        DynamicScopeReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl PackageReferenceValue {
            fn __ctor(&self, base: &Entity, property: &Entity, static_type: &Entity) {}
            pub(crate) fn new(
                arena: &EntityArena,
                base: &Entity,
                property: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = PackageReferenceValue(
                    FixtureReferenceValue(
                        ReferenceValue(
                            Value(
                                Entity(
                                    arena
                                        .allocate(__data__::__data_Entity {
                                            __variant: __data__::__variant_Entity::__data_Value(
                                                ::std::rc::Rc::new(__data__::__data_Value {
                                                    m_static_type: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_Value::__data_ReferenceValue(
                                                        ::std::rc::Rc::new(__data__::__data_ReferenceValue {
                                                            __variant: __data__::__variant_ReferenceValue::__data_FixtureReferenceValue(
                                                                ::std::rc::Rc::new(__data__::__data_FixtureReferenceValue {
                                                                    m_property: ::std::cell::RefCell::new(None),
                                                                    m_base: ::std::cell::RefCell::new(None),
                                                                    __variant: __data__::__variant_FixtureReferenceValue::__data_PackageReferenceValue(
                                                                        ::std::rc::Rc::new(__data__::__data_PackageReferenceValue {
                                                                            __variant: __data__::__variant_PackageReferenceValue::__Nothing,
                                                                        }),
                                                                    ),
                                                                }),
                                                            ),
                                                        }),
                                                    ),
                                                }),
                                            ),
                                        })
                                        .clone(),
                                ),
                            ),
                        ),
                    ),
                );
                FixtureReferenceValue::__ctor(&__cto1.0, base, property, static_type);
                __cto1.__ctor(base, property, static_type);
                __cto1
            }
            pub fn to<
                T: TryFrom<
                        PackageReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        PackageReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl ArrayElementReferenceValue {
            #[allow(non_snake_case)]
            fn m_base(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_ArrayElementReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_base(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_ArrayElementReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_key(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_ArrayElementReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_key)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_key(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_ArrayElementReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_key)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, base: &Entity, key: &Entity, static_type: &Entity) {
                self.set_m_base(Some(base.clone()));
                self.set_m_key(Some(key.clone()));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                base: &Entity,
                key: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = ArrayElementReferenceValue(
                    ReferenceValue(
                        Value(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Value(
                                            ::std::rc::Rc::new(__data__::__data_Value {
                                                m_static_type: ::std::cell::RefCell::new(None),
                                                __variant: __data__::__variant_Value::__data_ReferenceValue(
                                                    ::std::rc::Rc::new(__data__::__data_ReferenceValue {
                                                        __variant: __data__::__variant_ReferenceValue::__data_ArrayElementReferenceValue(
                                                            ::std::rc::Rc::new(__data__::__data_ArrayElementReferenceValue {
                                                                m_key: ::std::cell::RefCell::new(None),
                                                                m_base: ::std::cell::RefCell::new(None),
                                                                __variant: __data__::__variant_ArrayElementReferenceValue::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                ReferenceValue::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(base, key, static_type);
                __cto1
            }
            fn __nd_base(&self) -> Entity {
                self.m_base().unwrap()
            }
            fn __nd_key(&self) -> Entity {
                self.m_key().unwrap()
            }
            fn __nd_read_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_write_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_deletable(&self, host: &Database) -> bool {
                true
            }
            pub fn base(&self) -> Entity {
                self.__nd_base()
            }
            pub fn key(&self) -> Entity {
                self.__nd_key()
            }
            pub fn read_only(&self, host: &Database) -> bool {
                self.__nd_read_only(host)
            }
            pub fn write_only(&self, host: &Database) -> bool {
                self.__nd_write_only(host)
            }
            pub fn deletable(&self, host: &Database) -> bool {
                self.__nd_deletable(host)
            }
            pub fn to<
                T: TryFrom<
                        ArrayElementReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        ArrayElementReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl VectorElementReferenceValue {
            #[allow(non_snake_case)]
            fn m_base(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_VectorElementReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_base(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_VectorElementReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_base)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_key(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_VectorElementReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_key)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_key(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ReferenceValue(o) = &o
                        .__variant
                    {
                        (if let __data__::__variant_ReferenceValue::__data_VectorElementReferenceValue(
                            o,
                        ) = &o.__variant
                        {
                            (&o.m_key)
                        } else {
                            {
                                #[cold]
                                #[track_caller]
                                #[inline(never)]
                                const fn panic_cold_explicit() -> ! {
                                    ::core::panicking::panic_explicit()
                                }
                                panic_cold_explicit();
                            }
                        })
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, base: &Entity, key: &Entity, static_type: &Entity) {
                self.set_m_base(Some(base.clone()));
                self.set_m_key(Some(key.clone()));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                base: &Entity,
                key: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = VectorElementReferenceValue(
                    ReferenceValue(
                        Value(
                            Entity(
                                arena
                                    .allocate(__data__::__data_Entity {
                                        __variant: __data__::__variant_Entity::__data_Value(
                                            ::std::rc::Rc::new(__data__::__data_Value {
                                                m_static_type: ::std::cell::RefCell::new(None),
                                                __variant: __data__::__variant_Value::__data_ReferenceValue(
                                                    ::std::rc::Rc::new(__data__::__data_ReferenceValue {
                                                        __variant: __data__::__variant_ReferenceValue::__data_VectorElementReferenceValue(
                                                            ::std::rc::Rc::new(__data__::__data_VectorElementReferenceValue {
                                                                m_base: ::std::cell::RefCell::new(None),
                                                                m_key: ::std::cell::RefCell::new(None),
                                                                __variant: __data__::__variant_VectorElementReferenceValue::__Nothing,
                                                            }),
                                                        ),
                                                    }),
                                                ),
                                            }),
                                        ),
                                    })
                                    .clone(),
                            ),
                        ),
                    ),
                );
                ReferenceValue::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(base, key, static_type);
                __cto1
            }
            fn __nd_base(&self) -> Entity {
                self.m_base().unwrap()
            }
            fn __nd_key(&self) -> Entity {
                self.m_key().unwrap()
            }
            fn __nd_read_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_write_only(&self, host: &Database) -> bool {
                false
            }
            fn __nd_deletable(&self, host: &Database) -> bool {
                false
            }
            pub fn base(&self) -> Entity {
                self.__nd_base()
            }
            pub fn key(&self) -> Entity {
                self.__nd_key()
            }
            pub fn read_only(&self, host: &Database) -> bool {
                self.__nd_read_only(host)
            }
            pub fn write_only(&self, host: &Database) -> bool {
                self.__nd_write_only(host)
            }
            pub fn deletable(&self, host: &Database) -> bool {
                self.__nd_deletable(host)
            }
            pub fn to<
                T: TryFrom<
                        VectorElementReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        VectorElementReferenceValue,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl ConversionValue {
            #[allow(non_snake_case)]
            fn m_base(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ConversionValue(o) = &o
                        .__variant
                    {
                        (&o.m_base)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_base(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ConversionValue(o) = &o
                        .__variant
                    {
                        (&o.m_base)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_kind(&self) -> ConversionKind {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ConversionValue(o) = &o
                        .__variant
                    {
                        (&o.m_kind)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .get()
            }
            #[allow(non_snake_case)]
            fn set_m_kind(&self, v: ConversionKind) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ConversionValue(o) = &o
                        .__variant
                    {
                        (&o.m_kind)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .set(v);
            }
            #[allow(non_snake_case)]
            fn m_opt(&self) -> bool {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ConversionValue(o) = &o
                        .__variant
                    {
                        (&o.m_opt)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .get()
            }
            #[allow(non_snake_case)]
            fn set_m_opt(&self, v: bool) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ConversionValue(o) = &o
                        .__variant
                    {
                        (&o.m_opt)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .set(v);
            }
            #[allow(non_snake_case)]
            fn m_target(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ConversionValue(o) = &o
                        .__variant
                    {
                        (&o.m_target)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_target(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_ConversionValue(o) = &o
                        .__variant
                    {
                        (&o.m_target)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(
                &self,
                base: &Entity,
                variant: ConversionKind,
                opt: bool,
                target: &Entity,
                static_type: &Entity,
            ) {
                self.set_m_base(Some(base.clone()));
                self.set_m_kind(variant);
                self.set_m_opt(opt);
                self.set_m_target(Some(target.clone()));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                base: &Entity,
                variant: ConversionKind,
                opt: bool,
                target: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = ConversionValue(
                    Value(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Value(
                                        ::std::rc::Rc::new(__data__::__data_Value {
                                            m_static_type: ::std::cell::RefCell::new(None),
                                            __variant: __data__::__variant_Value::__data_ConversionValue(
                                                ::std::rc::Rc::new(__data__::__data_ConversionValue {
                                                    m_opt: ::std::cell::Cell::new(true),
                                                    m_base: ::std::cell::RefCell::new(None),
                                                    m_kind: ::std::cell::Cell::new(
                                                        ConversionKind::BetweenNumber,
                                                    ),
                                                    m_target: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_ConversionValue::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Value::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(base, variant, opt, target, static_type);
                __cto1
            }
            fn __nd_base(&self) -> Entity {
                self.m_base().unwrap()
            }
            fn __nd_conversion_kind(&self) -> ConversionKind {
                self.m_kind()
            }
            fn __nd_conversion_is_opt(&self) -> bool {
                self.m_opt()
            }
            fn __nd_conversion_target(&self) -> Entity {
                self.m_target().unwrap()
            }
            /// Original value.
            pub fn base(&self) -> Entity {
                self.__nd_base()
            }
            pub fn conversion_kind(&self) -> ConversionKind {
                self.__nd_conversion_kind()
            }
            /// Indicates whether the conversion has been performed by the `as` operator
            /// (rather than `T(v)` or implicit conversion) and the resulting type
            /// has been either escaped out of non nullable or made nullable.
            pub fn conversion_is_opt(&self) -> bool {
                self.__nd_conversion_is_opt()
            }
            pub fn conversion_target(&self) -> Entity {
                self.__nd_conversion_target()
            }
            pub fn to<
                T: TryFrom<ConversionValue, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<ConversionValue, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl NonNullValue {
            #[allow(non_snake_case)]
            fn m_base(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_NonNullValue(o) = &o
                        .__variant
                    {
                        (&o.m_base)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_base(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_NonNullValue(o) = &o
                        .__variant
                    {
                        (&o.m_base)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, base: &Entity, static_type: &Entity) {
                self.set_m_base(Some(base.clone()));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                base: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = NonNullValue(
                    Value(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Value(
                                        ::std::rc::Rc::new(__data__::__data_Value {
                                            m_static_type: ::std::cell::RefCell::new(None),
                                            __variant: __data__::__variant_Value::__data_NonNullValue(
                                                ::std::rc::Rc::new(__data__::__data_NonNullValue {
                                                    m_base: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_NonNullValue::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Value::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(base, static_type);
                __cto1
            }
            fn __nd_base(&self) -> Entity {
                self.m_base().unwrap()
            }
            /// Original value.
            pub fn base(&self) -> Entity {
                self.__nd_base()
            }
            pub fn to<
                T: TryFrom<NonNullValue, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<NonNullValue, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl LambdaObject {
            #[allow(non_snake_case)]
            fn m_activation(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_LambdaObject(o) = &o
                        .__variant
                    {
                        (&o.m_activation)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_activation(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_LambdaObject(o) = &o
                        .__variant
                    {
                        (&o.m_activation)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, activation: &Entity, static_type: &Entity) {
                self.set_m_activation(Some(activation.clone()));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                activation: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = LambdaObject(
                    Value(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Value(
                                        ::std::rc::Rc::new(__data__::__data_Value {
                                            m_static_type: ::std::cell::RefCell::new(None),
                                            __variant: __data__::__variant_Value::__data_LambdaObject(
                                                ::std::rc::Rc::new(__data__::__data_LambdaObject {
                                                    m_activation: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_LambdaObject::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Value::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(activation, static_type);
                __cto1
            }
            fn __nd_activation(&self) -> Option<Entity> {
                self.m_activation()
            }
            pub fn activation(&self) -> Option<Entity> {
                self.__nd_activation()
            }
            pub fn to<
                T: TryFrom<LambdaObject, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<LambdaObject, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl FilterValue {
            #[allow(non_snake_case)]
            fn m_scope(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_FilterValue(o) = &o
                        .__variant
                    {
                        (&o.m_scope)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_scope(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_Value(o) = &self
                    .0
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (if let __data__::__variant_Value::__data_FilterValue(o) = &o
                        .__variant
                    {
                        (&o.m_scope)
                    } else {
                        {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    })
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self, scope: &Entity, static_type: &Entity) {
                self.set_m_scope(Some(scope.clone()));
            }
            pub(crate) fn new(
                arena: &EntityArena,
                scope: &Entity,
                static_type: &Entity,
            ) -> Self {
                let __cto1 = FilterValue(
                    Value(
                        Entity(
                            arena
                                .allocate(__data__::__data_Entity {
                                    __variant: __data__::__variant_Entity::__data_Value(
                                        ::std::rc::Rc::new(__data__::__data_Value {
                                            m_static_type: ::std::cell::RefCell::new(None),
                                            __variant: __data__::__variant_Value::__data_FilterValue(
                                                ::std::rc::Rc::new(__data__::__data_FilterValue {
                                                    m_scope: ::std::cell::RefCell::new(None),
                                                    __variant: __data__::__variant_FilterValue::__Nothing,
                                                }),
                                            ),
                                        }),
                                    ),
                                })
                                .clone(),
                        ),
                    ),
                );
                Value::__ctor(&__cto1.0, static_type);
                __cto1.__ctor(scope, static_type);
                __cto1
            }
            fn __nd_scope(&self) -> Entity {
                self.m_scope().unwrap()
            }
            pub fn scope(&self) -> Entity {
                self.__nd_scope()
            }
            pub fn to<
                T: TryFrom<FilterValue, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<FilterValue, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl FieldResolution {
            #[allow(non_snake_case)]
            fn m_shorthand_resolution(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_FieldResolution(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_shorthand_resolution)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_shorthand_resolution(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_FieldResolution(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_shorthand_resolution)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_field_slot(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_FieldResolution(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_field_slot)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_field_slot(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_FieldResolution(o) = &self
                    .0
                    .0
                    .upgrade()
                    .unwrap()
                    .__variant
                {
                    (&o.m_field_slot)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self) {}
            pub(crate) fn new(arena: &EntityArena) -> Self {
                let __cto1 = FieldResolution(
                    Entity(
                        arena
                            .allocate(__data__::__data_Entity {
                                __variant: __data__::__variant_Entity::__data_FieldResolution(
                                    ::std::rc::Rc::new(__data__::__data_FieldResolution {
                                        m_field_slot: ::std::cell::RefCell::new(None),
                                        m_shorthand_resolution: ::std::cell::RefCell::new(None),
                                        __variant: __data__::__variant_FieldResolution::__Nothing,
                                    }),
                                ),
                            })
                            .clone(),
                    ),
                );
                Entity::__ctor(&__cto1.0);
                __cto1.__ctor();
                __cto1
            }
            fn __nd_shorthand_resolution(&self) -> Option<Entity> {
                self.m_shorthand_resolution()
            }
            fn __nd_set_shorthand_resolution(&self, value: Option<Entity>) {
                self.set_m_shorthand_resolution(value);
            }
            fn __nd_field_slot(&self) -> Option<Entity> {
                self.m_field_slot()
            }
            fn __nd_set_field_slot(&self, value: Option<Entity>) {
                self.set_m_field_slot(value);
            }
            pub fn shorthand_resolution(&self) -> Option<Entity> {
                self.__nd_shorthand_resolution()
            }
            pub fn set_shorthand_resolution(&self, value: Option<Entity>) {
                self.__nd_set_shorthand_resolution(value)
            }
            pub fn field_slot(&self) -> Option<Entity> {
                self.__nd_field_slot()
            }
            pub fn set_field_slot(&self, value: Option<Entity>) {
                self.__nd_set_field_slot(value)
            }
            pub fn to<
                T: TryFrom<FieldResolution, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<FieldResolution, Error = ::hydroperfox_smodel::SModelError>,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl DeclarativeFieldDestructuringResolution {
            #[allow(non_snake_case)]
            fn m_field_reference(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_DeclarativeFieldDestructuringResolution(
                    o,
                ) = &self.0.0.upgrade().unwrap().__variant
                {
                    (&o.m_field_reference)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_field_reference(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_DeclarativeFieldDestructuringResolution(
                    o,
                ) = &self.0.0.upgrade().unwrap().__variant
                {
                    (&o.m_field_reference)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_var_slot(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_DeclarativeFieldDestructuringResolution(
                    o,
                ) = &self.0.0.upgrade().unwrap().__variant
                {
                    (&o.m_var_slot)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_var_slot(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_DeclarativeFieldDestructuringResolution(
                    o,
                ) = &self.0.0.upgrade().unwrap().__variant
                {
                    (&o.m_var_slot)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self) {}
            pub(crate) fn new(arena: &EntityArena) -> Self {
                let __cto1 = DeclarativeFieldDestructuringResolution(
                    Entity(
                        arena
                            .allocate(__data__::__data_Entity {
                                __variant: __data__::__variant_Entity::__data_DeclarativeFieldDestructuringResolution(
                                    ::std::rc::Rc::new(__data__::__data_DeclarativeFieldDestructuringResolution {
                                        m_var_slot: ::std::cell::RefCell::new(None),
                                        m_field_reference: ::std::cell::RefCell::new(None),
                                        __variant: __data__::__variant_DeclarativeFieldDestructuringResolution::__Nothing,
                                    }),
                                ),
                            })
                            .clone(),
                    ),
                );
                Entity::__ctor(&__cto1.0);
                __cto1.__ctor();
                __cto1
            }
            fn __nd_field_reference(&self) -> Option<Entity> {
                self.m_field_reference()
            }
            fn __nd_set_field_reference(&self, value: Option<Entity>) {
                self.set_m_field_reference(value);
            }
            fn __nd_var_slot(&self) -> Option<Entity> {
                self.m_var_slot()
            }
            fn __nd_set_var_slot(&self, value: Option<Entity>) {
                self.set_m_var_slot(value);
            }
            /// Reference value, non-null value, or constant.
            pub fn field_reference(&self) -> Option<Entity> {
                self.__nd_field_reference()
            }
            /// Reference value, non-null value, or constant.
            pub fn set_field_reference(&self, value: Option<Entity>) {
                self.__nd_set_field_reference(value)
            }
            /// For fields without subpatterns, indicates
            /// the assigned variable slot.
            pub fn var_slot(&self) -> Option<Entity> {
                self.__nd_var_slot()
            }
            /// For fields without subpatterns, indicates
            /// the assigned variable slot.
            pub fn set_var_slot(&self, value: Option<Entity>) {
                self.__nd_set_var_slot(value)
            }
            pub fn to<
                T: TryFrom<
                        DeclarativeFieldDestructuringResolution,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        DeclarativeFieldDestructuringResolution,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        impl AssignmentFieldDestructuringResolution {
            #[allow(non_snake_case)]
            fn m_field_reference(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_AssignmentFieldDestructuringResolution(
                    o,
                ) = &self.0.0.upgrade().unwrap().__variant
                {
                    (&o.m_field_reference)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_field_reference(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_AssignmentFieldDestructuringResolution(
                    o,
                ) = &self.0.0.upgrade().unwrap().__variant
                {
                    (&o.m_field_reference)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            #[allow(non_snake_case)]
            fn m_target_reference(&self) -> Option<Entity> {
                (if let __data__::__variant_Entity::__data_AssignmentFieldDestructuringResolution(
                    o,
                ) = &self.0.0.upgrade().unwrap().__variant
                {
                    (&o.m_target_reference)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .borrow()
                    .clone()
            }
            #[allow(non_snake_case)]
            fn set_m_target_reference(&self, v: Option<Entity>) {
                (if let __data__::__variant_Entity::__data_AssignmentFieldDestructuringResolution(
                    o,
                ) = &self.0.0.upgrade().unwrap().__variant
                {
                    (&o.m_target_reference)
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                })
                    .replace(v);
            }
            fn __ctor(&self) {}
            pub(crate) fn new(arena: &EntityArena) -> Self {
                let __cto1 = AssignmentFieldDestructuringResolution(
                    Entity(
                        arena
                            .allocate(__data__::__data_Entity {
                                __variant: __data__::__variant_Entity::__data_AssignmentFieldDestructuringResolution(
                                    ::std::rc::Rc::new(__data__::__data_AssignmentFieldDestructuringResolution {
                                        m_field_reference: ::std::cell::RefCell::new(None),
                                        m_target_reference: ::std::cell::RefCell::new(None),
                                        __variant: __data__::__variant_AssignmentFieldDestructuringResolution::__Nothing,
                                    }),
                                ),
                            })
                            .clone(),
                    ),
                );
                Entity::__ctor(&__cto1.0);
                __cto1.__ctor();
                __cto1
            }
            fn __nd_field_reference(&self) -> Option<Entity> {
                self.m_field_reference()
            }
            fn __nd_set_field_reference(&self, value: Option<Entity>) {
                self.set_m_field_reference(value);
            }
            fn __nd_target_reference(&self) -> Option<Entity> {
                self.m_target_reference()
            }
            fn __nd_set_target_reference(&self, value: Option<Entity>) {
                self.set_m_target_reference(value);
            }
            /// Reference value, non-null value, or constant.
            pub fn field_reference(&self) -> Option<Entity> {
                self.__nd_field_reference()
            }
            /// Reference value, non-null value, or constant.
            pub fn set_field_reference(&self, value: Option<Entity>) {
                self.__nd_set_field_reference(value)
            }
            /// For fields without subpatterns, indicates
            /// the target reference value.
            pub fn target_reference(&self) -> Option<Entity> {
                self.__nd_target_reference()
            }
            /// For fields without subpatterns, indicates
            /// the target reference value.
            pub fn set_target_reference(&self, value: Option<Entity>) {
                self.__nd_set_target_reference(value)
            }
            pub fn to<
                T: TryFrom<
                        AssignmentFieldDestructuringResolution,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> Result<T, ::hydroperfox_smodel::SModelError> {
                T::try_from(self.clone())
            }
            pub fn is<
                T: TryFrom<
                        AssignmentFieldDestructuringResolution,
                        Error = ::hydroperfox_smodel::SModelError,
                    >,
            >(&self) -> bool {
                T::try_from(self.clone()).is_ok()
            }
        }
        #[allow(non_camel_case_types, non_snake_case)]
        mod __data__ {
            use super::*;
            pub enum __variant_Entity {
                __data_UnresolvedEntity(::std::rc::Rc<__data_UnresolvedEntity>),
                __data_InvalidationEntity(::std::rc::Rc<__data_InvalidationEntity>),
                __data_Namespace(::std::rc::Rc<__data_Namespace>),
                __data_Package(::std::rc::Rc<__data_Package>),
                __data_Alias(::std::rc::Rc<__data_Alias>),
                __data_Type(::std::rc::Rc<__data_Type>),
                __data_VariableSlot(::std::rc::Rc<__data_VariableSlot>),
                __data_VirtualSlot(::std::rc::Rc<__data_VirtualSlot>),
                __data_MethodSlot(::std::rc::Rc<__data_MethodSlot>),
                __data_Scope(::std::rc::Rc<__data_Scope>),
                __data_Value(::std::rc::Rc<__data_Value>),
                __data_FieldResolution(::std::rc::Rc<__data_FieldResolution>),
                __data_DeclarativeFieldDestructuringResolution(
                    ::std::rc::Rc<__data_DeclarativeFieldDestructuringResolution>,
                ),
                __data_AssignmentFieldDestructuringResolution(
                    ::std::rc::Rc<__data_AssignmentFieldDestructuringResolution>,
                ),
                __Nothing,
            }
            pub struct __data_Entity {
                pub __variant: __variant_Entity,
            }
            pub enum __variant_UnresolvedEntity {
                __Nothing,
            }
            pub struct __data_UnresolvedEntity {
                pub __variant: __variant_UnresolvedEntity,
            }
            pub enum __variant_InvalidationEntity {
                __Nothing,
            }
            pub struct __data_InvalidationEntity {
                pub __variant: __variant_InvalidationEntity,
            }
            pub enum __variant_Namespace {
                __data_SystemNamespace(::std::rc::Rc<__data_SystemNamespace>),
                __data_UserNamespace(::std::rc::Rc<__data_UserNamespace>),
                __data_ExplicitNamespace(::std::rc::Rc<__data_ExplicitNamespace>),
                __Nothing,
            }
            pub struct __data_Namespace {
                pub __variant: __variant_Namespace,
            }
            pub enum __variant_SystemNamespace {
                __Nothing,
            }
            pub struct __data_SystemNamespace {
                pub m_kind: ::std::cell::Cell<SystemNamespaceKind>,
                pub m_parent: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_SystemNamespace,
            }
            pub enum __variant_UserNamespace {
                __Nothing,
            }
            pub struct __data_UserNamespace {
                pub m_uri: ::std::cell::RefCell<String>,
                pub __variant: __variant_UserNamespace,
            }
            pub enum __variant_ExplicitNamespace {
                __Nothing,
            }
            pub struct __data_ExplicitNamespace {
                pub m_uri: ::std::cell::RefCell<String>,
                pub __variant: __variant_ExplicitNamespace,
            }
            pub enum __variant_Package {
                __Nothing,
            }
            pub struct __data_Package {
                pub m_name: ::std::cell::RefCell<String>,
                pub m_parent: ::std::cell::RefCell<Option<Entity>>,
                pub m_public_ns: ::std::cell::RefCell<Option<Entity>>,
                pub m_internal_ns: ::std::cell::RefCell<Option<Entity>>,
                pub m_properties: ::std::cell::RefCell<Names>,
                pub m_subpackages: ::std::cell::RefCell<SharedMap<String, Entity>>,
                pub m_package_concats: ::std::cell::RefCell<SharedArray<Entity>>,
                pub m_asdoc: ::std::cell::RefCell<Option<Rc<Asdoc>>>,
                pub __variant: __variant_Package,
            }
            pub enum __variant_Alias {
                __Nothing,
            }
            pub struct __data_Alias {
                pub m_name: ::std::cell::RefCell<Option<QName>>,
                pub m_alias_of: ::std::cell::RefCell<Option<Entity>>,
                pub m_parent: ::std::cell::RefCell<Option<Entity>>,
                pub m_location: ::std::cell::RefCell<Option<Location>>,
                pub __variant: __variant_Alias,
            }
            pub enum __variant_Type {
                __data_AnyType(::std::rc::Rc<__data_AnyType>),
                __data_VoidType(::std::rc::Rc<__data_VoidType>),
                __data_ClassType(::std::rc::Rc<__data_ClassType>),
                __data_EnumType(::std::rc::Rc<__data_EnumType>),
                __data_InterfaceType(::std::rc::Rc<__data_InterfaceType>),
                __data_TypeAfterSubstitution(
                    ::std::rc::Rc<__data_TypeAfterSubstitution>,
                ),
                __data_TupleType(::std::rc::Rc<__data_TupleType>),
                __data_FunctionType(::std::rc::Rc<__data_FunctionType>),
                __data_NullableType(::std::rc::Rc<__data_NullableType>),
                __data_NonNullableType(::std::rc::Rc<__data_NonNullableType>),
                __data_TypeParameterType(::std::rc::Rc<__data_TypeParameterType>),
                __Nothing,
            }
            pub struct __data_Type {
                pub __variant: __variant_Type,
            }
            pub enum __variant_AnyType {
                __Nothing,
            }
            pub struct __data_AnyType {
                pub __variant: __variant_AnyType,
            }
            pub enum __variant_VoidType {
                __Nothing,
            }
            pub struct __data_VoidType {
                pub __variant: __variant_VoidType,
            }
            pub enum __variant_ClassType {
                __Nothing,
            }
            pub struct __data_ClassType {
                pub m_name: ::std::cell::RefCell<Option<QName>>,
                pub m_flags: ::std::cell::Cell<ClassTypeFlags>,
                pub m_type_params: ::std::cell::RefCell<Option<SharedArray<Entity>>>,
                pub m_extends_class: ::std::cell::RefCell<Option<Entity>>,
                pub m_implements: ::std::cell::RefCell<SharedArray<Entity>>,
                pub m_known_subclasses: ::std::cell::RefCell<SharedArray<Entity>>,
                pub m_constructor_method: ::std::cell::RefCell<Option<Entity>>,
                pub m_parent: ::std::cell::RefCell<Option<Entity>>,
                pub m_private_ns: ::std::cell::RefCell<Option<Entity>>,
                pub m_protected_ns: ::std::cell::RefCell<Option<Entity>>,
                pub m_static_protected_ns: ::std::cell::RefCell<Option<Entity>>,
                pub m_properties: ::std::cell::RefCell<Names>,
                pub m_prototype: ::std::cell::RefCell<Names>,
                pub m_events: ::std::cell::RefCell<SharedMap<String, Event>>,
                pub m_asdoc: ::std::cell::RefCell<Option<Rc<Asdoc>>>,
                pub m_metadata: ::std::cell::RefCell<SharedArray<Rc<Metadata>>>,
                pub m_location: ::std::cell::RefCell<Option<Location>>,
                pub __variant: __variant_ClassType,
            }
            pub enum __variant_EnumType {
                __Nothing,
            }
            pub struct __data_EnumType {
                pub m_name: ::std::cell::RefCell<Option<QName>>,
                pub m_parent: ::std::cell::RefCell<Option<Entity>>,
                pub m_private_ns: ::std::cell::RefCell<Option<Entity>>,
                pub m_properties: ::std::cell::RefCell<Names>,
                pub m_prototype: ::std::cell::RefCell<Names>,
                pub m_number_mapping: ::std::cell::RefCell<SharedMap<String, Number>>,
                pub m_slot_mapping: ::std::cell::RefCell<SharedMap<String, Entity>>,
                pub m_asdoc: ::std::cell::RefCell<Option<Rc<Asdoc>>>,
                pub m_metadata: ::std::cell::RefCell<SharedArray<Rc<Metadata>>>,
                pub m_location: ::std::cell::RefCell<Option<Location>>,
                pub __variant: __variant_EnumType,
            }
            pub enum __variant_InterfaceType {
                __Nothing,
            }
            pub struct __data_InterfaceType {
                pub m_name: ::std::cell::RefCell<Option<QName>>,
                pub m_type_params: ::std::cell::RefCell<Option<SharedArray<Entity>>>,
                pub m_events: ::std::cell::RefCell<SharedMap<String, Event>>,
                pub m_extends_interfaces: ::std::cell::RefCell<SharedArray<Entity>>,
                pub m_known_implementors: ::std::cell::RefCell<SharedArray<Entity>>,
                pub m_parent: ::std::cell::RefCell<Option<Entity>>,
                pub m_prototype: ::std::cell::RefCell<Names>,
                pub m_asdoc: ::std::cell::RefCell<Option<Rc<Asdoc>>>,
                pub m_metadata: ::std::cell::RefCell<SharedArray<Rc<Metadata>>>,
                pub m_location: ::std::cell::RefCell<Option<Location>>,
                pub __variant: __variant_InterfaceType,
            }
            pub enum __variant_TypeAfterSubstitution {
                __Nothing,
            }
            pub struct __data_TypeAfterSubstitution {
                pub m_origin: ::std::cell::RefCell<Option<Entity>>,
                pub m_substitute_types: ::std::cell::RefCell<SharedArray<Entity>>,
                pub m_extends_class: ::std::cell::RefCell<Option<Entity>>,
                pub m_implements: ::std::cell::RefCell<Option<SharedArray<Entity>>>,
                pub m_extends_interfaces: ::std::cell::RefCell<
                    Option<SharedArray<Entity>>,
                >,
                pub m_properties: ::std::cell::RefCell<Option<Names>>,
                pub m_prototype: ::std::cell::RefCell<Option<Names>>,
                pub m_constructor_method: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_TypeAfterSubstitution,
            }
            pub enum __variant_TupleType {
                __Nothing,
            }
            pub struct __data_TupleType {
                pub m_elements: ::std::cell::RefCell<SharedArray<Entity>>,
                pub __variant: __variant_TupleType,
            }
            pub enum __variant_FunctionType {
                __Nothing,
            }
            pub struct __data_FunctionType {
                pub m_params: ::std::cell::RefCell<
                    SharedArray<Rc<SemanticFunctionTypeParameter>>,
                >,
                pub m_result_type: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_FunctionType,
            }
            pub enum __variant_NullableType {
                __Nothing,
            }
            pub struct __data_NullableType {
                pub m_base: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_NullableType,
            }
            pub enum __variant_NonNullableType {
                __Nothing,
            }
            pub struct __data_NonNullableType {
                pub m_base: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_NonNullableType,
            }
            pub enum __variant_TypeParameterType {
                __Nothing,
            }
            pub struct __data_TypeParameterType {
                pub m_name: ::std::cell::RefCell<Option<QName>>,
                pub m_location: ::std::cell::RefCell<Option<Location>>,
                pub __variant: __variant_TypeParameterType,
            }
            pub enum __variant_VariableSlot {
                __data_OriginalVariableSlot(::std::rc::Rc<__data_OriginalVariableSlot>),
                __data_VariableSlotAfterSubstitution(
                    ::std::rc::Rc<__data_VariableSlotAfterSubstitution>,
                ),
                __Nothing,
            }
            pub struct __data_VariableSlot {
                pub __variant: __variant_VariableSlot,
            }
            pub enum __variant_OriginalVariableSlot {
                __Nothing,
            }
            pub struct __data_OriginalVariableSlot {
                pub m_name: ::std::cell::RefCell<Option<QName>>,
                pub m_location: ::std::cell::RefCell<Option<Location>>,
                pub m_asdoc: ::std::cell::RefCell<Option<Rc<Asdoc>>>,
                pub m_metadata: ::std::cell::RefCell<SharedArray<Rc<Metadata>>>,
                pub m_constant: ::std::cell::RefCell<Option<Entity>>,
                pub m_static_type: ::std::cell::RefCell<Option<Entity>>,
                pub m_parent: ::std::cell::RefCell<Option<Entity>>,
                pub m_flags: ::std::cell::Cell<VariableSlotFlags>,
                pub m_bindable_event: ::std::cell::RefCell<Option<String>>,
                pub __variant: __variant_OriginalVariableSlot,
            }
            pub enum __variant_VariableSlotAfterSubstitution {
                __Nothing,
            }
            pub struct __data_VariableSlotAfterSubstitution {
                pub m_origin: ::std::cell::RefCell<Option<Entity>>,
                pub m_indirect_type_params: ::std::cell::RefCell<SharedArray<Entity>>,
                pub m_indirect_substitute_types: ::std::cell::RefCell<
                    SharedArray<Entity>,
                >,
                pub m_static_type: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_VariableSlotAfterSubstitution,
            }
            pub enum __variant_VirtualSlot {
                __data_OriginalVirtualSlot(::std::rc::Rc<__data_OriginalVirtualSlot>),
                __data_VirtualSlotAfterSubstitution(
                    ::std::rc::Rc<__data_VirtualSlotAfterSubstitution>,
                ),
                __Nothing,
            }
            pub struct __data_VirtualSlot {
                pub __variant: __variant_VirtualSlot,
            }
            pub enum __variant_OriginalVirtualSlot {
                __Nothing,
            }
            pub struct __data_OriginalVirtualSlot {
                pub m_name: ::std::cell::RefCell<Option<QName>>,
                pub m_location: ::std::cell::RefCell<Option<Location>>,
                pub m_asdoc: ::std::cell::RefCell<Option<Rc<Asdoc>>>,
                pub m_getter: ::std::cell::RefCell<Option<Entity>>,
                pub m_setter: ::std::cell::RefCell<Option<Entity>>,
                pub m_static_type: ::std::cell::RefCell<Option<Entity>>,
                pub m_parent: ::std::cell::RefCell<Option<Entity>>,
                pub m_flags: ::std::cell::Cell<VirtualSlotFlags>,
                pub m_bindable_event: ::std::cell::RefCell<Option<String>>,
                pub __variant: __variant_OriginalVirtualSlot,
            }
            pub enum __variant_VirtualSlotAfterSubstitution {
                __Nothing,
            }
            pub struct __data_VirtualSlotAfterSubstitution {
                pub m_origin: ::std::cell::RefCell<Option<Entity>>,
                pub m_indirect_type_params: ::std::cell::RefCell<SharedArray<Entity>>,
                pub m_indirect_substitute_types: ::std::cell::RefCell<
                    SharedArray<Entity>,
                >,
                pub m_getter: ::std::cell::RefCell<Option<Entity>>,
                pub m_setter: ::std::cell::RefCell<Option<Entity>>,
                pub m_static_type: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_VirtualSlotAfterSubstitution,
            }
            pub enum __variant_MethodSlot {
                __data_OriginalMethodSlot(::std::rc::Rc<__data_OriginalMethodSlot>),
                __data_MethodSlotAfterSubstitution(
                    ::std::rc::Rc<__data_MethodSlotAfterSubstitution>,
                ),
                __Nothing,
            }
            pub struct __data_MethodSlot {
                pub __variant: __variant_MethodSlot,
            }
            pub enum __variant_OriginalMethodSlot {
                __Nothing,
            }
            pub struct __data_OriginalMethodSlot {
                pub m_name: ::std::cell::RefCell<Option<QName>>,
                pub m_location: ::std::cell::RefCell<Option<Location>>,
                pub m_asdoc: ::std::cell::RefCell<Option<Rc<Asdoc>>>,
                pub m_metadata: ::std::cell::RefCell<SharedArray<Rc<Metadata>>>,
                pub m_activation: ::std::cell::RefCell<Option<Entity>>,
                pub m_signature: ::std::cell::RefCell<Option<Entity>>,
                pub m_parent: ::std::cell::RefCell<Option<Entity>>,
                pub m_of_virtual_slot: ::std::cell::RefCell<Option<Entity>>,
                pub m_overriden_by: ::std::cell::RefCell<SharedArray<Entity>>,
                pub m_overrides_method: ::std::cell::RefCell<Option<Entity>>,
                pub m_flags: ::std::cell::Cell<MethodSlotFlags>,
                pub __variant: __variant_OriginalMethodSlot,
            }
            pub enum __variant_MethodSlotAfterSubstitution {
                __Nothing,
            }
            pub struct __data_MethodSlotAfterSubstitution {
                pub m_origin: ::std::cell::RefCell<Option<Entity>>,
                pub m_indirect_type_params: ::std::cell::RefCell<SharedArray<Entity>>,
                pub m_indirect_substitute_types: ::std::cell::RefCell<
                    SharedArray<Entity>,
                >,
                pub m_signature: ::std::cell::RefCell<Option<Entity>>,
                pub m_of_virtual_slot: ::std::cell::RefCell<Option<Entity>>,
                pub m_overriden_by: ::std::cell::RefCell<Option<SharedArray<Entity>>>,
                pub m_overrides_method: ::std::cell::RefCell<Option<Entity>>,
                pub m_is_overriding: ::std::cell::Cell<bool>,
                pub __variant: __variant_MethodSlotAfterSubstitution,
            }
            pub enum __variant_Scope {
                __data_WithScope(::std::rc::Rc<__data_WithScope>),
                __data_FilterScope(::std::rc::Rc<__data_FilterScope>),
                __data_Activation(::std::rc::Rc<__data_Activation>),
                __data_FixtureScope(::std::rc::Rc<__data_FixtureScope>),
                __Nothing,
            }
            pub struct __data_Scope {
                pub m_parent: ::std::cell::RefCell<Option<Entity>>,
                pub m_properties: ::std::cell::RefCell<Names>,
                pub m_open_ns_set: ::std::cell::RefCell<SharedArray<Entity>>,
                pub m_import_list: ::std::cell::RefCell<SharedArray<Entity>>,
                pub __variant: __variant_Scope,
            }
            pub enum __variant_WithScope {
                __Nothing,
            }
            pub struct __data_WithScope {
                pub m_object: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_WithScope,
            }
            pub enum __variant_FilterScope {
                __Nothing,
            }
            pub struct __data_FilterScope {
                pub m_base: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_FilterScope,
            }
            pub enum __variant_Activation {
                __Nothing,
            }
            pub struct __data_Activation {
                pub m_kind: ::std::cell::Cell<u8>,
                pub m_method: ::std::cell::RefCell<Option<Entity>>,
                pub m_this: ::std::cell::RefCell<Option<Entity>>,
                pub m_property_has_capture: ::std::cell::RefCell<
                    Option<SharedArray<Entity>>,
                >,
                pub m_cfg: ::std::cell::RefCell<ControlFlowGraph>,
                pub m_public_ns: ::std::cell::RefCell<Option<Entity>>,
                pub m_internal_ns: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_Activation,
            }
            pub enum __variant_FixtureScope {
                __data_ClassScope(::std::rc::Rc<__data_ClassScope>),
                __data_EnumScope(::std::rc::Rc<__data_EnumScope>),
                __data_InterfaceScope(::std::rc::Rc<__data_InterfaceScope>),
                __data_PackageScope(::std::rc::Rc<__data_PackageScope>),
                __Nothing,
            }
            pub struct __data_FixtureScope {
                pub __variant: __variant_FixtureScope,
            }
            pub enum __variant_ClassScope {
                __Nothing,
            }
            pub struct __data_ClassScope {
                pub m_class: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_ClassScope,
            }
            pub enum __variant_EnumScope {
                __Nothing,
            }
            pub struct __data_EnumScope {
                pub m_class: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_EnumScope,
            }
            pub enum __variant_InterfaceScope {
                __Nothing,
            }
            pub struct __data_InterfaceScope {
                pub m_itrfc: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_InterfaceScope,
            }
            pub enum __variant_PackageScope {
                __Nothing,
            }
            pub struct __data_PackageScope {
                pub m_pckg: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_PackageScope,
            }
            pub enum __variant_Value {
                __data_PackagePropertyImport(
                    ::std::rc::Rc<__data_PackagePropertyImport>,
                ),
                __data_PackageWildcardImport(
                    ::std::rc::Rc<__data_PackageWildcardImport>,
                ),
                __data_PackageRecursiveImport(
                    ::std::rc::Rc<__data_PackageRecursiveImport>,
                ),
                __data_Constant(::std::rc::Rc<__data_Constant>),
                __data_ThisObject(::std::rc::Rc<__data_ThisObject>),
                __data_MetaProperty(::std::rc::Rc<__data_MetaProperty>),
                __data_MetaEnvProperty(::std::rc::Rc<__data_MetaEnvProperty>),
                __data_ReferenceValue(::std::rc::Rc<__data_ReferenceValue>),
                __data_ConversionValue(::std::rc::Rc<__data_ConversionValue>),
                __data_NonNullValue(::std::rc::Rc<__data_NonNullValue>),
                __data_LambdaObject(::std::rc::Rc<__data_LambdaObject>),
                __data_FilterValue(::std::rc::Rc<__data_FilterValue>),
                __Nothing,
            }
            pub struct __data_Value {
                pub m_static_type: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_Value,
            }
            pub enum __variant_PackagePropertyImport {
                __Nothing,
            }
            pub struct __data_PackagePropertyImport {
                pub m_property: ::std::cell::RefCell<Option<Entity>>,
                pub m_location: ::std::cell::RefCell<Option<Location>>,
                pub __variant: __variant_PackagePropertyImport,
            }
            pub enum __variant_PackageWildcardImport {
                __Nothing,
            }
            pub struct __data_PackageWildcardImport {
                pub m_package: ::std::cell::RefCell<Option<Entity>>,
                pub m_location: ::std::cell::RefCell<Option<Location>>,
                pub __variant: __variant_PackageWildcardImport,
            }
            pub enum __variant_PackageRecursiveImport {
                __Nothing,
            }
            pub struct __data_PackageRecursiveImport {
                pub m_package: ::std::cell::RefCell<Option<Entity>>,
                pub m_location: ::std::cell::RefCell<Option<Location>>,
                pub __variant: __variant_PackageRecursiveImport,
            }
            pub enum __variant_Constant {
                __data_UndefinedConstant(::std::rc::Rc<__data_UndefinedConstant>),
                __data_NullConstant(::std::rc::Rc<__data_NullConstant>),
                __data_NamespaceConstant(::std::rc::Rc<__data_NamespaceConstant>),
                __data_TypeConstant(::std::rc::Rc<__data_TypeConstant>),
                __data_NumberConstant(::std::rc::Rc<__data_NumberConstant>),
                __data_StringConstant(::std::rc::Rc<__data_StringConstant>),
                __data_BooleanConstant(::std::rc::Rc<__data_BooleanConstant>),
                __Nothing,
            }
            pub struct __data_Constant {
                pub __variant: __variant_Constant,
            }
            pub enum __variant_UndefinedConstant {
                __Nothing,
            }
            pub struct __data_UndefinedConstant {
                pub __variant: __variant_UndefinedConstant,
            }
            pub enum __variant_NullConstant {
                __Nothing,
            }
            pub struct __data_NullConstant {
                pub __variant: __variant_NullConstant,
            }
            pub enum __variant_NamespaceConstant {
                __Nothing,
            }
            pub struct __data_NamespaceConstant {
                pub m_ns: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_NamespaceConstant,
            }
            pub enum __variant_TypeConstant {
                __Nothing,
            }
            pub struct __data_TypeConstant {
                pub m_type: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_TypeConstant,
            }
            pub enum __variant_NumberConstant {
                __Nothing,
            }
            pub struct __data_NumberConstant {
                pub m_value: ::std::cell::RefCell<Number>,
                pub __variant: __variant_NumberConstant,
            }
            pub enum __variant_StringConstant {
                __Nothing,
            }
            pub struct __data_StringConstant {
                pub m_value: ::std::cell::RefCell<String>,
                pub __variant: __variant_StringConstant,
            }
            pub enum __variant_BooleanConstant {
                __Nothing,
            }
            pub struct __data_BooleanConstant {
                pub m_value: ::std::cell::Cell<bool>,
                pub __variant: __variant_BooleanConstant,
            }
            pub enum __variant_ThisObject {
                __Nothing,
            }
            pub struct __data_ThisObject {
                pub __variant: __variant_ThisObject,
            }
            pub enum __variant_MetaProperty {
                __Nothing,
            }
            pub struct __data_MetaProperty {
                pub __variant: __variant_MetaProperty,
            }
            pub enum __variant_MetaEnvProperty {
                __Nothing,
            }
            pub struct __data_MetaEnvProperty {
                pub __variant: __variant_MetaEnvProperty,
            }
            pub enum __variant_ReferenceValue {
                __data_XmlReferenceValue(::std::rc::Rc<__data_XmlReferenceValue>),
                __data_DynamicReferenceValue(
                    ::std::rc::Rc<__data_DynamicReferenceValue>,
                ),
                __data_FixtureReferenceValue(
                    ::std::rc::Rc<__data_FixtureReferenceValue>,
                ),
                __data_StaticDynamicReferenceValue(
                    ::std::rc::Rc<__data_StaticDynamicReferenceValue>,
                ),
                __data_TupleReferenceValue(::std::rc::Rc<__data_TupleReferenceValue>),
                __data_DynamicScopeReferenceValue(
                    ::std::rc::Rc<__data_DynamicScopeReferenceValue>,
                ),
                __data_ArrayElementReferenceValue(
                    ::std::rc::Rc<__data_ArrayElementReferenceValue>,
                ),
                __data_VectorElementReferenceValue(
                    ::std::rc::Rc<__data_VectorElementReferenceValue>,
                ),
                __Nothing,
            }
            pub struct __data_ReferenceValue {
                pub __variant: __variant_ReferenceValue,
            }
            pub enum __variant_XmlReferenceValue {
                __Nothing,
            }
            pub struct __data_XmlReferenceValue {
                pub m_base: ::std::cell::RefCell<Option<Entity>>,
                pub m_qual: ::std::cell::RefCell<Option<Entity>>,
                pub m_key: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_XmlReferenceValue,
            }
            pub enum __variant_DynamicReferenceValue {
                __Nothing,
            }
            pub struct __data_DynamicReferenceValue {
                pub m_base: ::std::cell::RefCell<Option<Entity>>,
                pub m_qual: ::std::cell::RefCell<Option<Entity>>,
                pub m_key: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_DynamicReferenceValue,
            }
            pub enum __variant_FixtureReferenceValue {
                __data_StaticReferenceValue(::std::rc::Rc<__data_StaticReferenceValue>),
                __data_InstanceReferenceValue(
                    ::std::rc::Rc<__data_InstanceReferenceValue>,
                ),
                __data_ScopeReferenceValue(::std::rc::Rc<__data_ScopeReferenceValue>),
                __data_PackageReferenceValue(
                    ::std::rc::Rc<__data_PackageReferenceValue>,
                ),
                __Nothing,
            }
            pub struct __data_FixtureReferenceValue {
                pub m_base: ::std::cell::RefCell<Option<Entity>>,
                pub m_property: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_FixtureReferenceValue,
            }
            pub enum __variant_StaticReferenceValue {
                __Nothing,
            }
            pub struct __data_StaticReferenceValue {
                pub __variant: __variant_StaticReferenceValue,
            }
            pub enum __variant_StaticDynamicReferenceValue {
                __Nothing,
            }
            pub struct __data_StaticDynamicReferenceValue {
                pub m_base: ::std::cell::RefCell<Option<Entity>>,
                pub m_qual: ::std::cell::RefCell<Option<Entity>>,
                pub m_key: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_StaticDynamicReferenceValue,
            }
            pub enum __variant_InstanceReferenceValue {
                __Nothing,
            }
            pub struct __data_InstanceReferenceValue {
                pub __variant: __variant_InstanceReferenceValue,
            }
            pub enum __variant_TupleReferenceValue {
                __Nothing,
            }
            pub struct __data_TupleReferenceValue {
                pub m_base: ::std::cell::RefCell<Option<Entity>>,
                pub m_index: ::std::cell::RefCell<usize>,
                pub __variant: __variant_TupleReferenceValue,
            }
            pub enum __variant_ScopeReferenceValue {
                __Nothing,
            }
            pub struct __data_ScopeReferenceValue {
                pub __variant: __variant_ScopeReferenceValue,
            }
            pub enum __variant_DynamicScopeReferenceValue {
                __Nothing,
            }
            pub struct __data_DynamicScopeReferenceValue {
                pub m_base: ::std::cell::RefCell<Option<Entity>>,
                pub m_qual: ::std::cell::RefCell<Option<Entity>>,
                pub m_key: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_DynamicScopeReferenceValue,
            }
            pub enum __variant_PackageReferenceValue {
                __Nothing,
            }
            pub struct __data_PackageReferenceValue {
                pub __variant: __variant_PackageReferenceValue,
            }
            pub enum __variant_ArrayElementReferenceValue {
                __Nothing,
            }
            pub struct __data_ArrayElementReferenceValue {
                pub m_base: ::std::cell::RefCell<Option<Entity>>,
                pub m_key: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_ArrayElementReferenceValue,
            }
            pub enum __variant_VectorElementReferenceValue {
                __Nothing,
            }
            pub struct __data_VectorElementReferenceValue {
                pub m_base: ::std::cell::RefCell<Option<Entity>>,
                pub m_key: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_VectorElementReferenceValue,
            }
            pub enum __variant_ConversionValue {
                __Nothing,
            }
            pub struct __data_ConversionValue {
                pub m_base: ::std::cell::RefCell<Option<Entity>>,
                pub m_kind: ::std::cell::Cell<ConversionKind>,
                pub m_opt: ::std::cell::Cell<bool>,
                pub m_target: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_ConversionValue,
            }
            pub enum __variant_NonNullValue {
                __Nothing,
            }
            pub struct __data_NonNullValue {
                pub m_base: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_NonNullValue,
            }
            pub enum __variant_LambdaObject {
                __Nothing,
            }
            pub struct __data_LambdaObject {
                pub m_activation: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_LambdaObject,
            }
            pub enum __variant_FilterValue {
                __Nothing,
            }
            pub struct __data_FilterValue {
                pub m_scope: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_FilterValue,
            }
            pub enum __variant_FieldResolution {
                __Nothing,
            }
            pub struct __data_FieldResolution {
                pub m_shorthand_resolution: ::std::cell::RefCell<Option<Entity>>,
                pub m_field_slot: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_FieldResolution,
            }
            pub enum __variant_DeclarativeFieldDestructuringResolution {
                __Nothing,
            }
            pub struct __data_DeclarativeFieldDestructuringResolution {
                pub m_field_reference: ::std::cell::RefCell<Option<Entity>>,
                pub m_var_slot: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_DeclarativeFieldDestructuringResolution,
            }
            pub enum __variant_AssignmentFieldDestructuringResolution {
                __Nothing,
            }
            pub struct __data_AssignmentFieldDestructuringResolution {
                pub m_field_reference: ::std::cell::RefCell<Option<Entity>>,
                pub m_target_reference: ::std::cell::RefCell<Option<Entity>>,
                pub __variant: __variant_AssignmentFieldDestructuringResolution,
            }
        }
        impl ToString for Entity {
            fn to_string(&self) -> String {
                self.to_string_1()
            }
        }
        impl DiagnosticArgument for Entity {}
        pub enum SystemNamespaceKind {
            Public,
            Private,
            Protected,
            Internal,
            StaticProtected,
        }
        #[automatically_derived]
        impl ::core::marker::Copy for SystemNamespaceKind {}
        #[automatically_derived]
        impl ::core::clone::Clone for SystemNamespaceKind {
            #[inline]
            fn clone(&self) -> SystemNamespaceKind {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SystemNamespaceKind {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SystemNamespaceKind {
            #[inline]
            fn eq(&self, other: &SystemNamespaceKind) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        impl ToString for SystemNamespaceKind {
            fn to_string(&self) -> String {
                match self {
                    Self::Public => "public".into(),
                    Self::Private => "private".into(),
                    Self::Protected => "protected".into(),
                    Self::Internal => "internal".into(),
                    Self::StaticProtected => "static protected".into(),
                }
            }
        }
        /// A qualified name in ActionScript 3 consisting of
        /// a namespace and a local name.
        ///
        /// This structure is not intended for E4X, but for representing
        /// ActionScript 3 property names.
        ///
        /// # Representation
        ///
        /// `QName` in this codebase is a type managed by reference counting.
        /// Calling `.clone()` in it will clone by reference, not by content.
        pub struct QName(pub(crate) Rc<QName1>);
        #[automatically_derived]
        impl ::core::clone::Clone for QName {
            #[inline]
            fn clone(&self) -> QName {
                QName(::core::clone::Clone::clone(&self.0))
            }
        }
        impl QName {
            pub fn in_public_or_protected_ns(&self) -> bool {
                let ns = self.namespace();
                ns.is_public_ns() || ns.is_protected_ns()
            }
            pub fn namespace(&self) -> Entity {
                self.0.m_namespace.clone()
            }
            pub fn local_name(&self) -> String {
                self.0.m_local_name.clone()
            }
            pub fn matches_in_ns_set_or_any_public_ns(
                &self,
                ns_set: &SharedArray<Entity>,
                local_name: &str,
            ) -> bool {
                let ns1 = self.namespace();
                if !ns1.is_public_ns() {
                    let found_ns = ns_set.iter().find(|ns2| &ns1 == ns2).is_some();
                    if !found_ns {
                        return false;
                    }
                }
                self.local_name() == local_name
            }
        }
        impl std::hash::Hash for QName {
            fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
                Rc::as_ptr(&self.0).hash(state)
            }
        }
        impl PartialEq for QName {
            fn eq(&self, other: &Self) -> bool {
                Rc::ptr_eq(&self.0, &other.0)
            }
        }
        impl Eq for QName {}
        pub(crate) struct QName1 {
            pub(crate) m_namespace: Entity,
            pub(crate) m_local_name: String,
        }
        impl ToString for QName {
            fn to_string(&self) -> String {
                let q = self.namespace();
                let lname = self.local_name();
                if q.is::<SystemNamespace>() {
                    return lname;
                }
                ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!("{0}::{1}", q.uri(), lname),
                    );
                    res
                })
            }
        }
        impl DiagnosticArgument for QName {}
        struct ClassTypeFlags(
            <ClassTypeFlags as ::bitflags::__private::PublicFlags>::Internal,
        );
        #[automatically_derived]
        impl ::core::marker::Copy for ClassTypeFlags {}
        #[automatically_derived]
        impl ::core::clone::Clone for ClassTypeFlags {
            #[inline]
            fn clone(&self) -> ClassTypeFlags {
                let _: ::core::clone::AssertParamIsClone<
                    <ClassTypeFlags as ::bitflags::__private::PublicFlags>::Internal,
                >;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ClassTypeFlags {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ClassTypeFlags {
            #[inline]
            fn eq(&self, other: &ClassTypeFlags) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ClassTypeFlags {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<
                    <ClassTypeFlags as ::bitflags::__private::PublicFlags>::Internal,
                >;
            }
        }
        impl ClassTypeFlags {
            #[allow(deprecated, non_upper_case_globals)]
            pub const IS_FINAL: Self = Self::from_bits_retain(0b00000001);
            #[allow(deprecated, non_upper_case_globals)]
            pub const IS_STATIC: Self = Self::from_bits_retain(0b00000010);
            #[allow(deprecated, non_upper_case_globals)]
            pub const IS_ABSTRACT: Self = Self::from_bits_retain(0b00000100);
            #[allow(deprecated, non_upper_case_globals)]
            pub const IS_DYNAMIC: Self = Self::from_bits_retain(0b00001000);
            #[allow(deprecated, non_upper_case_globals)]
            pub const IS_OPTIONS_CLASS: Self = Self::from_bits_retain(0b00010000);
        }
        impl ::bitflags::Flags for ClassTypeFlags {
            const FLAGS: &'static [::bitflags::Flag<ClassTypeFlags>] = &[
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("IS_FINAL", ClassTypeFlags::IS_FINAL)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("IS_STATIC", ClassTypeFlags::IS_STATIC)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("IS_ABSTRACT", ClassTypeFlags::IS_ABSTRACT)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("IS_DYNAMIC", ClassTypeFlags::IS_DYNAMIC)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "IS_OPTIONS_CLASS",
                        ClassTypeFlags::IS_OPTIONS_CLASS,
                    )
                },
            ];
            type Bits = u16;
            fn bits(&self) -> u16 {
                ClassTypeFlags::bits(self)
            }
            fn from_bits_retain(bits: u16) -> ClassTypeFlags {
                ClassTypeFlags::from_bits_retain(bits)
            }
        }
        #[allow(
            dead_code,
            deprecated,
            unused_doc_comments,
            unused_attributes,
            unused_mut,
            unused_imports,
            non_upper_case_globals,
            clippy::assign_op_pattern,
            clippy::indexing_slicing,
            clippy::same_name_method,
            clippy::iter_without_into_iter,
        )]
        const _: () = {
            #[repr(transparent)]
            struct InternalBitFlags(u16);
            #[automatically_derived]
            impl ::core::clone::Clone for InternalBitFlags {
                #[inline]
                fn clone(&self) -> InternalBitFlags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for InternalBitFlags {
                #[inline]
                fn eq(&self, other: &InternalBitFlags) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for InternalBitFlags {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for InternalBitFlags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &InternalBitFlags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for InternalBitFlags {
                #[inline]
                fn cmp(&self, other: &InternalBitFlags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for InternalBitFlags {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            impl ::bitflags::__private::PublicFlags for ClassTypeFlags {
                type Primitive = u16;
                type Internal = InternalBitFlags;
            }
            impl ::bitflags::__private::core::default::Default for InternalBitFlags {
                #[inline]
                fn default() -> Self {
                    InternalBitFlags::empty()
                }
            }
            impl ::bitflags::__private::core::fmt::Debug for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                ) -> ::bitflags::__private::core::fmt::Result {
                    if self.is_empty() {
                        f.write_fmt(
                            format_args!("{0:#x}", <u16 as ::bitflags::Bits>::EMPTY),
                        )
                    } else {
                        ::bitflags::__private::core::fmt::Display::fmt(self, f)
                    }
                }
            }
            impl ::bitflags::__private::core::fmt::Display for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::parser::to_writer(&ClassTypeFlags(*self), f)
                }
            }
            impl ::bitflags::__private::core::str::FromStr for InternalBitFlags {
                type Err = ::bitflags::parser::ParseError;
                fn from_str(
                    s: &str,
                ) -> ::bitflags::__private::core::result::Result<Self, Self::Err> {
                    ::bitflags::parser::from_str::<ClassTypeFlags>(s)
                        .map(|flags| flags.0)
                }
            }
            impl ::bitflags::__private::core::convert::AsRef<u16> for InternalBitFlags {
                fn as_ref(&self) -> &u16 {
                    &self.0
                }
            }
            impl ::bitflags::__private::core::convert::From<u16> for InternalBitFlags {
                fn from(bits: u16) -> Self {
                    Self::from_bits_retain(bits)
                }
            }
            #[allow(dead_code, deprecated, unused_attributes)]
            impl InternalBitFlags {
                /// Get a flags value with all bits unset.
                #[inline]
                pub const fn empty() -> Self {
                    { Self(<u16 as ::bitflags::Bits>::EMPTY) }
                }
                /// Get a flags value with all known bits set.
                #[inline]
                pub const fn all() -> Self {
                    {
                        let mut truncated = <u16 as ::bitflags::Bits>::EMPTY;
                        let mut i = 0;
                        {
                            {
                                let flag = <ClassTypeFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <ClassTypeFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <ClassTypeFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <ClassTypeFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <ClassTypeFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        let _ = i;
                        Self::from_bits_retain(truncated)
                    }
                }
                /// Get the underlying bits value.
                ///
                /// The returned value is exactly the bits set in this flags value.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    let f = self;
                    { f.0 }
                }
                /// Convert from a bits value.
                ///
                /// This method will return `None` if any unknown bits are set.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let bits = bits;
                    {
                        let truncated = Self::from_bits_truncate(bits).0;
                        if truncated == bits {
                            ::bitflags::__private::core::option::Option::Some(Self(bits))
                        } else {
                            ::bitflags::__private::core::option::Option::None
                        }
                    }
                }
                /// Convert from a bits value, unsetting any unknown bits.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    let bits = bits;
                    { Self(bits & Self::all().bits()) }
                }
                /// Convert from a bits value exactly.
                #[inline]
                pub const fn from_bits_retain(bits: u16) -> Self {
                    let bits = bits;
                    { Self(bits) }
                }
                /// Get a flags value with the bits of a flag with the given name set.
                ///
                /// This method will return `None` if `name` is empty or doesn't
                /// correspond to any named flag.
                #[inline]
                pub fn from_name(
                    name: &str,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let name = name;
                    {
                        {
                            if name == "IS_FINAL" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(ClassTypeFlags::IS_FINAL.bits()),
                                );
                            }
                        };
                        {
                            if name == "IS_STATIC" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(ClassTypeFlags::IS_STATIC.bits()),
                                );
                            }
                        };
                        {
                            if name == "IS_ABSTRACT" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(ClassTypeFlags::IS_ABSTRACT.bits()),
                                );
                            }
                        };
                        {
                            if name == "IS_DYNAMIC" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(ClassTypeFlags::IS_DYNAMIC.bits()),
                                );
                            }
                        };
                        {
                            if name == "IS_OPTIONS_CLASS" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(ClassTypeFlags::IS_OPTIONS_CLASS.bits()),
                                );
                            }
                        };
                        let _ = name;
                        ::bitflags::__private::core::option::Option::None
                    }
                }
                /// Whether all bits in this flags value are unset.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    let f = self;
                    { f.bits() == <u16 as ::bitflags::Bits>::EMPTY }
                }
                /// Whether all known bits in this flags value are set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    let f = self;
                    { Self::all().bits() | f.bits() == f.bits() }
                }
                /// Whether any set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.bits() & other.bits() != <u16 as ::bitflags::Bits>::EMPTY }
                }
                /// Whether all set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.bits() & other.bits() == other.bits() }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        *f = Self::from_bits_retain(f.bits()).union(other);
                    }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `remove` won't truncate `other`, but the `!` operator will.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        *f = Self::from_bits_retain(f.bits()).difference(other);
                    }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        *f = Self::from_bits_retain(f.bits())
                            .symmetric_difference(other);
                    }
                }
                /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    let f = self;
                    let other = other;
                    let value = value;
                    {
                        if value {
                            f.insert(other);
                        } else {
                            f.remove(other);
                        }
                    }
                }
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() & other.bits()) }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() | other.bits()) }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() & !other.bits()) }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() ^ other.bits()) }
                }
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    let f = self;
                    { Self::from_bits_truncate(!f.bits()) }
                }
            }
            impl ::bitflags::__private::core::fmt::Binary for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::Octal for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::LowerHex for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::UpperHex for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::ops::BitOr for InternalBitFlags {
                type Output = Self;
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor(self, other: InternalBitFlags) -> Self {
                    self.union(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitOrAssign for InternalBitFlags {
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.insert(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitXor for InternalBitFlags {
                type Output = Self;
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    self.symmetric_difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitXorAssign for InternalBitFlags {
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.toggle(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitAnd for InternalBitFlags {
                type Output = Self;
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    self.intersection(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitAndAssign for InternalBitFlags {
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    *self = Self::from_bits_retain(self.bits()).intersection(other);
                }
            }
            impl ::bitflags::__private::core::ops::Sub for InternalBitFlags {
                type Output = Self;
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    self.difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::SubAssign for InternalBitFlags {
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.remove(other);
                }
            }
            impl ::bitflags::__private::core::ops::Not for InternalBitFlags {
                type Output = Self;
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                fn not(self) -> Self {
                    self.complement()
                }
            }
            impl ::bitflags::__private::core::iter::Extend<InternalBitFlags>
            for InternalBitFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn extend<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(&mut self, iterator: T) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::__private::core::iter::FromIterator<InternalBitFlags>
            for InternalBitFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn from_iter<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(iterator: T) -> Self {
                    use ::bitflags::__private::core::iter::Extend;
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl InternalBitFlags {
                /// Yield a set of contained flags values.
                ///
                /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                /// will be yielded together as a final flags value.
                #[inline]
                pub const fn iter(&self) -> ::bitflags::iter::Iter<ClassTypeFlags> {
                    ::bitflags::iter::Iter::__private_const_new(
                        <ClassTypeFlags as ::bitflags::Flags>::FLAGS,
                        ClassTypeFlags::from_bits_retain(self.bits()),
                        ClassTypeFlags::from_bits_retain(self.bits()),
                    )
                }
                /// Yield a set of contained named flags values.
                ///
                /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                #[inline]
                pub const fn iter_names(
                    &self,
                ) -> ::bitflags::iter::IterNames<ClassTypeFlags> {
                    ::bitflags::iter::IterNames::__private_const_new(
                        <ClassTypeFlags as ::bitflags::Flags>::FLAGS,
                        ClassTypeFlags::from_bits_retain(self.bits()),
                        ClassTypeFlags::from_bits_retain(self.bits()),
                    )
                }
            }
            impl ::bitflags::__private::core::iter::IntoIterator for InternalBitFlags {
                type Item = ClassTypeFlags;
                type IntoIter = ::bitflags::iter::Iter<ClassTypeFlags>;
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
            impl InternalBitFlags {
                /// Returns a mutable reference to the raw value of the flags currently stored.
                #[inline]
                pub fn bits_mut(&mut self) -> &mut u16 {
                    &mut self.0
                }
            }
            impl ::bitflags::__private::serde::Serialize for InternalBitFlags {
                fn serialize<S: ::bitflags::__private::serde::Serializer>(
                    &self,
                    serializer: S,
                ) -> ::bitflags::__private::core::result::Result<S::Ok, S::Error> {
                    ::bitflags::serde::serialize(
                        &ClassTypeFlags::from_bits_retain(self.bits()),
                        serializer,
                    )
                }
            }
            impl<'de> ::bitflags::__private::serde::Deserialize<'de>
            for InternalBitFlags {
                fn deserialize<D: ::bitflags::__private::serde::Deserializer<'de>>(
                    deserializer: D,
                ) -> ::bitflags::__private::core::result::Result<Self, D::Error> {
                    let flags: ClassTypeFlags = ::bitflags::serde::deserialize(
                        deserializer,
                    )?;
                    Ok(flags.0)
                }
            }
            #[allow(dead_code, deprecated, unused_attributes)]
            impl ClassTypeFlags {
                /// Get a flags value with all bits unset.
                #[inline]
                pub const fn empty() -> Self {
                    { Self(InternalBitFlags::empty()) }
                }
                /// Get a flags value with all known bits set.
                #[inline]
                pub const fn all() -> Self {
                    { Self(InternalBitFlags::all()) }
                }
                /// Get the underlying bits value.
                ///
                /// The returned value is exactly the bits set in this flags value.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    let f = self;
                    { f.0.bits() }
                }
                /// Convert from a bits value.
                ///
                /// This method will return `None` if any unknown bits are set.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let bits = bits;
                    {
                        match InternalBitFlags::from_bits(bits) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                }
                /// Convert from a bits value, unsetting any unknown bits.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    let bits = bits;
                    { Self(InternalBitFlags::from_bits_truncate(bits)) }
                }
                /// Convert from a bits value exactly.
                #[inline]
                pub const fn from_bits_retain(bits: u16) -> Self {
                    let bits = bits;
                    { Self(InternalBitFlags::from_bits_retain(bits)) }
                }
                /// Get a flags value with the bits of a flag with the given name set.
                ///
                /// This method will return `None` if `name` is empty or doesn't
                /// correspond to any named flag.
                #[inline]
                pub fn from_name(
                    name: &str,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let name = name;
                    {
                        match InternalBitFlags::from_name(name) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                }
                /// Whether all bits in this flags value are unset.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    let f = self;
                    { f.0.is_empty() }
                }
                /// Whether all known bits in this flags value are set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    let f = self;
                    { f.0.is_all() }
                }
                /// Whether any set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.0.intersects(other.0) }
                }
                /// Whether all set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.0.contains(other.0) }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.insert(other.0) }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `remove` won't truncate `other`, but the `!` operator will.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.remove(other.0) }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.toggle(other.0) }
                }
                /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    let f = self;
                    let other = other;
                    let value = value;
                    { f.0.set(other.0, value) }
                }
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.intersection(other.0)) }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.union(other.0)) }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.difference(other.0)) }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.symmetric_difference(other.0)) }
                }
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    let f = self;
                    { Self(f.0.complement()) }
                }
            }
            impl ::bitflags::__private::core::fmt::Binary for ClassTypeFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::Octal for ClassTypeFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::LowerHex for ClassTypeFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::UpperHex for ClassTypeFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::ops::BitOr for ClassTypeFlags {
                type Output = Self;
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor(self, other: ClassTypeFlags) -> Self {
                    self.union(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitOrAssign for ClassTypeFlags {
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.insert(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitXor for ClassTypeFlags {
                type Output = Self;
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    self.symmetric_difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitXorAssign for ClassTypeFlags {
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.toggle(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitAnd for ClassTypeFlags {
                type Output = Self;
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    self.intersection(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitAndAssign for ClassTypeFlags {
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    *self = Self::from_bits_retain(self.bits()).intersection(other);
                }
            }
            impl ::bitflags::__private::core::ops::Sub for ClassTypeFlags {
                type Output = Self;
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    self.difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::SubAssign for ClassTypeFlags {
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.remove(other);
                }
            }
            impl ::bitflags::__private::core::ops::Not for ClassTypeFlags {
                type Output = Self;
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                fn not(self) -> Self {
                    self.complement()
                }
            }
            impl ::bitflags::__private::core::iter::Extend<ClassTypeFlags>
            for ClassTypeFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn extend<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(&mut self, iterator: T) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::__private::core::iter::FromIterator<ClassTypeFlags>
            for ClassTypeFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn from_iter<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(iterator: T) -> Self {
                    use ::bitflags::__private::core::iter::Extend;
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ClassTypeFlags {
                /// Yield a set of contained flags values.
                ///
                /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                /// will be yielded together as a final flags value.
                #[inline]
                pub const fn iter(&self) -> ::bitflags::iter::Iter<ClassTypeFlags> {
                    ::bitflags::iter::Iter::__private_const_new(
                        <ClassTypeFlags as ::bitflags::Flags>::FLAGS,
                        ClassTypeFlags::from_bits_retain(self.bits()),
                        ClassTypeFlags::from_bits_retain(self.bits()),
                    )
                }
                /// Yield a set of contained named flags values.
                ///
                /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                #[inline]
                pub const fn iter_names(
                    &self,
                ) -> ::bitflags::iter::IterNames<ClassTypeFlags> {
                    ::bitflags::iter::IterNames::__private_const_new(
                        <ClassTypeFlags as ::bitflags::Flags>::FLAGS,
                        ClassTypeFlags::from_bits_retain(self.bits()),
                        ClassTypeFlags::from_bits_retain(self.bits()),
                    )
                }
            }
            impl ::bitflags::__private::core::iter::IntoIterator for ClassTypeFlags {
                type Item = ClassTypeFlags;
                type IntoIter = ::bitflags::iter::Iter<ClassTypeFlags>;
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
        };
        struct VariableSlotFlags(
            <VariableSlotFlags as ::bitflags::__private::PublicFlags>::Internal,
        );
        #[automatically_derived]
        impl ::core::marker::Copy for VariableSlotFlags {}
        #[automatically_derived]
        impl ::core::clone::Clone for VariableSlotFlags {
            #[inline]
            fn clone(&self) -> VariableSlotFlags {
                let _: ::core::clone::AssertParamIsClone<
                    <VariableSlotFlags as ::bitflags::__private::PublicFlags>::Internal,
                >;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for VariableSlotFlags {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for VariableSlotFlags {
            #[inline]
            fn eq(&self, other: &VariableSlotFlags) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for VariableSlotFlags {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<
                    <VariableSlotFlags as ::bitflags::__private::PublicFlags>::Internal,
                >;
            }
        }
        impl VariableSlotFlags {
            #[allow(deprecated, non_upper_case_globals)]
            pub const READ_ONLY: Self = Self::from_bits_retain(0b00000010);
        }
        impl ::bitflags::Flags for VariableSlotFlags {
            const FLAGS: &'static [::bitflags::Flag<VariableSlotFlags>] = &[
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("READ_ONLY", VariableSlotFlags::READ_ONLY)
                },
            ];
            type Bits = u16;
            fn bits(&self) -> u16 {
                VariableSlotFlags::bits(self)
            }
            fn from_bits_retain(bits: u16) -> VariableSlotFlags {
                VariableSlotFlags::from_bits_retain(bits)
            }
        }
        #[allow(
            dead_code,
            deprecated,
            unused_doc_comments,
            unused_attributes,
            unused_mut,
            unused_imports,
            non_upper_case_globals,
            clippy::assign_op_pattern,
            clippy::indexing_slicing,
            clippy::same_name_method,
            clippy::iter_without_into_iter,
        )]
        const _: () = {
            #[repr(transparent)]
            struct InternalBitFlags(u16);
            #[automatically_derived]
            impl ::core::clone::Clone for InternalBitFlags {
                #[inline]
                fn clone(&self) -> InternalBitFlags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for InternalBitFlags {
                #[inline]
                fn eq(&self, other: &InternalBitFlags) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for InternalBitFlags {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for InternalBitFlags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &InternalBitFlags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for InternalBitFlags {
                #[inline]
                fn cmp(&self, other: &InternalBitFlags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for InternalBitFlags {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            impl ::bitflags::__private::PublicFlags for VariableSlotFlags {
                type Primitive = u16;
                type Internal = InternalBitFlags;
            }
            impl ::bitflags::__private::core::default::Default for InternalBitFlags {
                #[inline]
                fn default() -> Self {
                    InternalBitFlags::empty()
                }
            }
            impl ::bitflags::__private::core::fmt::Debug for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                ) -> ::bitflags::__private::core::fmt::Result {
                    if self.is_empty() {
                        f.write_fmt(
                            format_args!("{0:#x}", <u16 as ::bitflags::Bits>::EMPTY),
                        )
                    } else {
                        ::bitflags::__private::core::fmt::Display::fmt(self, f)
                    }
                }
            }
            impl ::bitflags::__private::core::fmt::Display for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::parser::to_writer(&VariableSlotFlags(*self), f)
                }
            }
            impl ::bitflags::__private::core::str::FromStr for InternalBitFlags {
                type Err = ::bitflags::parser::ParseError;
                fn from_str(
                    s: &str,
                ) -> ::bitflags::__private::core::result::Result<Self, Self::Err> {
                    ::bitflags::parser::from_str::<VariableSlotFlags>(s)
                        .map(|flags| flags.0)
                }
            }
            impl ::bitflags::__private::core::convert::AsRef<u16> for InternalBitFlags {
                fn as_ref(&self) -> &u16 {
                    &self.0
                }
            }
            impl ::bitflags::__private::core::convert::From<u16> for InternalBitFlags {
                fn from(bits: u16) -> Self {
                    Self::from_bits_retain(bits)
                }
            }
            #[allow(dead_code, deprecated, unused_attributes)]
            impl InternalBitFlags {
                /// Get a flags value with all bits unset.
                #[inline]
                pub const fn empty() -> Self {
                    { Self(<u16 as ::bitflags::Bits>::EMPTY) }
                }
                /// Get a flags value with all known bits set.
                #[inline]
                pub const fn all() -> Self {
                    {
                        let mut truncated = <u16 as ::bitflags::Bits>::EMPTY;
                        let mut i = 0;
                        {
                            {
                                let flag = <VariableSlotFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        let _ = i;
                        Self::from_bits_retain(truncated)
                    }
                }
                /// Get the underlying bits value.
                ///
                /// The returned value is exactly the bits set in this flags value.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    let f = self;
                    { f.0 }
                }
                /// Convert from a bits value.
                ///
                /// This method will return `None` if any unknown bits are set.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let bits = bits;
                    {
                        let truncated = Self::from_bits_truncate(bits).0;
                        if truncated == bits {
                            ::bitflags::__private::core::option::Option::Some(Self(bits))
                        } else {
                            ::bitflags::__private::core::option::Option::None
                        }
                    }
                }
                /// Convert from a bits value, unsetting any unknown bits.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    let bits = bits;
                    { Self(bits & Self::all().bits()) }
                }
                /// Convert from a bits value exactly.
                #[inline]
                pub const fn from_bits_retain(bits: u16) -> Self {
                    let bits = bits;
                    { Self(bits) }
                }
                /// Get a flags value with the bits of a flag with the given name set.
                ///
                /// This method will return `None` if `name` is empty or doesn't
                /// correspond to any named flag.
                #[inline]
                pub fn from_name(
                    name: &str,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let name = name;
                    {
                        {
                            if name == "READ_ONLY" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(VariableSlotFlags::READ_ONLY.bits()),
                                );
                            }
                        };
                        let _ = name;
                        ::bitflags::__private::core::option::Option::None
                    }
                }
                /// Whether all bits in this flags value are unset.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    let f = self;
                    { f.bits() == <u16 as ::bitflags::Bits>::EMPTY }
                }
                /// Whether all known bits in this flags value are set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    let f = self;
                    { Self::all().bits() | f.bits() == f.bits() }
                }
                /// Whether any set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.bits() & other.bits() != <u16 as ::bitflags::Bits>::EMPTY }
                }
                /// Whether all set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.bits() & other.bits() == other.bits() }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        *f = Self::from_bits_retain(f.bits()).union(other);
                    }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `remove` won't truncate `other`, but the `!` operator will.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        *f = Self::from_bits_retain(f.bits()).difference(other);
                    }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        *f = Self::from_bits_retain(f.bits())
                            .symmetric_difference(other);
                    }
                }
                /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    let f = self;
                    let other = other;
                    let value = value;
                    {
                        if value {
                            f.insert(other);
                        } else {
                            f.remove(other);
                        }
                    }
                }
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() & other.bits()) }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() | other.bits()) }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() & !other.bits()) }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() ^ other.bits()) }
                }
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    let f = self;
                    { Self::from_bits_truncate(!f.bits()) }
                }
            }
            impl ::bitflags::__private::core::fmt::Binary for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::Octal for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::LowerHex for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::UpperHex for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::ops::BitOr for InternalBitFlags {
                type Output = Self;
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor(self, other: InternalBitFlags) -> Self {
                    self.union(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitOrAssign for InternalBitFlags {
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.insert(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitXor for InternalBitFlags {
                type Output = Self;
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    self.symmetric_difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitXorAssign for InternalBitFlags {
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.toggle(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitAnd for InternalBitFlags {
                type Output = Self;
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    self.intersection(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitAndAssign for InternalBitFlags {
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    *self = Self::from_bits_retain(self.bits()).intersection(other);
                }
            }
            impl ::bitflags::__private::core::ops::Sub for InternalBitFlags {
                type Output = Self;
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    self.difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::SubAssign for InternalBitFlags {
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.remove(other);
                }
            }
            impl ::bitflags::__private::core::ops::Not for InternalBitFlags {
                type Output = Self;
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                fn not(self) -> Self {
                    self.complement()
                }
            }
            impl ::bitflags::__private::core::iter::Extend<InternalBitFlags>
            for InternalBitFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn extend<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(&mut self, iterator: T) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::__private::core::iter::FromIterator<InternalBitFlags>
            for InternalBitFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn from_iter<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(iterator: T) -> Self {
                    use ::bitflags::__private::core::iter::Extend;
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl InternalBitFlags {
                /// Yield a set of contained flags values.
                ///
                /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                /// will be yielded together as a final flags value.
                #[inline]
                pub const fn iter(&self) -> ::bitflags::iter::Iter<VariableSlotFlags> {
                    ::bitflags::iter::Iter::__private_const_new(
                        <VariableSlotFlags as ::bitflags::Flags>::FLAGS,
                        VariableSlotFlags::from_bits_retain(self.bits()),
                        VariableSlotFlags::from_bits_retain(self.bits()),
                    )
                }
                /// Yield a set of contained named flags values.
                ///
                /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                #[inline]
                pub const fn iter_names(
                    &self,
                ) -> ::bitflags::iter::IterNames<VariableSlotFlags> {
                    ::bitflags::iter::IterNames::__private_const_new(
                        <VariableSlotFlags as ::bitflags::Flags>::FLAGS,
                        VariableSlotFlags::from_bits_retain(self.bits()),
                        VariableSlotFlags::from_bits_retain(self.bits()),
                    )
                }
            }
            impl ::bitflags::__private::core::iter::IntoIterator for InternalBitFlags {
                type Item = VariableSlotFlags;
                type IntoIter = ::bitflags::iter::Iter<VariableSlotFlags>;
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
            impl InternalBitFlags {
                /// Returns a mutable reference to the raw value of the flags currently stored.
                #[inline]
                pub fn bits_mut(&mut self) -> &mut u16 {
                    &mut self.0
                }
            }
            impl ::bitflags::__private::serde::Serialize for InternalBitFlags {
                fn serialize<S: ::bitflags::__private::serde::Serializer>(
                    &self,
                    serializer: S,
                ) -> ::bitflags::__private::core::result::Result<S::Ok, S::Error> {
                    ::bitflags::serde::serialize(
                        &VariableSlotFlags::from_bits_retain(self.bits()),
                        serializer,
                    )
                }
            }
            impl<'de> ::bitflags::__private::serde::Deserialize<'de>
            for InternalBitFlags {
                fn deserialize<D: ::bitflags::__private::serde::Deserializer<'de>>(
                    deserializer: D,
                ) -> ::bitflags::__private::core::result::Result<Self, D::Error> {
                    let flags: VariableSlotFlags = ::bitflags::serde::deserialize(
                        deserializer,
                    )?;
                    Ok(flags.0)
                }
            }
            #[allow(dead_code, deprecated, unused_attributes)]
            impl VariableSlotFlags {
                /// Get a flags value with all bits unset.
                #[inline]
                pub const fn empty() -> Self {
                    { Self(InternalBitFlags::empty()) }
                }
                /// Get a flags value with all known bits set.
                #[inline]
                pub const fn all() -> Self {
                    { Self(InternalBitFlags::all()) }
                }
                /// Get the underlying bits value.
                ///
                /// The returned value is exactly the bits set in this flags value.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    let f = self;
                    { f.0.bits() }
                }
                /// Convert from a bits value.
                ///
                /// This method will return `None` if any unknown bits are set.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let bits = bits;
                    {
                        match InternalBitFlags::from_bits(bits) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                }
                /// Convert from a bits value, unsetting any unknown bits.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    let bits = bits;
                    { Self(InternalBitFlags::from_bits_truncate(bits)) }
                }
                /// Convert from a bits value exactly.
                #[inline]
                pub const fn from_bits_retain(bits: u16) -> Self {
                    let bits = bits;
                    { Self(InternalBitFlags::from_bits_retain(bits)) }
                }
                /// Get a flags value with the bits of a flag with the given name set.
                ///
                /// This method will return `None` if `name` is empty or doesn't
                /// correspond to any named flag.
                #[inline]
                pub fn from_name(
                    name: &str,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let name = name;
                    {
                        match InternalBitFlags::from_name(name) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                }
                /// Whether all bits in this flags value are unset.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    let f = self;
                    { f.0.is_empty() }
                }
                /// Whether all known bits in this flags value are set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    let f = self;
                    { f.0.is_all() }
                }
                /// Whether any set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.0.intersects(other.0) }
                }
                /// Whether all set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.0.contains(other.0) }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.insert(other.0) }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `remove` won't truncate `other`, but the `!` operator will.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.remove(other.0) }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.toggle(other.0) }
                }
                /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    let f = self;
                    let other = other;
                    let value = value;
                    { f.0.set(other.0, value) }
                }
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.intersection(other.0)) }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.union(other.0)) }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.difference(other.0)) }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.symmetric_difference(other.0)) }
                }
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    let f = self;
                    { Self(f.0.complement()) }
                }
            }
            impl ::bitflags::__private::core::fmt::Binary for VariableSlotFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::Octal for VariableSlotFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::LowerHex for VariableSlotFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::UpperHex for VariableSlotFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::ops::BitOr for VariableSlotFlags {
                type Output = Self;
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor(self, other: VariableSlotFlags) -> Self {
                    self.union(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitOrAssign for VariableSlotFlags {
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.insert(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitXor for VariableSlotFlags {
                type Output = Self;
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    self.symmetric_difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitXorAssign for VariableSlotFlags {
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.toggle(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitAnd for VariableSlotFlags {
                type Output = Self;
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    self.intersection(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitAndAssign for VariableSlotFlags {
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    *self = Self::from_bits_retain(self.bits()).intersection(other);
                }
            }
            impl ::bitflags::__private::core::ops::Sub for VariableSlotFlags {
                type Output = Self;
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    self.difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::SubAssign for VariableSlotFlags {
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.remove(other);
                }
            }
            impl ::bitflags::__private::core::ops::Not for VariableSlotFlags {
                type Output = Self;
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                fn not(self) -> Self {
                    self.complement()
                }
            }
            impl ::bitflags::__private::core::iter::Extend<VariableSlotFlags>
            for VariableSlotFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn extend<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(&mut self, iterator: T) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::__private::core::iter::FromIterator<VariableSlotFlags>
            for VariableSlotFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn from_iter<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(iterator: T) -> Self {
                    use ::bitflags::__private::core::iter::Extend;
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl VariableSlotFlags {
                /// Yield a set of contained flags values.
                ///
                /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                /// will be yielded together as a final flags value.
                #[inline]
                pub const fn iter(&self) -> ::bitflags::iter::Iter<VariableSlotFlags> {
                    ::bitflags::iter::Iter::__private_const_new(
                        <VariableSlotFlags as ::bitflags::Flags>::FLAGS,
                        VariableSlotFlags::from_bits_retain(self.bits()),
                        VariableSlotFlags::from_bits_retain(self.bits()),
                    )
                }
                /// Yield a set of contained named flags values.
                ///
                /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                #[inline]
                pub const fn iter_names(
                    &self,
                ) -> ::bitflags::iter::IterNames<VariableSlotFlags> {
                    ::bitflags::iter::IterNames::__private_const_new(
                        <VariableSlotFlags as ::bitflags::Flags>::FLAGS,
                        VariableSlotFlags::from_bits_retain(self.bits()),
                        VariableSlotFlags::from_bits_retain(self.bits()),
                    )
                }
            }
            impl ::bitflags::__private::core::iter::IntoIterator for VariableSlotFlags {
                type Item = VariableSlotFlags;
                type IntoIter = ::bitflags::iter::Iter<VariableSlotFlags>;
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
        };
        struct VirtualSlotFlags(
            <VirtualSlotFlags as ::bitflags::__private::PublicFlags>::Internal,
        );
        #[automatically_derived]
        impl ::core::marker::Copy for VirtualSlotFlags {}
        #[automatically_derived]
        impl ::core::clone::Clone for VirtualSlotFlags {
            #[inline]
            fn clone(&self) -> VirtualSlotFlags {
                let _: ::core::clone::AssertParamIsClone<
                    <VirtualSlotFlags as ::bitflags::__private::PublicFlags>::Internal,
                >;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for VirtualSlotFlags {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for VirtualSlotFlags {
            #[inline]
            fn eq(&self, other: &VirtualSlotFlags) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for VirtualSlotFlags {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<
                    <VirtualSlotFlags as ::bitflags::__private::PublicFlags>::Internal,
                >;
            }
        }
        impl VirtualSlotFlags {}
        impl ::bitflags::Flags for VirtualSlotFlags {
            const FLAGS: &'static [::bitflags::Flag<VirtualSlotFlags>] = &[];
            type Bits = u16;
            fn bits(&self) -> u16 {
                VirtualSlotFlags::bits(self)
            }
            fn from_bits_retain(bits: u16) -> VirtualSlotFlags {
                VirtualSlotFlags::from_bits_retain(bits)
            }
        }
        #[allow(
            dead_code,
            deprecated,
            unused_doc_comments,
            unused_attributes,
            unused_mut,
            unused_imports,
            non_upper_case_globals,
            clippy::assign_op_pattern,
            clippy::indexing_slicing,
            clippy::same_name_method,
            clippy::iter_without_into_iter,
        )]
        const _: () = {
            #[repr(transparent)]
            struct InternalBitFlags(u16);
            #[automatically_derived]
            impl ::core::clone::Clone for InternalBitFlags {
                #[inline]
                fn clone(&self) -> InternalBitFlags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for InternalBitFlags {
                #[inline]
                fn eq(&self, other: &InternalBitFlags) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for InternalBitFlags {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for InternalBitFlags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &InternalBitFlags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for InternalBitFlags {
                #[inline]
                fn cmp(&self, other: &InternalBitFlags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for InternalBitFlags {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            impl ::bitflags::__private::PublicFlags for VirtualSlotFlags {
                type Primitive = u16;
                type Internal = InternalBitFlags;
            }
            impl ::bitflags::__private::core::default::Default for InternalBitFlags {
                #[inline]
                fn default() -> Self {
                    InternalBitFlags::empty()
                }
            }
            impl ::bitflags::__private::core::fmt::Debug for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                ) -> ::bitflags::__private::core::fmt::Result {
                    if self.is_empty() {
                        f.write_fmt(
                            format_args!("{0:#x}", <u16 as ::bitflags::Bits>::EMPTY),
                        )
                    } else {
                        ::bitflags::__private::core::fmt::Display::fmt(self, f)
                    }
                }
            }
            impl ::bitflags::__private::core::fmt::Display for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::parser::to_writer(&VirtualSlotFlags(*self), f)
                }
            }
            impl ::bitflags::__private::core::str::FromStr for InternalBitFlags {
                type Err = ::bitflags::parser::ParseError;
                fn from_str(
                    s: &str,
                ) -> ::bitflags::__private::core::result::Result<Self, Self::Err> {
                    ::bitflags::parser::from_str::<VirtualSlotFlags>(s)
                        .map(|flags| flags.0)
                }
            }
            impl ::bitflags::__private::core::convert::AsRef<u16> for InternalBitFlags {
                fn as_ref(&self) -> &u16 {
                    &self.0
                }
            }
            impl ::bitflags::__private::core::convert::From<u16> for InternalBitFlags {
                fn from(bits: u16) -> Self {
                    Self::from_bits_retain(bits)
                }
            }
            #[allow(dead_code, deprecated, unused_attributes)]
            impl InternalBitFlags {
                /// Get a flags value with all bits unset.
                #[inline]
                pub const fn empty() -> Self {
                    { Self(<u16 as ::bitflags::Bits>::EMPTY) }
                }
                /// Get a flags value with all known bits set.
                #[inline]
                pub const fn all() -> Self {
                    {
                        let mut truncated = <u16 as ::bitflags::Bits>::EMPTY;
                        let mut i = 0;
                        let _ = i;
                        Self::from_bits_retain(truncated)
                    }
                }
                /// Get the underlying bits value.
                ///
                /// The returned value is exactly the bits set in this flags value.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    let f = self;
                    { f.0 }
                }
                /// Convert from a bits value.
                ///
                /// This method will return `None` if any unknown bits are set.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let bits = bits;
                    {
                        let truncated = Self::from_bits_truncate(bits).0;
                        if truncated == bits {
                            ::bitflags::__private::core::option::Option::Some(Self(bits))
                        } else {
                            ::bitflags::__private::core::option::Option::None
                        }
                    }
                }
                /// Convert from a bits value, unsetting any unknown bits.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    let bits = bits;
                    { Self(bits & Self::all().bits()) }
                }
                /// Convert from a bits value exactly.
                #[inline]
                pub const fn from_bits_retain(bits: u16) -> Self {
                    let bits = bits;
                    { Self(bits) }
                }
                /// Get a flags value with the bits of a flag with the given name set.
                ///
                /// This method will return `None` if `name` is empty or doesn't
                /// correspond to any named flag.
                #[inline]
                pub fn from_name(
                    name: &str,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let name = name;
                    {
                        let _ = name;
                        ::bitflags::__private::core::option::Option::None
                    }
                }
                /// Whether all bits in this flags value are unset.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    let f = self;
                    { f.bits() == <u16 as ::bitflags::Bits>::EMPTY }
                }
                /// Whether all known bits in this flags value are set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    let f = self;
                    { Self::all().bits() | f.bits() == f.bits() }
                }
                /// Whether any set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.bits() & other.bits() != <u16 as ::bitflags::Bits>::EMPTY }
                }
                /// Whether all set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.bits() & other.bits() == other.bits() }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        *f = Self::from_bits_retain(f.bits()).union(other);
                    }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `remove` won't truncate `other`, but the `!` operator will.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        *f = Self::from_bits_retain(f.bits()).difference(other);
                    }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        *f = Self::from_bits_retain(f.bits())
                            .symmetric_difference(other);
                    }
                }
                /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    let f = self;
                    let other = other;
                    let value = value;
                    {
                        if value {
                            f.insert(other);
                        } else {
                            f.remove(other);
                        }
                    }
                }
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() & other.bits()) }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() | other.bits()) }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() & !other.bits()) }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() ^ other.bits()) }
                }
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    let f = self;
                    { Self::from_bits_truncate(!f.bits()) }
                }
            }
            impl ::bitflags::__private::core::fmt::Binary for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::Octal for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::LowerHex for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::UpperHex for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::ops::BitOr for InternalBitFlags {
                type Output = Self;
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor(self, other: InternalBitFlags) -> Self {
                    self.union(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitOrAssign for InternalBitFlags {
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.insert(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitXor for InternalBitFlags {
                type Output = Self;
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    self.symmetric_difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitXorAssign for InternalBitFlags {
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.toggle(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitAnd for InternalBitFlags {
                type Output = Self;
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    self.intersection(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitAndAssign for InternalBitFlags {
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    *self = Self::from_bits_retain(self.bits()).intersection(other);
                }
            }
            impl ::bitflags::__private::core::ops::Sub for InternalBitFlags {
                type Output = Self;
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    self.difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::SubAssign for InternalBitFlags {
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.remove(other);
                }
            }
            impl ::bitflags::__private::core::ops::Not for InternalBitFlags {
                type Output = Self;
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                fn not(self) -> Self {
                    self.complement()
                }
            }
            impl ::bitflags::__private::core::iter::Extend<InternalBitFlags>
            for InternalBitFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn extend<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(&mut self, iterator: T) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::__private::core::iter::FromIterator<InternalBitFlags>
            for InternalBitFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn from_iter<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(iterator: T) -> Self {
                    use ::bitflags::__private::core::iter::Extend;
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl InternalBitFlags {
                /// Yield a set of contained flags values.
                ///
                /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                /// will be yielded together as a final flags value.
                #[inline]
                pub const fn iter(&self) -> ::bitflags::iter::Iter<VirtualSlotFlags> {
                    ::bitflags::iter::Iter::__private_const_new(
                        <VirtualSlotFlags as ::bitflags::Flags>::FLAGS,
                        VirtualSlotFlags::from_bits_retain(self.bits()),
                        VirtualSlotFlags::from_bits_retain(self.bits()),
                    )
                }
                /// Yield a set of contained named flags values.
                ///
                /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                #[inline]
                pub const fn iter_names(
                    &self,
                ) -> ::bitflags::iter::IterNames<VirtualSlotFlags> {
                    ::bitflags::iter::IterNames::__private_const_new(
                        <VirtualSlotFlags as ::bitflags::Flags>::FLAGS,
                        VirtualSlotFlags::from_bits_retain(self.bits()),
                        VirtualSlotFlags::from_bits_retain(self.bits()),
                    )
                }
            }
            impl ::bitflags::__private::core::iter::IntoIterator for InternalBitFlags {
                type Item = VirtualSlotFlags;
                type IntoIter = ::bitflags::iter::Iter<VirtualSlotFlags>;
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
            impl InternalBitFlags {
                /// Returns a mutable reference to the raw value of the flags currently stored.
                #[inline]
                pub fn bits_mut(&mut self) -> &mut u16 {
                    &mut self.0
                }
            }
            impl ::bitflags::__private::serde::Serialize for InternalBitFlags {
                fn serialize<S: ::bitflags::__private::serde::Serializer>(
                    &self,
                    serializer: S,
                ) -> ::bitflags::__private::core::result::Result<S::Ok, S::Error> {
                    ::bitflags::serde::serialize(
                        &VirtualSlotFlags::from_bits_retain(self.bits()),
                        serializer,
                    )
                }
            }
            impl<'de> ::bitflags::__private::serde::Deserialize<'de>
            for InternalBitFlags {
                fn deserialize<D: ::bitflags::__private::serde::Deserializer<'de>>(
                    deserializer: D,
                ) -> ::bitflags::__private::core::result::Result<Self, D::Error> {
                    let flags: VirtualSlotFlags = ::bitflags::serde::deserialize(
                        deserializer,
                    )?;
                    Ok(flags.0)
                }
            }
            #[allow(dead_code, deprecated, unused_attributes)]
            impl VirtualSlotFlags {
                /// Get a flags value with all bits unset.
                #[inline]
                pub const fn empty() -> Self {
                    { Self(InternalBitFlags::empty()) }
                }
                /// Get a flags value with all known bits set.
                #[inline]
                pub const fn all() -> Self {
                    { Self(InternalBitFlags::all()) }
                }
                /// Get the underlying bits value.
                ///
                /// The returned value is exactly the bits set in this flags value.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    let f = self;
                    { f.0.bits() }
                }
                /// Convert from a bits value.
                ///
                /// This method will return `None` if any unknown bits are set.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let bits = bits;
                    {
                        match InternalBitFlags::from_bits(bits) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                }
                /// Convert from a bits value, unsetting any unknown bits.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    let bits = bits;
                    { Self(InternalBitFlags::from_bits_truncate(bits)) }
                }
                /// Convert from a bits value exactly.
                #[inline]
                pub const fn from_bits_retain(bits: u16) -> Self {
                    let bits = bits;
                    { Self(InternalBitFlags::from_bits_retain(bits)) }
                }
                /// Get a flags value with the bits of a flag with the given name set.
                ///
                /// This method will return `None` if `name` is empty or doesn't
                /// correspond to any named flag.
                #[inline]
                pub fn from_name(
                    name: &str,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let name = name;
                    {
                        match InternalBitFlags::from_name(name) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                }
                /// Whether all bits in this flags value are unset.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    let f = self;
                    { f.0.is_empty() }
                }
                /// Whether all known bits in this flags value are set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    let f = self;
                    { f.0.is_all() }
                }
                /// Whether any set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.0.intersects(other.0) }
                }
                /// Whether all set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.0.contains(other.0) }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.insert(other.0) }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `remove` won't truncate `other`, but the `!` operator will.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.remove(other.0) }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.toggle(other.0) }
                }
                /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    let f = self;
                    let other = other;
                    let value = value;
                    { f.0.set(other.0, value) }
                }
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.intersection(other.0)) }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.union(other.0)) }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.difference(other.0)) }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.symmetric_difference(other.0)) }
                }
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    let f = self;
                    { Self(f.0.complement()) }
                }
            }
            impl ::bitflags::__private::core::fmt::Binary for VirtualSlotFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::Octal for VirtualSlotFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::LowerHex for VirtualSlotFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::UpperHex for VirtualSlotFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::ops::BitOr for VirtualSlotFlags {
                type Output = Self;
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor(self, other: VirtualSlotFlags) -> Self {
                    self.union(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitOrAssign for VirtualSlotFlags {
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.insert(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitXor for VirtualSlotFlags {
                type Output = Self;
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    self.symmetric_difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitXorAssign for VirtualSlotFlags {
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.toggle(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitAnd for VirtualSlotFlags {
                type Output = Self;
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    self.intersection(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitAndAssign for VirtualSlotFlags {
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    *self = Self::from_bits_retain(self.bits()).intersection(other);
                }
            }
            impl ::bitflags::__private::core::ops::Sub for VirtualSlotFlags {
                type Output = Self;
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    self.difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::SubAssign for VirtualSlotFlags {
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.remove(other);
                }
            }
            impl ::bitflags::__private::core::ops::Not for VirtualSlotFlags {
                type Output = Self;
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                fn not(self) -> Self {
                    self.complement()
                }
            }
            impl ::bitflags::__private::core::iter::Extend<VirtualSlotFlags>
            for VirtualSlotFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn extend<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(&mut self, iterator: T) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::__private::core::iter::FromIterator<VirtualSlotFlags>
            for VirtualSlotFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn from_iter<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(iterator: T) -> Self {
                    use ::bitflags::__private::core::iter::Extend;
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl VirtualSlotFlags {
                /// Yield a set of contained flags values.
                ///
                /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                /// will be yielded together as a final flags value.
                #[inline]
                pub const fn iter(&self) -> ::bitflags::iter::Iter<VirtualSlotFlags> {
                    ::bitflags::iter::Iter::__private_const_new(
                        <VirtualSlotFlags as ::bitflags::Flags>::FLAGS,
                        VirtualSlotFlags::from_bits_retain(self.bits()),
                        VirtualSlotFlags::from_bits_retain(self.bits()),
                    )
                }
                /// Yield a set of contained named flags values.
                ///
                /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                #[inline]
                pub const fn iter_names(
                    &self,
                ) -> ::bitflags::iter::IterNames<VirtualSlotFlags> {
                    ::bitflags::iter::IterNames::__private_const_new(
                        <VirtualSlotFlags as ::bitflags::Flags>::FLAGS,
                        VirtualSlotFlags::from_bits_retain(self.bits()),
                        VirtualSlotFlags::from_bits_retain(self.bits()),
                    )
                }
            }
            impl ::bitflags::__private::core::iter::IntoIterator for VirtualSlotFlags {
                type Item = VirtualSlotFlags;
                type IntoIter = ::bitflags::iter::Iter<VirtualSlotFlags>;
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
        };
        struct MethodSlotFlags(
            <MethodSlotFlags as ::bitflags::__private::PublicFlags>::Internal,
        );
        #[automatically_derived]
        impl ::core::marker::Copy for MethodSlotFlags {}
        #[automatically_derived]
        impl ::core::clone::Clone for MethodSlotFlags {
            #[inline]
            fn clone(&self) -> MethodSlotFlags {
                let _: ::core::clone::AssertParamIsClone<
                    <MethodSlotFlags as ::bitflags::__private::PublicFlags>::Internal,
                >;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MethodSlotFlags {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MethodSlotFlags {
            #[inline]
            fn eq(&self, other: &MethodSlotFlags) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for MethodSlotFlags {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<
                    <MethodSlotFlags as ::bitflags::__private::PublicFlags>::Internal,
                >;
            }
        }
        impl MethodSlotFlags {
            #[allow(deprecated, non_upper_case_globals)]
            pub const IS_FINAL: Self = Self::from_bits_retain(0b000000001);
            #[allow(deprecated, non_upper_case_globals)]
            pub const IS_STATIC: Self = Self::from_bits_retain(0b000000010);
            #[allow(deprecated, non_upper_case_globals)]
            pub const IS_ABSTRACT: Self = Self::from_bits_retain(0b000000100);
            #[allow(deprecated, non_upper_case_globals)]
            pub const IS_OVERRIDING: Self = Self::from_bits_retain(0b000010000);
            #[allow(deprecated, non_upper_case_globals)]
            pub const IS_ASYNC: Self = Self::from_bits_retain(0b000100000);
            #[allow(deprecated, non_upper_case_globals)]
            pub const IS_GENERATOR: Self = Self::from_bits_retain(0b001000000);
            #[allow(deprecated, non_upper_case_globals)]
            pub const IS_CONSTRUCTOR: Self = Self::from_bits_retain(0b010000000);
        }
        impl ::bitflags::Flags for MethodSlotFlags {
            const FLAGS: &'static [::bitflags::Flag<MethodSlotFlags>] = &[
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("IS_FINAL", MethodSlotFlags::IS_FINAL)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("IS_STATIC", MethodSlotFlags::IS_STATIC)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("IS_ABSTRACT", MethodSlotFlags::IS_ABSTRACT)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "IS_OVERRIDING",
                        MethodSlotFlags::IS_OVERRIDING,
                    )
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("IS_ASYNC", MethodSlotFlags::IS_ASYNC)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new("IS_GENERATOR", MethodSlotFlags::IS_GENERATOR)
                },
                {
                    #[allow(deprecated, non_upper_case_globals)]
                    ::bitflags::Flag::new(
                        "IS_CONSTRUCTOR",
                        MethodSlotFlags::IS_CONSTRUCTOR,
                    )
                },
            ];
            type Bits = u16;
            fn bits(&self) -> u16 {
                MethodSlotFlags::bits(self)
            }
            fn from_bits_retain(bits: u16) -> MethodSlotFlags {
                MethodSlotFlags::from_bits_retain(bits)
            }
        }
        #[allow(
            dead_code,
            deprecated,
            unused_doc_comments,
            unused_attributes,
            unused_mut,
            unused_imports,
            non_upper_case_globals,
            clippy::assign_op_pattern,
            clippy::indexing_slicing,
            clippy::same_name_method,
            clippy::iter_without_into_iter,
        )]
        const _: () = {
            #[repr(transparent)]
            struct InternalBitFlags(u16);
            #[automatically_derived]
            impl ::core::clone::Clone for InternalBitFlags {
                #[inline]
                fn clone(&self) -> InternalBitFlags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for InternalBitFlags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for InternalBitFlags {
                #[inline]
                fn eq(&self, other: &InternalBitFlags) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for InternalBitFlags {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for InternalBitFlags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &InternalBitFlags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for InternalBitFlags {
                #[inline]
                fn cmp(&self, other: &InternalBitFlags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for InternalBitFlags {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            impl ::bitflags::__private::PublicFlags for MethodSlotFlags {
                type Primitive = u16;
                type Internal = InternalBitFlags;
            }
            impl ::bitflags::__private::core::default::Default for InternalBitFlags {
                #[inline]
                fn default() -> Self {
                    InternalBitFlags::empty()
                }
            }
            impl ::bitflags::__private::core::fmt::Debug for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                ) -> ::bitflags::__private::core::fmt::Result {
                    if self.is_empty() {
                        f.write_fmt(
                            format_args!("{0:#x}", <u16 as ::bitflags::Bits>::EMPTY),
                        )
                    } else {
                        ::bitflags::__private::core::fmt::Display::fmt(self, f)
                    }
                }
            }
            impl ::bitflags::__private::core::fmt::Display for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter<'_>,
                ) -> ::bitflags::__private::core::fmt::Result {
                    ::bitflags::parser::to_writer(&MethodSlotFlags(*self), f)
                }
            }
            impl ::bitflags::__private::core::str::FromStr for InternalBitFlags {
                type Err = ::bitflags::parser::ParseError;
                fn from_str(
                    s: &str,
                ) -> ::bitflags::__private::core::result::Result<Self, Self::Err> {
                    ::bitflags::parser::from_str::<MethodSlotFlags>(s)
                        .map(|flags| flags.0)
                }
            }
            impl ::bitflags::__private::core::convert::AsRef<u16> for InternalBitFlags {
                fn as_ref(&self) -> &u16 {
                    &self.0
                }
            }
            impl ::bitflags::__private::core::convert::From<u16> for InternalBitFlags {
                fn from(bits: u16) -> Self {
                    Self::from_bits_retain(bits)
                }
            }
            #[allow(dead_code, deprecated, unused_attributes)]
            impl InternalBitFlags {
                /// Get a flags value with all bits unset.
                #[inline]
                pub const fn empty() -> Self {
                    { Self(<u16 as ::bitflags::Bits>::EMPTY) }
                }
                /// Get a flags value with all known bits set.
                #[inline]
                pub const fn all() -> Self {
                    {
                        let mut truncated = <u16 as ::bitflags::Bits>::EMPTY;
                        let mut i = 0;
                        {
                            {
                                let flag = <MethodSlotFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <MethodSlotFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <MethodSlotFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <MethodSlotFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <MethodSlotFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <MethodSlotFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        {
                            {
                                let flag = <MethodSlotFlags as ::bitflags::Flags>::FLAGS[i]
                                    .value()
                                    .bits();
                                truncated = truncated | flag;
                                i += 1;
                            }
                        };
                        let _ = i;
                        Self::from_bits_retain(truncated)
                    }
                }
                /// Get the underlying bits value.
                ///
                /// The returned value is exactly the bits set in this flags value.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    let f = self;
                    { f.0 }
                }
                /// Convert from a bits value.
                ///
                /// This method will return `None` if any unknown bits are set.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let bits = bits;
                    {
                        let truncated = Self::from_bits_truncate(bits).0;
                        if truncated == bits {
                            ::bitflags::__private::core::option::Option::Some(Self(bits))
                        } else {
                            ::bitflags::__private::core::option::Option::None
                        }
                    }
                }
                /// Convert from a bits value, unsetting any unknown bits.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    let bits = bits;
                    { Self(bits & Self::all().bits()) }
                }
                /// Convert from a bits value exactly.
                #[inline]
                pub const fn from_bits_retain(bits: u16) -> Self {
                    let bits = bits;
                    { Self(bits) }
                }
                /// Get a flags value with the bits of a flag with the given name set.
                ///
                /// This method will return `None` if `name` is empty or doesn't
                /// correspond to any named flag.
                #[inline]
                pub fn from_name(
                    name: &str,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let name = name;
                    {
                        {
                            if name == "IS_FINAL" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(MethodSlotFlags::IS_FINAL.bits()),
                                );
                            }
                        };
                        {
                            if name == "IS_STATIC" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(MethodSlotFlags::IS_STATIC.bits()),
                                );
                            }
                        };
                        {
                            if name == "IS_ABSTRACT" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(MethodSlotFlags::IS_ABSTRACT.bits()),
                                );
                            }
                        };
                        {
                            if name == "IS_OVERRIDING" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(MethodSlotFlags::IS_OVERRIDING.bits()),
                                );
                            }
                        };
                        {
                            if name == "IS_ASYNC" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(MethodSlotFlags::IS_ASYNC.bits()),
                                );
                            }
                        };
                        {
                            if name == "IS_GENERATOR" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(MethodSlotFlags::IS_GENERATOR.bits()),
                                );
                            }
                        };
                        {
                            if name == "IS_CONSTRUCTOR" {
                                return ::bitflags::__private::core::option::Option::Some(
                                    Self(MethodSlotFlags::IS_CONSTRUCTOR.bits()),
                                );
                            }
                        };
                        let _ = name;
                        ::bitflags::__private::core::option::Option::None
                    }
                }
                /// Whether all bits in this flags value are unset.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    let f = self;
                    { f.bits() == <u16 as ::bitflags::Bits>::EMPTY }
                }
                /// Whether all known bits in this flags value are set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    let f = self;
                    { Self::all().bits() | f.bits() == f.bits() }
                }
                /// Whether any set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.bits() & other.bits() != <u16 as ::bitflags::Bits>::EMPTY }
                }
                /// Whether all set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.bits() & other.bits() == other.bits() }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        *f = Self::from_bits_retain(f.bits()).union(other);
                    }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `remove` won't truncate `other`, but the `!` operator will.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        *f = Self::from_bits_retain(f.bits()).difference(other);
                    }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    {
                        *f = Self::from_bits_retain(f.bits())
                            .symmetric_difference(other);
                    }
                }
                /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    let f = self;
                    let other = other;
                    let value = value;
                    {
                        if value {
                            f.insert(other);
                        } else {
                            f.remove(other);
                        }
                    }
                }
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() & other.bits()) }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() | other.bits()) }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() & !other.bits()) }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self::from_bits_retain(f.bits() ^ other.bits()) }
                }
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    let f = self;
                    { Self::from_bits_truncate(!f.bits()) }
                }
            }
            impl ::bitflags::__private::core::fmt::Binary for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::Octal for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::LowerHex for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::UpperHex for InternalBitFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::ops::BitOr for InternalBitFlags {
                type Output = Self;
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor(self, other: InternalBitFlags) -> Self {
                    self.union(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitOrAssign for InternalBitFlags {
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.insert(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitXor for InternalBitFlags {
                type Output = Self;
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    self.symmetric_difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitXorAssign for InternalBitFlags {
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.toggle(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitAnd for InternalBitFlags {
                type Output = Self;
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    self.intersection(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitAndAssign for InternalBitFlags {
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    *self = Self::from_bits_retain(self.bits()).intersection(other);
                }
            }
            impl ::bitflags::__private::core::ops::Sub for InternalBitFlags {
                type Output = Self;
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    self.difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::SubAssign for InternalBitFlags {
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.remove(other);
                }
            }
            impl ::bitflags::__private::core::ops::Not for InternalBitFlags {
                type Output = Self;
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                fn not(self) -> Self {
                    self.complement()
                }
            }
            impl ::bitflags::__private::core::iter::Extend<InternalBitFlags>
            for InternalBitFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn extend<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(&mut self, iterator: T) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::__private::core::iter::FromIterator<InternalBitFlags>
            for InternalBitFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn from_iter<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(iterator: T) -> Self {
                    use ::bitflags::__private::core::iter::Extend;
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl InternalBitFlags {
                /// Yield a set of contained flags values.
                ///
                /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                /// will be yielded together as a final flags value.
                #[inline]
                pub const fn iter(&self) -> ::bitflags::iter::Iter<MethodSlotFlags> {
                    ::bitflags::iter::Iter::__private_const_new(
                        <MethodSlotFlags as ::bitflags::Flags>::FLAGS,
                        MethodSlotFlags::from_bits_retain(self.bits()),
                        MethodSlotFlags::from_bits_retain(self.bits()),
                    )
                }
                /// Yield a set of contained named flags values.
                ///
                /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                #[inline]
                pub const fn iter_names(
                    &self,
                ) -> ::bitflags::iter::IterNames<MethodSlotFlags> {
                    ::bitflags::iter::IterNames::__private_const_new(
                        <MethodSlotFlags as ::bitflags::Flags>::FLAGS,
                        MethodSlotFlags::from_bits_retain(self.bits()),
                        MethodSlotFlags::from_bits_retain(self.bits()),
                    )
                }
            }
            impl ::bitflags::__private::core::iter::IntoIterator for InternalBitFlags {
                type Item = MethodSlotFlags;
                type IntoIter = ::bitflags::iter::Iter<MethodSlotFlags>;
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
            impl InternalBitFlags {
                /// Returns a mutable reference to the raw value of the flags currently stored.
                #[inline]
                pub fn bits_mut(&mut self) -> &mut u16 {
                    &mut self.0
                }
            }
            impl ::bitflags::__private::serde::Serialize for InternalBitFlags {
                fn serialize<S: ::bitflags::__private::serde::Serializer>(
                    &self,
                    serializer: S,
                ) -> ::bitflags::__private::core::result::Result<S::Ok, S::Error> {
                    ::bitflags::serde::serialize(
                        &MethodSlotFlags::from_bits_retain(self.bits()),
                        serializer,
                    )
                }
            }
            impl<'de> ::bitflags::__private::serde::Deserialize<'de>
            for InternalBitFlags {
                fn deserialize<D: ::bitflags::__private::serde::Deserializer<'de>>(
                    deserializer: D,
                ) -> ::bitflags::__private::core::result::Result<Self, D::Error> {
                    let flags: MethodSlotFlags = ::bitflags::serde::deserialize(
                        deserializer,
                    )?;
                    Ok(flags.0)
                }
            }
            #[allow(dead_code, deprecated, unused_attributes)]
            impl MethodSlotFlags {
                /// Get a flags value with all bits unset.
                #[inline]
                pub const fn empty() -> Self {
                    { Self(InternalBitFlags::empty()) }
                }
                /// Get a flags value with all known bits set.
                #[inline]
                pub const fn all() -> Self {
                    { Self(InternalBitFlags::all()) }
                }
                /// Get the underlying bits value.
                ///
                /// The returned value is exactly the bits set in this flags value.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    let f = self;
                    { f.0.bits() }
                }
                /// Convert from a bits value.
                ///
                /// This method will return `None` if any unknown bits are set.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let bits = bits;
                    {
                        match InternalBitFlags::from_bits(bits) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                }
                /// Convert from a bits value, unsetting any unknown bits.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    let bits = bits;
                    { Self(InternalBitFlags::from_bits_truncate(bits)) }
                }
                /// Convert from a bits value exactly.
                #[inline]
                pub const fn from_bits_retain(bits: u16) -> Self {
                    let bits = bits;
                    { Self(InternalBitFlags::from_bits_retain(bits)) }
                }
                /// Get a flags value with the bits of a flag with the given name set.
                ///
                /// This method will return `None` if `name` is empty or doesn't
                /// correspond to any named flag.
                #[inline]
                pub fn from_name(
                    name: &str,
                ) -> ::bitflags::__private::core::option::Option<Self> {
                    let name = name;
                    {
                        match InternalBitFlags::from_name(name) {
                            ::bitflags::__private::core::option::Option::Some(bits) => {
                                ::bitflags::__private::core::option::Option::Some(
                                    Self(bits),
                                )
                            }
                            ::bitflags::__private::core::option::Option::None => {
                                ::bitflags::__private::core::option::Option::None
                            }
                        }
                    }
                }
                /// Whether all bits in this flags value are unset.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    let f = self;
                    { f.0.is_empty() }
                }
                /// Whether all known bits in this flags value are set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    let f = self;
                    { f.0.is_all() }
                }
                /// Whether any set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.0.intersects(other.0) }
                }
                /// Whether all set bits in a source flags value are also set in a target flags value.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    let f = self;
                    let other = other;
                    { f.0.contains(other.0) }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.insert(other.0) }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `remove` won't truncate `other`, but the `!` operator will.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.remove(other.0) }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    let f = self;
                    let other = other;
                    { f.0.toggle(other.0) }
                }
                /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    let f = self;
                    let other = other;
                    let value = value;
                    { f.0.set(other.0, value) }
                }
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.intersection(other.0)) }
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.union(other.0)) }
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.difference(other.0)) }
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    let f = self;
                    let other = other;
                    { Self(f.0.symmetric_difference(other.0)) }
                }
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    let f = self;
                    { Self(f.0.complement()) }
                }
            }
            impl ::bitflags::__private::core::fmt::Binary for MethodSlotFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Binary::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::Octal for MethodSlotFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::Octal::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::LowerHex for MethodSlotFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::LowerHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::fmt::UpperHex for MethodSlotFlags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::__private::core::fmt::Formatter,
                ) -> ::bitflags::__private::core::fmt::Result {
                    let inner = self.0;
                    ::bitflags::__private::core::fmt::UpperHex::fmt(&inner, f)
                }
            }
            impl ::bitflags::__private::core::ops::BitOr for MethodSlotFlags {
                type Output = Self;
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor(self, other: MethodSlotFlags) -> Self {
                    self.union(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitOrAssign for MethodSlotFlags {
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.insert(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitXor for MethodSlotFlags {
                type Output = Self;
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    self.symmetric_difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitXorAssign for MethodSlotFlags {
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.toggle(other);
                }
            }
            impl ::bitflags::__private::core::ops::BitAnd for MethodSlotFlags {
                type Output = Self;
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    self.intersection(other)
                }
            }
            impl ::bitflags::__private::core::ops::BitAndAssign for MethodSlotFlags {
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    *self = Self::from_bits_retain(self.bits()).intersection(other);
                }
            }
            impl ::bitflags::__private::core::ops::Sub for MethodSlotFlags {
                type Output = Self;
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    self.difference(other)
                }
            }
            impl ::bitflags::__private::core::ops::SubAssign for MethodSlotFlags {
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.remove(other);
                }
            }
            impl ::bitflags::__private::core::ops::Not for MethodSlotFlags {
                type Output = Self;
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                fn not(self) -> Self {
                    self.complement()
                }
            }
            impl ::bitflags::__private::core::iter::Extend<MethodSlotFlags>
            for MethodSlotFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn extend<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(&mut self, iterator: T) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::__private::core::iter::FromIterator<MethodSlotFlags>
            for MethodSlotFlags {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn from_iter<
                    T: ::bitflags::__private::core::iter::IntoIterator<Item = Self>,
                >(iterator: T) -> Self {
                    use ::bitflags::__private::core::iter::Extend;
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl MethodSlotFlags {
                /// Yield a set of contained flags values.
                ///
                /// Each yielded flags value will correspond to a defined named flag. Any unknown bits
                /// will be yielded together as a final flags value.
                #[inline]
                pub const fn iter(&self) -> ::bitflags::iter::Iter<MethodSlotFlags> {
                    ::bitflags::iter::Iter::__private_const_new(
                        <MethodSlotFlags as ::bitflags::Flags>::FLAGS,
                        MethodSlotFlags::from_bits_retain(self.bits()),
                        MethodSlotFlags::from_bits_retain(self.bits()),
                    )
                }
                /// Yield a set of contained named flags values.
                ///
                /// This method is like [`iter`](#method.iter), except only yields bits in contained named flags.
                /// Any unknown bits, or bits not corresponding to a contained flag will not be yielded.
                #[inline]
                pub const fn iter_names(
                    &self,
                ) -> ::bitflags::iter::IterNames<MethodSlotFlags> {
                    ::bitflags::iter::IterNames::__private_const_new(
                        <MethodSlotFlags as ::bitflags::Flags>::FLAGS,
                        MethodSlotFlags::from_bits_retain(self.bits()),
                        MethodSlotFlags::from_bits_retain(self.bits()),
                    )
                }
            }
            impl ::bitflags::__private::core::iter::IntoIterator for MethodSlotFlags {
                type Item = MethodSlotFlags;
                type IntoIter = ::bitflags::iter::Iter<MethodSlotFlags>;
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
        };
        /// Parameter belonging to a function type in the semantic model.
        pub struct SemanticFunctionTypeParameter {
            pub kind: ParameterKind,
            /// Static type of the parameter. It is never `UnresolvedEntity`
            /// as function types are only created after all compound types
            /// are resolved.
            pub static_type: Entity,
        }
        impl SemanticFunctionTypeParameter {
            /// Performs type substitution.
            pub fn apply_type(
                &self,
                host: &Database,
                type_params: &SharedArray<Entity>,
                substitute_types: &SharedArray<Entity>,
            ) -> Self {
                Self {
                    kind: self.kind,
                    static_type: ApplyType(host)
                        .exec(&self.static_type, type_params, substitute_types),
                }
            }
        }
        pub struct ControlFlowGraph(Rc<ControlFlowGraph1>);
        #[automatically_derived]
        impl ::core::clone::Clone for ControlFlowGraph {
            #[inline]
            fn clone(&self) -> ControlFlowGraph {
                ControlFlowGraph(::core::clone::Clone::clone(&self.0))
            }
        }
        impl ControlFlowGraph {
            pub fn new() -> Self {
                Self(
                    Rc::new(ControlFlowGraph1 {
                        blocks: SharedArray::new(),
                        edges: SharedArray::new(),
                    }),
                )
            }
            pub fn blocks(&self) -> SharedArray<ControlFlowBlock> {
                self.0.blocks.clone()
            }
            pub fn edges(&self) -> SharedArray<ControlFlowEdge> {
                self.0.edges.clone()
            }
        }
        impl std::hash::Hash for ControlFlowGraph {
            fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
                Rc::as_ptr(&self.0).hash(state)
            }
        }
        impl PartialEq for ControlFlowGraph {
            fn eq(&self, other: &Self) -> bool {
                Rc::ptr_eq(&self.0, &other.0)
            }
        }
        impl Eq for ControlFlowGraph {}
        struct ControlFlowGraph1 {
            blocks: SharedArray<ControlFlowBlock>,
            edges: SharedArray<ControlFlowEdge>,
        }
        pub struct ControlFlowBlock(Rc<Vec<Rc<Directive>>>);
        #[automatically_derived]
        impl ::core::clone::Clone for ControlFlowBlock {
            #[inline]
            fn clone(&self) -> ControlFlowBlock {
                ControlFlowBlock(::core::clone::Clone::clone(&self.0))
            }
        }
        impl ControlFlowBlock {
            pub fn new(lines: Vec<Rc<Directive>>) -> Self {
                Self(Rc::new(lines))
            }
            pub fn lines(&self) -> Rc<Vec<Rc<Directive>>> {
                self.0.clone()
            }
        }
        impl std::hash::Hash for ControlFlowBlock {
            fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
                Rc::as_ptr(&self.0).hash(state)
            }
        }
        impl PartialEq for ControlFlowBlock {
            fn eq(&self, other: &Self) -> bool {
                Rc::ptr_eq(&self.0, &other.0)
            }
        }
        impl Eq for ControlFlowBlock {}
        pub struct ControlFlowEdge {
            pub from: ControlFlowBlock,
            pub to: ControlFlowBlock,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ControlFlowEdge {
            #[inline]
            fn clone(&self) -> ControlFlowEdge {
                ControlFlowEdge {
                    from: ::core::clone::Clone::clone(&self.from),
                    to: ::core::clone::Clone::clone(&self.to),
                }
            }
        }
        pub struct DescendingClassHierarchy<'a>(Option<Entity>, &'a Database, Entity);
        impl<'a> Iterator for DescendingClassHierarchy<'a> {
            type Item = Entity;
            fn next(&mut self) -> Option<Self::Item> {
                if let Some(r) = self.0.clone() {
                    if r.is::<UnresolvedEntity>() {
                        self.0 = None;
                    } else {
                        self.0 = r.extends_class(self.1);
                        if self.0.as_ref().unwrap() == &self.2 {
                            self.0 = None;
                        }
                    }
                    Some(r)
                } else {
                    None
                }
            }
        }
        pub struct DescendingScopeHierarchy(Option<Entity>);
        impl Iterator for DescendingScopeHierarchy {
            type Item = Entity;
            fn next(&mut self) -> Option<Self::Item> {
                if let Some(r) = self.0.clone() {
                    self.0 = r.parent();
                    Some(r)
                } else {
                    None
                }
            }
        }
        pub struct DescendingDefinitionHierarchy(Option<Entity>);
        impl Iterator for DescendingDefinitionHierarchy {
            type Item = Entity;
            fn next(&mut self) -> Option<Self::Item> {
                if let Some(r) = self.0.clone() {
                    self.0 = r.parent();
                    Some(r)
                } else {
                    None
                }
            }
        }
        pub struct Event {
            pub data_type: Entity,
            pub constant: Option<Entity>,
            pub bubbles: Option<bool>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Event {
            #[inline]
            fn clone(&self) -> Event {
                Event {
                    data_type: ::core::clone::Clone::clone(&self.data_type),
                    constant: ::core::clone::Clone::clone(&self.constant),
                    bubbles: ::core::clone::Clone::clone(&self.bubbles),
                }
            }
        }
        const DEFAULT_ACTIVATION: u8 = 0;
        const PACKAGE_INIT_ACTIVATION: u8 = 1;
        const GLOBAL_INIT_ACTIVATION: u8 = 2;
    }
    pub use entity::*;
    mod factory {
        use crate::ns::*;
        pub struct Factory<'a>(pub(crate) &'a Database);
        impl<'a> Factory<'a> {
            pub fn create_public_ns(&self, parent: Option<Entity>) -> Entity {
                SystemNamespace::new(&self.0.arena, SystemNamespaceKind::Public, parent)
                    .into()
            }
            pub fn create_private_ns(&self, parent: Option<Entity>) -> Entity {
                SystemNamespace::new(&self.0.arena, SystemNamespaceKind::Private, parent)
                    .into()
            }
            pub fn create_protected_ns(&self, parent: Option<Entity>) -> Entity {
                SystemNamespace::new(
                        &self.0.arena,
                        SystemNamespaceKind::Protected,
                        parent,
                    )
                    .into()
            }
            pub fn create_static_protected_ns(&self, parent: Option<Entity>) -> Entity {
                SystemNamespace::new(
                        &self.0.arena,
                        SystemNamespaceKind::StaticProtected,
                        parent,
                    )
                    .into()
            }
            pub fn create_internal_ns(&self, parent: Option<Entity>) -> Entity {
                SystemNamespace::new(
                        &self.0.arena,
                        SystemNamespaceKind::Internal,
                        parent,
                    )
                    .into()
            }
            pub fn create_explicit_ns(&self, uri: String) -> Entity {
                let mut mappings = self.0.explicit_namespaces.borrow_mut();
                if let Some(ns) = mappings.get(&uri) {
                    return ns.clone();
                }
                let ns: Entity = ExplicitNamespace::new(&self.0.arena, uri.clone())
                    .into();
                mappings.insert(uri, ns.clone());
                ns
            }
            pub fn create_user_ns(&self, uri: String) -> Entity {
                let mut mappings = self.0.user_namespaces.borrow_mut();
                if let Some(ns) = mappings.get(&uri) {
                    return ns.clone();
                }
                let ns: Entity = UserNamespace::new(&self.0.arena, uri.clone()).into();
                mappings.insert(uri, ns.clone());
                ns
            }
            pub fn create_qname(&self, namespace: &Entity, local_name: String) -> QName {
                let mut ns_mappings = self.0.qnames.borrow_mut();
                if let Some(qn_mappings) = ns_mappings.get_mut(namespace) {
                    if let Some(qn) = qn_mappings.get(&local_name) {
                        return qn.clone();
                    }
                    let qn = QName(
                        Rc::new(QName1 {
                            m_namespace: namespace.clone(),
                            m_local_name: local_name.clone(),
                        }),
                    );
                    qn_mappings.insert(local_name, qn.clone());
                    return qn;
                }
                let qn = QName(
                    Rc::new(QName1 {
                        m_namespace: namespace.clone(),
                        m_local_name: local_name.clone(),
                    }),
                );
                let mut qn_mappings = HashMap::new();
                qn_mappings.insert(local_name, qn.clone());
                ns_mappings.insert(namespace.clone(), qn_mappings);
                qn
            }
            /// Interns a package from a fully qualified name.
            ///
            /// # Example
            ///
            /// ```ignore
            /// assert_eq!(host.factory().create_package(["foo", "bar"]).fully_qualified_name(), "foo.bar");
            /// ```
            pub fn create_package<'b>(
                &self,
                name: impl IntoIterator<Item = &'b str>,
            ) -> Entity {
                self.create_package_1(&name.into_iter().collect())
            }
            fn create_package_1(&self, name: &Vec<&str>) -> Entity {
                let mut result: Entity = self.0.top_level_package.clone();
                for name_1 in name {
                    let name_1 = (*name_1).to_owned();
                    let result_1 = result.subpackages().get(&name_1);
                    if let Some(result_1) = result_1 {
                        result = result_1;
                    } else {
                        let result_1 = Package::new(&self.0.arena, name_1.clone());
                        result_1.set_parent(Some(result.clone().into()));
                        result_1
                            .set_public_ns(
                                Some(self.create_public_ns(Some(result_1.clone().into()))),
                            );
                        result_1
                            .set_internal_ns(
                                Some(self.create_internal_ns(Some(result_1.clone().into()))),
                            );
                        result.subpackages().set(name_1, result_1.clone().into());
                        result = result_1.into();
                    }
                }
                result
            }
            pub fn create_alias(&self, name: QName, alias_of: Entity) -> Entity {
                Alias::new(&self.0.arena, name, alias_of).into()
            }
            /// # Parameters
            ///
            /// - `ns_for_prototype`: The namespace used for the `prototype` property. Either
            ///   `public` or `internal`.
            pub fn create_class_type(
                &self,
                name: QName,
                ns_for_prototype: &Entity,
            ) -> Entity {
                let r = ClassType::new(&self.0.arena, name);
                r.set_private_ns(Some(self.create_private_ns(Some(r.clone().into()))));
                r.set_protected_ns(
                    Some(self.create_protected_ns(Some(r.clone().into()))),
                );
                r.set_static_protected_ns(
                    Some(self.create_static_protected_ns(Some(r.clone().into()))),
                );
                let prototype_name = self
                    .create_qname(&ns_for_prototype, "prototype".into());
                let prototype_slot = self
                    .create_variable_slot(&prototype_name, true, &self.0.any_type());
                r.properties(self.0).set(prototype_name.clone(), prototype_slot);
                r.into()
            }
            pub fn create_enum_type(
                &self,
                name: QName,
                ns_for_prototype: &Entity,
            ) -> Entity {
                let r = EnumType::new(&self.0.arena, name);
                r.set_private_ns(Some(self.create_private_ns(Some(r.clone().into()))));
                let prototype_name = self
                    .create_qname(&ns_for_prototype, "prototype".into());
                let prototype_slot = self
                    .create_variable_slot(&prototype_name, true, &self.0.any_type());
                r.properties(self.0).set(prototype_name.clone(), prototype_slot);
                r.into()
            }
            pub fn create_interface_type(&self, name: QName) -> Entity {
                let r = InterfaceType::new(&self.0.arena, name);
                r.into()
            }
            /// Interns type after substitution.
            pub fn create_type_after_substitution(
                &self,
                origin: &Entity,
                substitute_types: &SharedArray<Entity>,
            ) -> Entity {
                let params = origin.type_params().unwrap();
                let param_count = params.length();
                match (&substitute_types.length(), &param_count) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
                let mut tas_list = self.0.types_after_sub.borrow_mut();
                let mut list = tas_list.get(&origin);
                let empty_list = ::alloc::vec::Vec::new();
                if list.is_none() {
                    list = Some(&empty_list);
                    tas_list.insert(origin.clone(), ::alloc::vec::Vec::new());
                }
                'tas: for tas in list.unwrap() {
                    let mut substitute_types_1 = substitute_types.iter();
                    let substitute_types_2 = tas.substitute_types();
                    let mut substitute_types_2 = substitute_types_2.iter();
                    while let Some(substitute_type_1) = substitute_types_1.next() {
                        let substitute_type_2 = substitute_types_2.next().unwrap();
                        if substitute_type_1 != substitute_type_2 {
                            continue 'tas;
                        }
                    }
                    return tas.clone();
                }
                let tas = TypeAfterSubstitution::new(
                    &self.0.arena,
                    origin.clone(),
                    substitute_types.clone(),
                );
                let list = tas_list.get_mut(&origin).unwrap();
                list.push(tas.clone().into());
                tas.into()
            }
            /// Interns a tuple type.
            pub fn create_tuple_type(&self, element_types: Vec<Entity>) -> Entity {
                let element_count = element_types.len();
                let mut tuple_types = self.0.tuple_types.borrow_mut();
                let mut collection = tuple_types.get_mut(&element_count);
                let mut empty_collection = ::alloc::vec::Vec::new();
                if collection.is_none() {
                    collection = Some(&mut empty_collection);
                    tuple_types.insert(element_count, ::alloc::vec::Vec::new());
                }
                'tt: for tt in collection.unwrap() {
                    let mut element_types_1 = element_types.iter();
                    let element_types_2 = tt.element_types();
                    let mut element_types_2 = element_types_2.iter();
                    while let Some(e_1) = element_types_1.next() {
                        let e_2 = element_types_2.next().unwrap();
                        if e_1 != &e_2 {
                            continue 'tt;
                        }
                    }
                    return tt.clone();
                }
                let tt = TupleType::new(&self.0.arena, SharedArray::from(element_types));
                let collection = tuple_types.get_mut(&element_count);
                collection.unwrap().push(tt.clone().into());
                tt.into()
            }
            /// Interns a function type.
            pub fn create_function_type(
                &self,
                params: Vec<Rc<SemanticFunctionTypeParameter>>,
                result_type: Entity,
            ) -> Entity {
                let param_count = params.len();
                let mut function_types = self.0.function_types.borrow_mut();
                let mut collection = function_types.get_mut(&param_count);
                let mut empty_collection = ::alloc::vec::Vec::new();
                if collection.is_none() {
                    collection = Some(&mut empty_collection);
                    function_types.insert(params.len(), ::alloc::vec::Vec::new());
                }
                'ft: for ft in collection.unwrap() {
                    if result_type != ft.result_type() {
                        continue 'ft;
                    }
                    let mut params_1 = params.iter();
                    let params_2 = ft.params();
                    let mut params_2 = params_2.iter();
                    while let Some(param_1) = params_1.next() {
                        let param_2 = params_2.next().unwrap();
                        if !(param_1.kind == param_2.kind
                            && &&param_1.static_type == &&param_2.static_type)
                        {
                            continue 'ft;
                        }
                    }
                    return ft.clone();
                }
                let ft = FunctionType::new(
                    &self.0.arena,
                    SharedArray::from(params),
                    result_type,
                );
                let collection = function_types.get_mut(&param_count);
                collection.unwrap().push(ft.clone().into());
                ft.into()
            }
            /// Interns a nullable type.
            pub fn create_nullable_type(&self, base: &Entity) -> Entity {
                if base == &self.0.any_type() || base.is::<NullableType>()
                    || base.is::<InvalidationEntity>()
                {
                    return base.clone();
                }
                if base.is::<NonNullableType>() {
                    return base.base();
                }
                let mut m = self.0.nullable_types.borrow_mut();
                let nt = m.get(base);
                if let Some(nt) = nt {
                    return nt.clone();
                }
                let nt = NullableType::new(&self.0.arena, base.clone());
                m.insert(base.clone(), nt.clone().into());
                nt.into()
            }
            /// Interns a non nullable type.
            pub fn create_non_nullable_type(&self, base: &Entity) -> Entity {
                if base == &self.0.any_type() || base.is::<NonNullableType>()
                    || base.is::<InvalidationEntity>()
                {
                    return base.clone();
                }
                let mut m = self.0.non_nullable_types.borrow_mut();
                let nt = m.get(base);
                if let Some(nt) = nt {
                    return nt.clone();
                }
                let nt = NonNullableType::new(&self.0.arena, base.clone());
                m.insert(base.clone(), nt.clone().into());
                nt.into()
            }
            pub fn create_type_parameter_type(&self, name: &QName) -> Entity {
                TypeParameterType::new(&self.0.arena, name.clone()).into()
            }
            pub fn create_variable_slot(
                &self,
                name: &QName,
                read_only: bool,
                static_type: &Entity,
            ) -> Entity {
                OriginalVariableSlot::new(&self.0.arena, name, read_only, static_type)
                    .into()
            }
            /// Interns a variable slot after indirect substitution.
            pub fn create_variable_slot_after_substitution(
                &self,
                origin: &Entity,
                indirect_type_params: &SharedArray<Entity>,
                indirect_substitute_types: &SharedArray<Entity>,
            ) -> Entity {
                match (
                    &indirect_type_params.length(),
                    &indirect_substitute_types.length(),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
                let mut vasub_list = self.0.vasub.borrow_mut();
                let mut base_list = vasub_list.get_mut(origin);
                let mut empty_base_list = HashMap::<
                    SharedArray<Entity>,
                    Vec<Entity>,
                >::new();
                if base_list.is_none() {
                    base_list = Some(&mut empty_base_list);
                    vasub_list.insert(origin.clone(), HashMap::new());
                }
                let base_list = base_list.unwrap();
                let mut list = base_list.get(indirect_type_params);
                let empty_list = ::alloc::vec::Vec::new();
                if list.is_none() {
                    list = Some(&empty_list);
                    base_list
                        .insert(indirect_type_params.clone(), ::alloc::vec::Vec::new());
                }
                'vasub: for vasub in list.unwrap() {
                    let mut substitute_types_1 = indirect_substitute_types.iter();
                    let substitute_types_2 = vasub.indirect_substitute_types();
                    let mut substitute_types_2 = substitute_types_2.iter();
                    while let Some(substitute_type_1) = substitute_types_1.next() {
                        let substitute_type_2 = substitute_types_2.next().unwrap();
                        if substitute_type_1 != substitute_type_2 {
                            continue 'vasub;
                        }
                    }
                    return vasub.clone();
                }
                let vasub = VariableSlotAfterSubstitution::new(
                    &self.0.arena,
                    &origin,
                    &indirect_type_params,
                    &indirect_substitute_types.clone(),
                );
                let list = vasub_list
                    .get_mut(origin)
                    .unwrap()
                    .get_mut(&indirect_type_params)
                    .unwrap();
                list.push(vasub.clone().into());
                vasub.into()
            }
            pub fn create_virtual_slot(&self, name: &QName) -> Entity {
                OriginalVirtualSlot::new(&self.0.arena, name).into()
            }
            /// Interns a virtual slot after indirect substitution.
            pub fn create_virtual_slot_after_substitution(
                &self,
                origin: &Entity,
                indirect_type_params: &SharedArray<Entity>,
                indirect_substitute_types: &SharedArray<Entity>,
            ) -> Entity {
                match (
                    &indirect_type_params.length(),
                    &indirect_substitute_types.length(),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
                let mut visub_list = self.0.visub.borrow_mut();
                let mut base_list = visub_list.get_mut(origin);
                let mut empty_base_list = HashMap::<
                    SharedArray<Entity>,
                    Vec<Entity>,
                >::new();
                if base_list.is_none() {
                    base_list = Some(&mut empty_base_list);
                    visub_list.insert(origin.clone(), HashMap::new());
                }
                let base_list = base_list.unwrap();
                let mut list = base_list.get(indirect_type_params);
                let empty_list = ::alloc::vec::Vec::new();
                if list.is_none() {
                    list = Some(&empty_list);
                    base_list
                        .insert(indirect_type_params.clone(), ::alloc::vec::Vec::new());
                }
                'visub: for visub in list.unwrap() {
                    let mut substitute_types_1 = indirect_substitute_types.iter();
                    let substitute_types_2 = visub.indirect_substitute_types();
                    let mut substitute_types_2 = substitute_types_2.iter();
                    while let Some(substitute_type_1) = substitute_types_1.next() {
                        let substitute_type_2 = substitute_types_2.next().unwrap();
                        if substitute_type_1 != substitute_type_2 {
                            continue 'visub;
                        }
                    }
                    return visub.clone();
                }
                let visub = VirtualSlotAfterSubstitution::new(
                    &self.0.arena,
                    &origin,
                    &indirect_type_params,
                    &indirect_substitute_types.clone(),
                );
                let list = visub_list
                    .get_mut(origin)
                    .unwrap()
                    .get_mut(&indirect_type_params)
                    .unwrap();
                list.push(visub.clone().into());
                visub.into()
            }
            pub fn create_method_slot(
                &self,
                name: &QName,
                signature: &Entity,
            ) -> Entity {
                OriginalMethodSlot::new(&self.0.arena, name, signature).into()
            }
            /// Interns a method slot after indirect substitution.
            pub fn create_method_slot_after_substitution(
                &self,
                origin: &Entity,
                indirect_type_params: &SharedArray<Entity>,
                indirect_substitute_types: &SharedArray<Entity>,
            ) -> Entity {
                match (
                    &indirect_type_params.length(),
                    &indirect_substitute_types.length(),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
                let mut mssub_list = self.0.mssub.borrow_mut();
                let mut base_list = mssub_list.get_mut(origin);
                let mut empty_base_list = HashMap::<
                    SharedArray<Entity>,
                    Vec<Entity>,
                >::new();
                if base_list.is_none() {
                    base_list = Some(&mut empty_base_list);
                    mssub_list.insert(origin.clone(), HashMap::new());
                }
                let base_list = base_list.unwrap();
                let mut list = base_list.get(indirect_type_params);
                let empty_list = ::alloc::vec::Vec::new();
                if list.is_none() {
                    list = Some(&empty_list);
                    base_list
                        .insert(indirect_type_params.clone(), ::alloc::vec::Vec::new());
                }
                'mssub: for mssub in list.unwrap() {
                    let mut substitute_types_1 = indirect_substitute_types.iter();
                    let substitute_types_2 = mssub.indirect_substitute_types();
                    let mut substitute_types_2 = substitute_types_2.iter();
                    while let Some(substitute_type_1) = substitute_types_1.next() {
                        let substitute_type_2 = substitute_types_2.next().unwrap();
                        if substitute_type_1 != substitute_type_2 {
                            continue 'mssub;
                        }
                    }
                    return mssub.clone();
                }
                let mssub = MethodSlotAfterSubstitution::new(
                    &self.0.arena,
                    &origin,
                    &indirect_type_params,
                    &indirect_substitute_types.clone(),
                );
                let list = mssub_list
                    .get_mut(origin)
                    .unwrap()
                    .get_mut(&indirect_type_params)
                    .unwrap();
                list.push(mssub.clone().into());
                mssub.into()
            }
            pub fn create_scope(&self) -> Entity {
                Scope::new(&self.0.arena).into()
            }
            pub fn create_with_scope(&self, object: &Entity) -> Entity {
                WithScope::new(&self.0.arena, object).into()
            }
            pub fn create_filter_scope(&self, base: &Entity) -> Entity {
                FilterScope::new(&self.0.arena, base).into()
            }
            pub fn create_activation(&self, of_method: &Entity) -> Entity {
                Activation::new(&self.0.arena, of_method).into()
            }
            pub fn create_class_scope(&self, class: &Entity) -> Entity {
                ClassScope::new(&self.0.arena, class).into()
            }
            pub fn create_enum_scope(&self, class: &Entity) -> Entity {
                EnumScope::new(&self.0.arena, class).into()
            }
            pub fn create_interface_scope(&self, itrfc: &Entity) -> Entity {
                InterfaceScope::new(&self.0.arena, itrfc).into()
            }
            pub fn create_package_scope(&self, pckg: &Entity) -> Entity {
                PackageScope::new(&self.0.arena, pckg).into()
            }
            pub fn create_value(&self, static_type: &Entity) -> Entity {
                Value::new(&self.0.arena, static_type).into()
            }
            pub fn create_package_property_import(
                &self,
                property: &Entity,
                location: Option<Location>,
            ) -> Entity {
                PackagePropertyImport::new(
                        &self.0.arena,
                        property,
                        location,
                        &self.0.any_type(),
                    )
                    .into()
            }
            pub fn create_package_wildcard_import(
                &self,
                package: &Entity,
                location: Option<Location>,
            ) -> Entity {
                PackageWildcardImport::new(
                        &self.0.arena,
                        package,
                        location,
                        &self.0.any_type(),
                    )
                    .into()
            }
            pub fn create_package_recursive_import(
                &self,
                package: &Entity,
                location: Option<Location>,
            ) -> Entity {
                PackageRecursiveImport::new(
                        &self.0.arena,
                        package,
                        location,
                        &self.0.any_type(),
                    )
                    .into()
            }
            pub fn create_undefined_constant(&self, static_type: &Entity) -> Entity {
                UndefinedConstant::new(&self.0.arena, static_type).into()
            }
            pub fn create_null_constant(&self, static_type: &Entity) -> Entity {
                NullConstant::new(&self.0.arena, static_type).into()
            }
            pub fn create_namespace_constant(
                &self,
                referenced_ns: &Entity,
            ) -> Result<Entity, DeferError> {
                Ok(
                    NamespaceConstant::new(
                            &self.0.arena,
                            referenced_ns,
                            &self.0.namespace_type().defer()?,
                        )
                        .into(),
                )
            }
            pub(crate) fn create_namespace_constant_with_static_type(
                &self,
                referenced_ns: &Entity,
                static_type: &Entity,
            ) -> Entity {
                NamespaceConstant::new(&self.0.arena, referenced_ns, static_type).into()
            }
            pub fn create_type_constant(
                &self,
                referenced_type: &Entity,
            ) -> Result<Entity, DeferError> {
                Ok(
                    TypeConstant::new(
                            &self.0.arena,
                            referenced_type,
                            &self.0.class_type().defer()?,
                        )
                        .into(),
                )
            }
            pub(crate) fn create_type_constant_with_static_type(
                &self,
                referenced_type: &Entity,
                static_type: &Entity,
            ) -> Entity {
                TypeConstant::new(&self.0.arena, referenced_type, static_type).into()
            }
            pub fn create_number_constant(
                &self,
                value: Number,
                static_type: &Entity,
            ) -> Entity {
                NumberConstant::new(&self.0.arena, value, static_type).into()
            }
            pub fn create_string_constant(
                &self,
                value: String,
                static_type: &Entity,
            ) -> Entity {
                StringConstant::new(&self.0.arena, value, static_type).into()
            }
            pub fn create_boolean_constant(
                &self,
                value: bool,
                static_type: &Entity,
            ) -> Entity {
                BooleanConstant::new(&self.0.arena, value, static_type).into()
            }
            pub fn create_this_object(&self, static_type: &Entity) -> Entity {
                ThisObject::new(&self.0.arena, static_type).into()
            }
            pub fn create_xml_reference_value(
                &self,
                base: &Entity,
                qualifier: Option<Entity>,
                key: &Entity,
            ) -> Entity {
                XmlReferenceValue::new(
                        &self.0.arena,
                        base,
                        qualifier,
                        key,
                        &self.0.any_type(),
                    )
                    .into()
            }
            pub fn create_dynamic_reference_value(
                &self,
                base: &Entity,
                qualifier: Option<Entity>,
                key: &Entity,
            ) -> Entity {
                DynamicReferenceValue::new(
                        &self.0.arena,
                        base,
                        qualifier,
                        key,
                        &self.0.any_type(),
                    )
                    .into()
            }
            pub fn create_array_element_reference_value(
                &self,
                base: &Entity,
                key: &Entity,
            ) -> Result<Entity, DeferError> {
                let st = base
                    .static_type(self.0)
                    .defer()?
                    .escape_of_non_nullable()
                    .array_element_type(self.0)?
                    .unwrap();
                Ok(ArrayElementReferenceValue::new(&self.0.arena, base, key, &st).into())
            }
            pub fn create_vector_element_reference_value(
                &self,
                base: &Entity,
                key: &Entity,
            ) -> Result<Entity, DeferError> {
                let st = base
                    .static_type(self.0)
                    .defer()?
                    .escape_of_non_nullable()
                    .vector_element_type(self.0)?
                    .unwrap();
                Ok(
                    VectorElementReferenceValue::new(&self.0.arena, base, key, &st)
                        .into(),
                )
            }
            pub fn create_static_reference_value(
                &self,
                base: &Entity,
                property: &Entity,
            ) -> Result<Entity, DeferError> {
                Ok(
                    StaticReferenceValue::new(
                            &self.0.arena,
                            base,
                            property,
                            &property.property_static_type(self.0).defer()?,
                        )
                        .into(),
                )
            }
            pub fn create_static_dynamic_reference_value(
                &self,
                base: &Entity,
                qualifier: Option<Entity>,
                key: &Entity,
            ) -> Entity {
                StaticDynamicReferenceValue::new(
                        &self.0.arena,
                        base,
                        qualifier,
                        key,
                        &self.0.any_type(),
                    )
                    .into()
            }
            pub fn create_instance_reference_value(
                &self,
                base: &Entity,
                property: &Entity,
            ) -> Result<Entity, DeferError> {
                Ok(
                    InstanceReferenceValue::new(
                            &self.0.arena,
                            base,
                            property,
                            &property.property_static_type(self.0).defer()?,
                        )
                        .into(),
                )
            }
            pub fn create_tuple_reference_value(
                &self,
                base: &Entity,
                index: usize,
            ) -> Entity {
                let st = base.static_type(self.0).element_types().get(index).unwrap();
                TupleReferenceValue::new(&self.0.arena, base, index, &st).into()
            }
            pub fn create_scope_reference_value(
                &self,
                base: &Entity,
                property: &Entity,
            ) -> Result<Entity, DeferError> {
                Ok(
                    ScopeReferenceValue::new(
                            &self.0.arena,
                            base,
                            property,
                            &property.property_static_type(self.0).defer()?,
                        )
                        .into(),
                )
            }
            pub fn create_dynamic_scope_reference_value(
                &self,
                base: &Entity,
                qualifier: Option<Entity>,
                key: &Entity,
            ) -> Entity {
                DynamicScopeReferenceValue::new(
                        &self.0.arena,
                        base,
                        qualifier,
                        key,
                        &self.0.any_type(),
                    )
                    .into()
            }
            pub fn create_package_reference_value(
                &self,
                base: &Entity,
                property: &Entity,
            ) -> Result<Entity, DeferError> {
                Ok(
                    PackageReferenceValue::new(
                            &self.0.arena,
                            base,
                            property,
                            &property.property_static_type(self.0).defer()?,
                        )
                        .into(),
                )
            }
            pub fn create_conversion_value(
                &self,
                base: &Entity,
                variant: ConversionKind,
                opt: bool,
                target: &Entity,
            ) -> Result<Entity, DeferError> {
                let mut st = if opt && !target.includes_null(self.0)? {
                    if target.is::<NonNullableType>() {
                        target.base()
                    } else {
                        self.create_nullable_type(target)
                    }
                } else {
                    target.clone()
                };
                if opt && !st.includes_null(self.0)? {
                    st = self.create_nullable_type(target);
                }
                Ok(
                    ConversionValue::new(&self.0.arena, base, variant, opt, target, &st)
                        .into(),
                )
            }
            pub fn create_non_null_value(
                &self,
                base: &Entity,
            ) -> Result<Entity, DeferError> {
                let orig_st = base.static_type(self.0).defer()?;
                let orig_st_esc = orig_st.escape_of_nullable();
                if orig_st_esc.includes_null(self.0)?
                    || orig_st_esc.includes_undefined(self.0)?
                {
                    let st = self.create_non_nullable_type(&orig_st_esc);
                    Ok(NonNullValue::new(&self.0.arena, base, &st).into())
                } else if orig_st_esc != orig_st {
                    Ok(NonNullValue::new(&self.0.arena, base, &orig_st_esc).into())
                } else {
                    Ok(base.clone())
                }
            }
            pub fn create_lambda_object(
                &self,
                activation: &Entity,
            ) -> Result<Entity, DeferError> {
                Ok(
                    LambdaObject::new(
                            &self.0.arena,
                            activation,
                            &self.0.function_type().defer()?,
                        )
                        .into(),
                )
            }
            pub fn create_filter_value(
                &self,
                scope: &Entity,
                static_type: &Entity,
            ) -> Entity {
                FilterValue::new(&self.0.arena, scope, static_type).into()
            }
            pub fn create_field_resolution(&self) -> Entity {
                FieldResolution::new(&self.0.arena).into()
            }
            pub fn create_declarative_field_destructuring_resolution(&self) -> Entity {
                DeclarativeFieldDestructuringResolution::new(&self.0.arena).into()
            }
            pub fn create_assignment_field_destructuring_resolution(&self) -> Entity {
                AssignmentFieldDestructuringResolution::new(&self.0.arena).into()
            }
        }
    }
    pub use factory::*;
    mod conversion {
        use crate::ns::*;
        pub enum ConversionKind {
            /// Implicit conversion.
            FromAny,
            /// Implicit conversion.
            ToAny,
            /// Implicit conversion between number types,
            /// where the base and target are as they are
            /// (not marked nullable or non-nullable).
            BetweenNumber,
            /// Implicit conversion to covariant type.
            ///
            /// Involved types either both include null or both do not include null.
            ToCovariant,
            /// Explicit conversion from `Object`, `Object!`, or `Object?`, to interface.
            ///
            /// Involved types either both include null or both do not include null.
            ObjectToItrfc,
            /// Implicit conversion to `Object`, `Object?` or `Object!`.
            ///
            /// Involved types either both include null or both do not include null.
            ItrfcToObject,
            /// Implicit conversion.
            NonNullableToNullable,
            /// Implicit conversion to `T?` where the `T` is a type
            /// that includes `null` without having been
            /// marked explicitly nullable.
            AsIsToNullable,
            /// Implicit conversion from `T!` to `T` where `T` is a type
            /// that includes `null` without having been
            /// marked explicitly nullable.
            NonNullableToAsIs,
            /// Explicit conversion.
            ///
            /// Involved types either both include null or both do not include null.
            ToContravariant,
            /// Explicit conversion.
            ///
            /// Restrictions:
            ///
            /// * Involved types either both include null or both do not include null.
            /// * Involved element types either both include null or both do not include null.
            ToCovariantVector,
            /// Explicit conversion.
            ///
            /// Restrictions:
            ///
            /// * Base type is either as-is, or non-nullable.
            /// * Target type is either as-is, or non-nullable.
            StringToEnum,
            /// Explicit conversion.
            ///
            /// Restrictions:
            ///
            /// * Base type is as-is.
            /// * Target type is either as-is, or non-nullable.
            NumberToEnum,
            /// Implicit conversion from `Function` to structural function type.
            ///
            /// Involved types either both include null or both do not include null.
            FunctionToStructuralFunction,
            /// Explicit conversion, where base type is a type parameter type,
            /// possibly having been marked non-nullable.
            FromTypeParameter,
            /// Explicit conversion where the type arguments to
            /// a parameterized type are changed. This conversion
            /// does not apply to `Vector.<T>`.
            ///
            /// Involved types either both include null or both do not include null.
            ///
            /// Involved types are each either a parameterized type without applied types
            /// or an application of a parameterized type.
            ParameterizedTypeAlter,
            /// Explicit type conversion.
            ToString,
            /// Explicit type conversion.
            ToBoolean,
            /// Explicit type conversion.
            ToNumber,
            /// Explicit type conversion.
            ToFloat,
            /// Explicit type conversion.
            ToUint,
            /// Explicit type conversion.
            ToInt,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ConversionKind {
            #[inline]
            fn clone(&self) -> ConversionKind {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ConversionKind {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ConversionKind {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ConversionKind {
            #[inline]
            fn eq(&self, other: &ConversionKind) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ConversionKind {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl ConversionKind {
            pub fn is_implicit(&self) -> bool {
                [
                    Self::FromAny,
                    Self::ToAny,
                    Self::BetweenNumber,
                    Self::ToCovariant,
                    Self::ItrfcToObject,
                    Self::NonNullableToNullable,
                    Self::AsIsToNullable,
                    Self::NonNullableToAsIs,
                    Self::FunctionToStructuralFunction,
                ]
                    .contains(self)
            }
        }
        pub struct ConversionMethods<'a>(pub &'a Database);
        impl<'a> ConversionMethods<'a> {
            pub fn constant(
                &self,
                value: &Entity,
                target_type: &Entity,
            ) -> Result<Option<Entity>, DeferError> {
                let from_type = value.static_type(self.0);
                if &from_type == target_type {
                    return Ok(Some(value.clone()));
                }
                if value.is::<InvalidationEntity>()
                    || from_type.is::<InvalidationEntity>()
                    || target_type.is::<InvalidationEntity>()
                {
                    return Ok(Some(self.0.invalidation_entity()));
                }
                if !value.is::<Constant>() {
                    return Ok(None);
                }
                if value.is::<UndefinedConstant>() {
                    if target_type.includes_undefined(self.0)? {
                        return Ok(
                            Some(self.0.factory().create_undefined_constant(target_type)),
                        );
                    } else if target_type.includes_null(self.0)? {
                        return Ok(
                            Some(self.0.factory().create_null_constant(target_type)),
                        );
                    }
                }
                if value.is::<NullConstant>()
                    && (target_type.includes_undefined(self.0)?
                        || target_type.includes_null(self.0)?)
                {
                    return Ok(Some(self.0.factory().create_null_constant(target_type)));
                }
                let object_type = self.0.object_type().defer()?;
                let target_esc_type = target_type.escape_of_nullable_or_non_nullable();
                if value.is::<NumberConstant>()
                    && (target_type.is::<AnyType>() || target_esc_type == object_type)
                {
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_number_constant(value.number_value(), target_type),
                        ),
                    );
                }
                if value.is::<NumberConstant>()
                    && self.0.numeric_types()?.contains(&target_esc_type)
                {
                    let v = value.number_value().convert_type(target_type, self.0)?;
                    return Ok(
                        Some(self.0.factory().create_number_constant(v, target_type)),
                    );
                }
                if (target_type.is::<NullableType>()
                    && target_type.base()
                        == from_type.escape_of_nullable_or_non_nullable())
                    || (target_type.is::<NonNullableType>()
                        && target_type.base()
                            == from_type.escape_of_nullable_or_non_nullable())
                {
                    let new_k = value.clone_constant(self.0);
                    new_k.set_static_type(target_type.clone());
                    return Ok(Some(new_k));
                }
                Ok(None)
            }
            pub fn implicit(
                &self,
                value: &Entity,
                target_type: &Entity,
                optional: bool,
            ) -> Result<Option<Entity>, DeferError> {
                let from_type = value.static_type(self.0);
                if &from_type == target_type {
                    return Ok(Some(value.clone()));
                }
                let kc = self.constant(value, target_type)?;
                if kc.is_some() {
                    return Ok(kc);
                }
                if from_type.is::<AnyType>() {
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_conversion_value(
                                    value,
                                    ConversionKind::FromAny,
                                    optional,
                                    target_type,
                                )?,
                        ),
                    );
                }
                if target_type.is::<AnyType>() {
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_conversion_value(
                                    value,
                                    ConversionKind::ToAny,
                                    optional,
                                    target_type,
                                )?,
                        ),
                    );
                }
                if self.0.numeric_types()?.contains(&from_type)
                    && self.0.numeric_types()?.contains(&target_type)
                {
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_conversion_value(
                                    value,
                                    ConversionKind::BetweenNumber,
                                    optional,
                                    target_type,
                                )?,
                        ),
                    );
                }
                let from_type_esc = from_type.escape_of_nullable_or_non_nullable();
                let target_type_esc = target_type.escape_of_nullable_or_non_nullable();
                if from_type_esc.is_subtype_of(&target_type_esc, self.0)? {
                    let both_include_null = from_type.includes_null(self.0)?
                        && target_type.includes_null(self.0)?;
                    let both_dont_include_null = !from_type.includes_null(self.0)?
                        && !target_type.includes_null(self.0)?;
                    if both_include_null || both_dont_include_null {
                        return Ok(
                            Some(
                                self
                                    .0
                                    .factory()
                                    .create_conversion_value(
                                        value,
                                        ConversionKind::ToCovariant,
                                        optional,
                                        target_type,
                                    )?,
                            ),
                        );
                    }
                }
                let object_type = self.0.object_type().defer()?;
                if target_type_esc == object_type
                    && from_type_esc.is_interface_type_possibly_after_sub()
                {
                    let both_include_null = from_type.includes_null(self.0)?
                        && target_type.includes_null(self.0)?;
                    let both_dont_include_null = !from_type.includes_null(self.0)?
                        && !target_type.includes_null(self.0)?;
                    if both_include_null || both_dont_include_null {
                        return Ok(
                            Some(
                                self
                                    .0
                                    .factory()
                                    .create_conversion_value(
                                        value,
                                        ConversionKind::ItrfcToObject,
                                        optional,
                                        target_type,
                                    )?,
                            ),
                        );
                    }
                }
                if target_type.is::<NullableType>() {
                    if from_type.is::<NonNullableType>()
                        && from_type.base() == target_type.base()
                    {
                        return Ok(
                            Some(
                                self
                                    .0
                                    .factory()
                                    .create_conversion_value(
                                        value,
                                        ConversionKind::NonNullableToNullable,
                                        optional,
                                        target_type,
                                    )?,
                            ),
                        );
                    }
                    if from_type == target_type.base() {
                        return Ok(
                            Some(
                                self
                                    .0
                                    .factory()
                                    .create_conversion_value(
                                        value,
                                        ConversionKind::AsIsToNullable,
                                        optional,
                                        target_type,
                                    )?,
                            ),
                        );
                    }
                }
                if from_type.is::<NonNullableType>() && target_type == &from_type.base()
                {
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_conversion_value(
                                    value,
                                    ConversionKind::NonNullableToAsIs,
                                    optional,
                                    target_type,
                                )?,
                        ),
                    );
                }
                let function_type = self.0.function_type().defer()?;
                if from_type_esc == function_type && target_type_esc.is::<FunctionType>()
                {
                    let both_include_null = from_type.includes_null(self.0)?
                        && target_type.includes_null(self.0)?;
                    let both_dont_include_null = !from_type.includes_null(self.0)?
                        && !target_type.includes_null(self.0)?;
                    if both_include_null || both_dont_include_null {
                        return Ok(
                            Some(
                                self
                                    .0
                                    .factory()
                                    .create_conversion_value(
                                        value,
                                        ConversionKind::FunctionToStructuralFunction,
                                        optional,
                                        target_type,
                                    )?,
                            ),
                        );
                    }
                }
                Ok(None)
            }
            pub fn explicit(
                &self,
                value: &Entity,
                target_type: &Entity,
                optional: bool,
            ) -> Result<Option<Entity>, DeferError> {
                let from_type = value.static_type(self.0);
                if &from_type == target_type {
                    return Ok(Some(value.clone()));
                }
                let ic = self.implicit(value, target_type, optional)?;
                if ic.is_some() {
                    return Ok(ic);
                }
                let from_type_esc = from_type.escape_of_nullable_or_non_nullable();
                let target_type_esc = target_type.escape_of_nullable_or_non_nullable();
                let object_type = self.0.object_type().defer()?;
                if from_type_esc == object_type
                    && target_type_esc.is_interface_type_possibly_after_sub()
                {
                    let both_include_null = from_type.includes_null(self.0)?
                        && target_type.includes_null(self.0)?;
                    let both_dont_include_null = !from_type.includes_null(self.0)?
                        && !target_type.includes_null(self.0)?;
                    if both_include_null || both_dont_include_null {
                        return Ok(
                            Some(
                                self
                                    .0
                                    .factory()
                                    .create_conversion_value(
                                        value,
                                        ConversionKind::ObjectToItrfc,
                                        optional,
                                        target_type,
                                    )?,
                            ),
                        );
                    }
                }
                if from_type_esc.is_ascending_type_of(&target_type_esc, self.0)? {
                    let both_include_null = from_type.includes_null(self.0)?
                        && target_type.includes_null(self.0)?;
                    let both_dont_include_null = !from_type.includes_null(self.0)?
                        && !target_type.includes_null(self.0)?;
                    if both_include_null || both_dont_include_null {
                        return Ok(
                            Some(
                                self
                                    .0
                                    .factory()
                                    .create_conversion_value(
                                        value,
                                        ConversionKind::ToContravariant,
                                        optional,
                                        target_type,
                                    )?,
                            ),
                        );
                    }
                }
                if let Some(el_subtype) = from_type_esc.vector_element_type(self.0)? {
                    if let Some(el_basetype) = target_type_esc
                        .vector_element_type(self.0)?
                    {
                        let asc = el_basetype
                            .escape_of_nullable_or_non_nullable()
                            .is_ascending_type_of(
                                &el_subtype.escape_of_nullable_or_non_nullable(),
                                self.0,
                            )?;
                        let both_el_include_null = el_basetype.includes_null(self.0)?
                            && el_subtype.includes_null(self.0)?;
                        let both_el_dont_include_null = !el_basetype
                            .includes_null(self.0)?
                            && !el_subtype.includes_null(self.0)?;
                        if asc && (both_el_include_null || both_el_dont_include_null) {
                            let both_include_null = from_type.includes_null(self.0)?
                                && target_type.includes_null(self.0)?;
                            let both_dont_include_null = !from_type
                                .includes_null(self.0)?
                                && !target_type.includes_null(self.0)?;
                            if both_include_null || both_dont_include_null {
                                return Ok(
                                    Some(
                                        self
                                            .0
                                            .factory()
                                            .create_conversion_value(
                                                value,
                                                ConversionKind::ToCovariantVector,
                                                optional,
                                                target_type,
                                            )?,
                                    ),
                                );
                            }
                        }
                    }
                }
                let string_type = self.0.string_type().defer()?;
                if from_type.escape_of_non_nullable() == string_type
                    && target_type.escape_of_non_nullable().is::<EnumType>()
                {
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_conversion_value(
                                    value,
                                    ConversionKind::StringToEnum,
                                    optional,
                                    target_type,
                                )?,
                        ),
                    );
                }
                let number_type = self.0.number_type().defer()?;
                if from_type == number_type
                    && target_type.escape_of_non_nullable().is::<EnumType>()
                {
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_conversion_value(
                                    value,
                                    ConversionKind::NumberToEnum,
                                    optional,
                                    target_type,
                                )?,
                        ),
                    );
                }
                if target_type == &string_type {
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_conversion_value(
                                    value,
                                    ConversionKind::ToString,
                                    optional,
                                    target_type,
                                )?,
                        ),
                    );
                }
                if target_type == &number_type {
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_conversion_value(
                                    value,
                                    ConversionKind::ToNumber,
                                    optional,
                                    target_type,
                                )?,
                        ),
                    );
                }
                let float_type = self.0.float_type().defer()?;
                if target_type == &float_type {
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_conversion_value(
                                    value,
                                    ConversionKind::ToFloat,
                                    optional,
                                    target_type,
                                )?,
                        ),
                    );
                }
                let uint_type = self.0.uint_type().defer()?;
                if target_type == &uint_type {
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_conversion_value(
                                    value,
                                    ConversionKind::ToUint,
                                    optional,
                                    target_type,
                                )?,
                        ),
                    );
                }
                let int_type = self.0.int_type().defer()?;
                if target_type == &int_type {
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_conversion_value(
                                    value,
                                    ConversionKind::ToInt,
                                    optional,
                                    target_type,
                                )?,
                        ),
                    );
                }
                let boolean_type = self.0.boolean_type().defer()?;
                if target_type == &boolean_type {
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_conversion_value(
                                    value,
                                    ConversionKind::ToBoolean,
                                    optional,
                                    target_type,
                                )?,
                        ),
                    );
                }
                if from_type.escape_of_non_nullable().is::<TypeParameterType>() {
                    return Ok(
                        Some(
                            self
                                .0
                                .factory()
                                .create_conversion_value(
                                    value,
                                    ConversionKind::FromTypeParameter,
                                    optional,
                                    target_type,
                                )?,
                        ),
                    );
                }
                if from_type_esc.is_parameterized_type_or_type_after_sub()
                    && target_type_esc.is_parameterized_type_or_type_after_sub()
                {
                    let from_origin = from_type_esc
                        .origin_or_parameterized_type_identity()
                        .unwrap();
                    let target_origin = target_type_esc
                        .origin_or_parameterized_type_identity()
                        .unwrap();
                    let vector_type = self.0.vector_type().defer()?;
                    let both_include_null = from_type.includes_null(self.0)?
                        && target_type.includes_null(self.0)?;
                    let both_dont_include_null = !from_type.includes_null(self.0)?
                        && !target_type.includes_null(self.0)?;
                    if from_origin == target_origin && from_origin != vector_type
                        && (both_include_null || both_dont_include_null)
                    {
                        return Ok(
                            Some(
                                self
                                    .0
                                    .factory()
                                    .create_conversion_value(
                                        value,
                                        ConversionKind::ParameterizedTypeAlter,
                                        optional,
                                        target_type,
                                    )?,
                            ),
                        );
                    }
                }
                Ok(None)
            }
        }
    }
    pub use conversion::*;
    mod apply_type {
        use crate::ns::*;
        /// Apply types to a parameterized type across several entities.
        pub struct ApplyType<'a>(pub &'a Database);
        impl<'a> ApplyType<'a> {
            pub fn exec(
                &mut self,
                thing: &Entity,
                type_params: &SharedArray<Entity>,
                substitute_types: &SharedArray<Entity>,
            ) -> Entity {
                if thing.is::<UnresolvedEntity>() || thing.is::<InvalidationEntity>() {
                    return thing.clone();
                } else if thing.is::<Type>() {
                    if thing.is::<FunctionType>() {
                        let result_type = thing
                            .result_type()
                            .apply_type(self.0, type_params, substitute_types);
                        let mut params: Vec<Rc<SemanticFunctionTypeParameter>> = Vec::new();
                        for param in thing.params().iter() {
                            params
                                .push(
                                    Rc::new(
                                        param.apply_type(self.0, type_params, substitute_types),
                                    ),
                                );
                        }
                        return self
                            .0
                            .factory()
                            .create_function_type(params, result_type);
                    } else if thing.is::<NullableType>() {
                        let base = &thing
                            .base()
                            .apply_type(self.0, type_params, substitute_types);
                        return self.0.factory().create_nullable_type(base);
                    } else if thing.is::<NonNullableType>() {
                        let base = &thing
                            .base()
                            .apply_type(self.0, type_params, substitute_types);
                        return self.0.factory().create_non_nullable_type(base);
                    } else if thing.is::<TupleType>() {
                        let el: Vec<Entity> = thing
                            .element_types()
                            .iter()
                            .map(|t| t.apply_type(self.0, type_params, substitute_types))
                            .collect();
                        return self.0.factory().create_tuple_type(el);
                    } else if thing.is::<TypeAfterSubstitution>() {
                        let new_substitute_types: SharedArray<Entity> = thing
                            .substitute_types()
                            .iter()
                            .map(|t| t.apply_type(self.0, type_params, substitute_types))
                            .collect();
                        return self
                            .0
                            .factory()
                            .create_type_after_substitution(
                                &thing.origin(),
                                &new_substitute_types,
                            );
                    } else if thing.is::<TypeParameterType>() {
                        let i = type_params.index_of(&thing);
                        if let Some(i) = i {
                            return substitute_types.get(i).unwrap();
                        }
                    }
                    return thing.clone();
                } else if thing.is::<VariableSlot>() {
                    self.0
                        .factory()
                        .create_variable_slot_after_substitution(
                            thing,
                            type_params,
                            substitute_types,
                        )
                } else if thing.is::<VirtualSlot>() {
                    self.0
                        .factory()
                        .create_virtual_slot_after_substitution(
                            thing,
                            type_params,
                            substitute_types,
                        )
                } else if thing.is::<MethodSlot>() {
                    self.0
                        .factory()
                        .create_method_slot_after_substitution(
                            thing,
                            type_params,
                            substitute_types,
                        )
                } else {
                    {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        const fn panic_cold_explicit() -> ! {
                            ::core::panicking::panic_explicit()
                        }
                        panic_cold_explicit();
                    }
                }
            }
        }
    }
    pub use apply_type::*;
    mod unused {
        use crate::ns::*;
        /// Manage unused entities.
        pub struct Unused<'a>(pub &'a Database);
        impl<'a> Unused<'a> {
            pub fn all(&self) -> std::cell::Ref<Vec<Entity>> {
                self.0.unused_things()
            }
            pub fn is_unused(&self, entity: &Entity) -> bool {
                self.0.is_unused(entity)
            }
            pub fn add(&self, thing: &Entity) {
                self.0.add_unused_thing(thing);
            }
            pub fn add_nominal(&self, thing: &Entity) {
                let name = thing.name();
                if name.in_public_or_protected_ns() || name.local_name().starts_with('_')
                {
                    return;
                }
                self.add(thing);
            }
            pub fn mark_used(&self, property: &Entity) {
                if property.is::<InvalidationEntity>() {
                    return;
                }
                let qn = property.name();
                if !qn.in_public_or_protected_ns() {
                    if property.is_entity_after_substitution() {
                        self.mark_used(&property.origin());
                    } else {
                        self.0.remove_unused_thing(property);
                    }
                }
            }
        }
    }
    pub use unused::*;
}
pub mod util {
    pub use hydroperfox_smodel::util::{SharedArray, SharedMap, shared_array, shared_map};
    pub use by_address::ByAddress;
    pub use maplit::{hashmap, hashset};
}
/// Unified compiler module.
pub mod ns {
    pub use mxmlextrema_as3parser::ns::*;
    pub use super::errors::*;
    pub use super::semantics::*;
    pub use super::util::*;
}
